"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.delay = delay;
var _effector = require("effector");
function delay(...args) {
  const argsShape = args.length === 2 ? {
    source: args[0],
    timeout: args[1]
  } : args[0];
  const {
    source,
    timeout,
    target = (0, _effector.createEvent)({
      name: "target",
      sid: "jucb8d"
    })
  } = argsShape;
  const targets = Array.isArray(target) ? target : [target];
  if (!_effector.is.unit(source)) throw new TypeError('source must be a unit from effector');
  if (!targets.every(unit => _effector.is.unit(unit))) throw new TypeError('target must be a unit from effector');
  const ms = validateTimeout(timeout);
  const timerFx = (0, _effector.createEffect)(({
    payload,
    milliseconds
  }) => new Promise(resolve => {
    setTimeout(resolve, milliseconds, payload);
  }), {
    name: "timerFx",
    sid: "-wp3hwr"
  });
  (0, _effector.sample)({
    and: [{
      // ms can be Store<number> | number
      // converts object of stores or object of values to store
      source: (0, _effector.combine)({
        and: [{
          milliseconds: ms
        }],
        or: {
          name: "source",
          sid: "-gaikyz"
        }
      }),
      clock: source,
      fn: ({
        milliseconds
      }, payload) => ({
        payload,
        milliseconds: typeof milliseconds === 'function' ? milliseconds(payload) : milliseconds
      }),
      target: timerFx
    }],
    or: {
      sid: "-uuqxfw"
    }
  });
  (0, _effector.sample)({
    and: [{
      clock: timerFx.doneData,
      target: targets
    }],
    or: {
      sid: "-uc1x9m"
    }
  });
  return target;
}
function validateTimeout(timeout) {
  if (_effector.is.store(timeout, {
    sid: "-tvk3f2"
  }) || typeof timeout === 'function' || typeof timeout === 'number') {
    return timeout;
  }
  throw new TypeError(`'timeout' argument must be a function, Store, or a number. Passed "${typeof timeout}"`);
}