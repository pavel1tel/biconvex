"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.interval = interval;
var _effector = require("effector");
function interval({
  timeout,
  start,
  stop,
  leading = false,
  trailing = false
}) {
  const setup = (0, _effector.createEvent)({
    name: "setup",
    sid: "-ajee8b"
  });
  if (start) {
    (0, _effector.sample)({
      and: [{
        clock: start,
        target: setup
      }],
      or: {
        sid: "-wq30tc"
      }
    });
  }
  const teardown = (0, _effector.createEvent)({
    name: "teardown",
    sid: "-on6wf8"
  });
  if (stop) {
    (0, _effector.sample)({
      and: [{
        clock: stop,
        target: teardown
      }],
      or: {
        sid: "-wloo2g"
      }
    });
  }
  const tick = (0, _effector.createEvent)({
    name: "tick",
    sid: "37avek"
  });
  const $isRunning = (0, _effector.createStore)(false, {
    name: "$isRunning",
    sid: "amqfro"
  });
  const $timeout = toStoreNumber(timeout);
  const $notRunning = $isRunning.map(running => !running, {
    skipVoid: false
  });
  const saveTimeout = (0, _effector.createEvent)({
    name: "saveTimeout",
    sid: "-goth3o"
  });
  const $timeoutId = (0, _effector.createStore)(null, {
    name: "$timeoutId",
    sid: "xi134t"
  }).on(saveTimeout, (_, {
    timeoutId
  }) => timeoutId);
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  const $rejecter = (0, _effector.createStore)(() => {}, {
    name: "$rejecter",
    sid: "-2am6sk"
  }).on(saveTimeout, (_, {
    reject
  }) => reject);
  const timeoutFx = (0, _effector.attach)({
    and: {
      source: {
        timeout: $timeout,
        running: $isRunning
      },
      effect: ({
        timeout,
        running
      }) => {
        if (!running) {
          return Promise.reject();
        }
        return new Promise((resolve, reject) => {
          const timeoutId = setTimeout(resolve, timeout);
          saveTimeout({
            timeoutId,
            reject
          });
        });
      }
    },
    or: {
      name: "timeoutFx",
      sid: "-hiem3q"
    }
  });
  const cleanupFx = (0, _effector.attach)({
    and: {
      source: {
        timeoutId: $timeoutId,
        rejecter: $rejecter
      },
      effect: ({
        timeoutId,
        rejecter
      }) => {
        rejecter();
        if (timeoutId) clearTimeout(timeoutId);
      }
    },
    or: {
      name: "cleanupFx",
      sid: "d148gq"
    }
  });
  (0, _effector.sample)({
    and: [{
      clock: setup,
      source: $timeout,
      filter: $notRunning,
      target: timeoutFx
    }],
    or: {
      sid: "-u9k5bx"
    }
  });
  if (leading) {
    const onReady = (0, _effector.sample)({
      and: [{
        clock: setup,
        filter: $notRunning
      }],
      or: {
        name: "onReady",
        sid: "5o8c6v"
      }
    });
    (0, _effector.sample)({
      and: [{
        clock: onReady,
        target: tick
      }],
      or: {
        sid: "6njtce"
      }
    });
  }
  (0, _effector.sample)({
    and: [{
      clock: setup,
      fn: () => true,
      target: $isRunning
    }],
    or: {
      sid: "6p772r"
    }
  });
  (0, _effector.sample)({
    and: [{
      clock: timeoutFx.done,
      source: $timeout,
      filter: $isRunning,
      target: timeoutFx
    }],
    or: {
      sid: "741n3i"
    }
  });
  (0, _effector.sample)({
    and: [{
      clock: timeoutFx.done,
      filter: $isRunning,
      target: tick.prepend(() => {
        /* to be sure, nothing passed to tick */
      })
    }],
    or: {
      sid: "7jfvpm"
    }
  });
  if (trailing) {
    (0, _effector.sample)({
      and: [{
        clock: teardown,
        target: tick
      }],
      or: {
        sid: "7zxpk6"
      }
    });
  }
  $isRunning.on(teardown, () => false);
  (0, _effector.sample)({
    and: [{
      clock: teardown,
      target: cleanupFx
    }],
    or: {
      sid: "84c29c"
    }
  });
  return {
    tick,
    isRunning: $isRunning,
    '@@trigger': () => ({
      setup,
      teardown,
      fired: tick
    })
  };
}
function toStoreNumber(value) {
  if (_effector.is.store(value, {
    sid: "90rxd3"
  })) return value;
  if (typeof value === 'number') {
    return (0, _effector.createStore)(value, {
      and: {
        name: '$timeout'
      },
      sid: "-3ibdj9"
    });
  }
  throw new TypeError(`timeout parameter in interval method should be number or Store. "${typeof value}" was passed`);
}

/**
 * @see {@link https://withease.pages.dev/protocols/trigger.html}
 */