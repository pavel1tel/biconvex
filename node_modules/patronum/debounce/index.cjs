"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.debounce = debounce;
var _effector = require("effector");
function debounce(...args) {
  var _ref;
  const argsShape = args.length === 2 ? {
    source: args[0],
    timeout: args[1]
  } : args[0];
  const {
    source,
    timeout,
    target,
    name
  } = argsShape;
  if (!_effector.is.unit(source)) throw new TypeError('source must be unit from effector');
  if (_effector.is.domain(source, {
    sid: "jsc7s2"
  })) throw new TypeError('source cannot be domain');
  const $timeout = toStoreNumber(timeout);
  const saveCancel = (0, _effector.createEvent)({
    name: "saveCancel",
    sid: "-kec0n3"
  });
  const $canceller = (0, _effector.createStore)([], {
    and: {
      serialize: 'ignore'
    },
    name: "$canceller",
    sid: "-tfm9fg"
  }).on(saveCancel, (_, payload) => payload);
  const tick = (_ref = target) !== null && _ref !== void 0 ? _ref : (0, _effector.createEvent)({
    name: "tick",
    sid: "-50e2rn"
  });
  const timerFx = (0, _effector.attach)({
    and: {
      name: name || `debounce(${source?.shortName || source.kind}) effect`,
      source: $canceller,
      effect([timeoutId, rejectPromise], timeout) {
        if (timeoutId) clearTimeout(timeoutId);
        if (rejectPromise) rejectPromise();
        return new Promise((resolve, reject) => {
          saveCancel([setTimeout(resolve, timeout), reject]);
        });
      }
    },
    or: {
      name: "timerFx",
      sid: "-jwso4j"
    }
  });
  $canceller.reset(timerFx.done);

  // It's ok - nothing will ever start unless source is triggered
  const $payload = (0, _effector.createStore)([], {
    and: {
      serialize: 'ignore',
      skipVoid: false
    },
    name: "$payload",
    sid: "-x9cllg"
  }).on(source, (_, payload) => [payload]);
  const $canTick = (0, _effector.createStore)(true, {
    and: {
      serialize: 'ignore'
    },
    name: "$canTick",
    sid: "8r2952"
  });
  const triggerTick = (0, _effector.createEvent)({
    name: "triggerTick",
    sid: "-781myl"
  });
  $canTick.on(triggerTick, () => false).on([tick,
  // debounce timeout should be restarted on timeout change
  $timeout,
  // debounce timeout can be restarted in later ticks
  timerFx], () => true);
  const requestTick = (0, _effector.merge)([source,
  // debounce timeout is restarted on timeout change
  (0, _effector.sample)({
    and: [{
      clock: $timeout,
      filter: timerFx.pending
    }],
    or: {
      name: "requestTick",
      sid: "-khrpxp"
    }
  })], {
    name: "requestTick",
    sid: "2k0852"
  });
  (0, _effector.sample)({
    and: [{
      clock: requestTick,
      filter: $canTick,
      target: triggerTick
    }],
    or: {
      sid: "-31h8q8"
    }
  });
  (0, _effector.sample)({
    and: [{
      source: $timeout,
      clock: triggerTick,
      target: timerFx
    }],
    or: {
      sid: "-2y6h62"
    }
  });
  (0, _effector.sample)({
    and: [{
      source: $payload,
      clock: timerFx.done,
      fn: ([payload]) => payload,
      target: tick
    }],
    or: {
      sid: "-2jc15b"
    }
  });
  return tick;
}
function toStoreNumber(value) {
  if (_effector.is.store(value, {
    sid: "-21qm2b"
  })) return value;
  if (typeof value === 'number') {
    if (value < 0 || !Number.isFinite(value)) throw new Error(`timeout must be positive number or zero. Received: "${value}"`);
    return (0, _effector.createStore)(value, {
      and: {
        name: '$timeout'
      },
      sid: "kbepy4"
    });
  }
  throw new TypeError(`timeout parameter in interval method should be number or Store. "${typeof value}" was passed`);
}