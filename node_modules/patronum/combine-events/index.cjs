"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.combineEvents = combineEvents;
var _effector = require("effector");
function combineEvents(args) {
  const argsShape = isEventsShape(args) ? {
    events: args
  } : args;
  const {
    events,
    reset,
    target = (0, _effector.createEvent)({
      name: "target",
      sid: "p73fff"
    })
  } = argsShape;
  if (!(_effector.is.unit(target) && _effector.is.targetable(target))) throwError('target should be a targetable unit');
  if (reset && !_effector.is.unit(reset)) throwError('reset should be a unit');
  (0, _effector.withRegion)(target, () => {
    const keys = Object.keys(events);
    const defaultShape = Array.isArray(events) ? [...keys].fill('') : {};
    const $counter = (0, _effector.createStore)(keys.length, {
      and: {
        serialize: 'ignore'
      },
      name: "$counter",
      sid: "-ahoahx"
    });
    const $results = (0, _effector.createStore)(defaultShape, {
      and: {
        serialize: 'ignore'
      },
      name: "$results",
      sid: "oy8iyn"
    });
    (0, _effector.sample)({
      and: [{
        source: target,
        target: $counter.reinit
      }],
      or: {
        sid: "blex0c"
      }
    });
    $results.reset(target);
    if (reset) {
      (0, _effector.sample)({
        and: [{
          source: reset,
          target: $counter.reinit
        }],
        or: {
          sid: "bnm3fi"
        }
      });
      $results.reset(reset);
    }
    for (const key of keys) {
      const $isDone = (0, _effector.createStore)(false, {
        and: {
          serialize: 'ignore'
        },
        name: "$isDone",
        sid: "-rf2fac"
      }).on(events[key], () => true).reset(target);
      if (reset) {
        $isDone.reset(reset);
      }
      $counter.on($isDone, value => value - 1);
      $results.on(events[key], (shape, payload) => {
        const newShape = Array.isArray(shape) ? [...shape] : {
          ...shape
        };
        newShape[key] = payload;
        return newShape;
      });
    }
    const eventsTrriggered = (0, _effector.sample)({
      and: [{
        source: $results,
        clock: [...Object.values(events)]
      }],
      or: {
        name: "eventsTrriggered",
        sid: "-lro8bq"
      }
    });
    (0, _effector.sample)({
      and: [{
        source: eventsTrriggered,
        filter: $counter.map(value => value === 0, {
          skipVoid: false
        }),
        target: target
      }],
      or: {
        sid: "-dlkr2s"
      }
    });
  });
  return target;
}
function isEventsShape(args) {
  return Object.keys(args).some(key => !['events', 'reset', 'target'].includes(key) && _effector.is.unit(args[key]));
}
function throwError(message) {
  throw new Error(message);
}