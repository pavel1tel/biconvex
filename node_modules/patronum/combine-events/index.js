function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
import { createEvent, createStore, is, sample, withRegion } from 'effector';
export function combineEvents(args) {
  var argsShape = isEventsShape(args) ? {
    events: args
  } : args;
  var {
    events,
    reset,
    target = createEvent({
      name: "target",
      sid: "p73fff"
    })
  } = argsShape;
  if (!(is.unit(target) && is.targetable(target))) throwError('target should be a targetable unit');
  if (reset && !is.unit(reset)) throwError('reset should be a unit');
  withRegion(target, () => {
    var keys = Object.keys(events);
    var defaultShape = Array.isArray(events) ? [...keys].fill('') : {};
    var $counter = createStore(keys.length, {
      and: {
        serialize: 'ignore'
      },
      name: "$counter",
      sid: "-ahoahx"
    });
    var $results = createStore(defaultShape, {
      and: {
        serialize: 'ignore'
      },
      name: "$results",
      sid: "oy8iyn"
    });
    sample({
      and: [{
        source: target,
        target: $counter.reinit
      }],
      or: {
        sid: "blex0c"
      }
    });
    $results.reset(target);
    if (reset) {
      sample({
        and: [{
          source: reset,
          target: $counter.reinit
        }],
        or: {
          sid: "bnm3fi"
        }
      });
      $results.reset(reset);
    }
    var _loop = function _loop(key) {
      var $isDone = createStore(false, {
        and: {
          serialize: 'ignore'
        },
        name: "$isDone",
        sid: "-rf2fac"
      }).on(events[key], () => true).reset(target);
      if (reset) {
        $isDone.reset(reset);
      }
      $counter.on($isDone, value => value - 1);
      $results.on(events[key], (shape, payload) => {
        var newShape = Array.isArray(shape) ? [...shape] : _objectSpread({}, shape);
        newShape[key] = payload;
        return newShape;
      });
    };
    for (var key of keys) {
      _loop(key);
    }
    var eventsTrriggered = sample({
      and: [{
        source: $results,
        clock: [...Object.values(events)]
      }],
      or: {
        name: "eventsTrriggered",
        sid: "-lro8bq"
      }
    });
    sample({
      and: [{
        source: eventsTrriggered,
        filter: $counter.map(value => value === 0, {
          skipVoid: false
        }),
        target: target
      }],
      or: {
        sid: "-dlkr2s"
      }
    });
  });
  return target;
}
function isEventsShape(args) {
  return Object.keys(args).some(key => !['events', 'reset', 'target'].includes(key) && is.unit(args[key]));
}
function throwError(message) {
  throw new Error(message);
}