import * as effector from 'effector';
import { Store, Event, Effect, EventCallable, StoreWritable, Clock, NoInfer, EffectParams } from 'effector';
import { History } from 'history';

type RouteParams = Record<string, any>;
type RouteQuery = Record<string, any>;
type RouteParamsAndQuery<Params extends RouteParams> = {
    params: Params;
    query: RouteQuery;
};
interface NavigateParams<Params extends RouteParams> extends RouteParamsAndQuery<Params> {
    replace?: boolean;
}
type RouteInstance<Params extends RouteParams> = {
    $isOpened: Store<boolean>;
    $params: Store<Params>;
    $query: Store<RouteQuery>;
    opened: Event<RouteParamsAndQuery<Params>>;
    updated: Event<RouteParamsAndQuery<Params>>;
    closed: Event<void>;
    navigate: Effect<NavigateParams<Params>, NavigateParams<Params>>;
    open: Effect<Params extends EmptyObject ? void : Params, RouteParamsAndQuery<Params>>;
    kind: typeof Kind.ROUTE;
};
interface RouteInstanceInternal<Params extends RouteParams> extends RouteInstance<Params> {
    opened: EventCallable<RouteParamsAndQuery<Params>>;
    updated: EventCallable<RouteParamsAndQuery<Params>>;
    closed: EventCallable<void>;
}
type RouteObject<Params extends RouteParams> = {
    route: RouteInstance<Params>;
    path: string;
};
interface RouteObjectInternal<Params extends RouteParams> extends RouteObject<Params> {
    route: RouteInstanceInternal<Params>;
}
type UnmappedRouteObject<Params extends RouteParams> = {
    route: RouteInstance<Params> | RouteInstance<Params>[];
    path: string;
};
type HistoryPushParams = {
    history: History;
    path: string;
    params: RouteParams;
    query: RouteQuery;
    method: "replace" | "push";
};
type HistoryBackForwardParams = History;
type ParamsSerializer = {
    write: (params: RouteParams) => string;
    read: (query: string) => RouteParams;
};
type PathCreator<Params extends RouteParams> = string;
declare const Kind: {
    ROUTE: symbol;
};
type EmptyObject = {
    [key in string]: never;
};

type CreateRouteParams = {
    filter?: Store<boolean>;
};
declare function createRoute<Params extends RouteParams = {}>(params?: CreateRouteParams): RouteInstance<Params>;

interface RouterControls {
    $query: StoreWritable<RouteQuery>;
    back: EventCallable<void>;
    forward: EventCallable<void>;
}
declare function createRouterControls(): RouterControls;

declare function createHistoryRouter({ base, routes, notFoundRoute, hydrate, serialize, controls, }: {
    base?: string;
    routes: UnmappedRouteObject<any>[];
    notFoundRoute?: RouteInstance<any>;
    serialize?: ParamsSerializer;
    hydrate?: boolean;
    controls?: ReturnType<typeof createRouterControls>;
}): {
    $path: effector.StoreWritable<string>;
    $activeRoutes: effector.StoreWritable<RouteInstance<any>[]>;
    $history: effector.StoreWritable<History>;
    setHistory: effector.EventCallable<History>;
    $query: effector.StoreWritable<RouteQuery>;
    back: effector.EventCallable<void>;
    forward: effector.EventCallable<void>;
    push: effector.Effect<Omit<HistoryPushParams, "history">, HistoryPushParams, Error>;
    routes: RouteObjectInternal<any>[];
    initialized: effector.EventCallable<{
        activeRoutes: RouteInstance<any>[];
        path: string;
        query: RouteQuery;
    }>;
    routeNotFound: effector.EventCallable<void>;
};

/** Detects whether passed value is a `RouteInstance<any>` or not */
declare function isRoute(route: RouteInstance<any> | unknown): route is RouteInstance<any>;

type RedirectParams<T, Params extends RouteParams> = Params extends EmptyObject ? {
    clock?: Clock<T>;
    route: RouteInstance<Params>;
    query?: ((clock: T) => RouteQuery) | Store<RouteQuery> | RouteQuery;
    replace?: ((clock: T) => boolean) | Store<boolean> | boolean;
} : {
    clock?: Clock<T>;
    route: RouteInstance<Params>;
    params: ((clock: T) => Params) | Store<Params> | Params;
    query?: ((clock: T) => RouteQuery) | Store<RouteQuery> | RouteQuery;
    replace?: ((clock: T) => boolean) | Store<boolean> | boolean;
} | {
    clock?: Clock<{
        params: Params;
        query?: RouteQuery;
        replace?: boolean;
    }>;
    route: RouteInstance<Params>;
    params?: ((clock: T) => Params) | Store<Params> | Params;
    query?: ((clock: T) => RouteQuery) | Store<RouteQuery> | RouteQuery;
    replace?: ((clock: T) => boolean) | Store<boolean> | boolean;
};
/** Opens passed `route` upon `clock` trigger */
declare function redirect<T, Params extends RouteParams>(options: RedirectParams<T, Params>): Event<T>;

type ChainRouteParamsInternalAttach<Params extends RouteParams, FX extends Effect<any, any, any>> = {
    route: RouteInstance<Params>;
    chainedRoute?: RouteInstance<Params>;
    beforeOpen: {
        effect: FX;
        mapParams: ({ params, query, }: {
            params: Params;
            query: RouteQuery;
        }) => NoInfer<EffectParams<FX>>;
    };
    openOn?: Clock<any>;
    cancelOn?: Clock<any>;
};
type ChainRouteParamsWithEffect<Params extends RouteParams> = {
    route: RouteInstance<Params>;
    chainedRoute?: RouteInstance<Params>;
    beforeOpen: Effect<RouteParamsAndQuery<Params>, any, any>;
};
type ChainRouteParamsAdvanced<Params extends RouteParams> = {
    route: RouteInstance<Params>;
    chainedRoute?: RouteInstance<Params>;
    beforeOpen: Clock<RouteParamsAndQuery<Params>>;
    openOn: Clock<any>;
    cancelOn?: Clock<any>;
};
declare function chainRoute<Params extends RouteParams>(instance: RouteInstance<Params>): RouteInstance<Params>;
declare function chainRoute<Params extends RouteParams>(config: ChainRouteParamsWithEffect<Params>): RouteInstance<Params>;
declare function chainRoute<Params extends RouteParams>(config: ChainRouteParamsAdvanced<Params>): RouteInstance<Params>;
declare function chainRoute<Params extends RouteParams, FX extends Effect<any, any, any>>(config: ChainRouteParamsInternalAttach<Params, FX>): RouteInstance<Params>;

type QueryCleanupStrategy = {
    irrelevant: boolean;
    empty: boolean;
    preserve: string[];
};
type QuerySyncParams<T extends Record<string, Store<any>>> = {
    source: T;
    clock?: Clock<any>;
    controls: ReturnType<typeof createRouterControls>;
    route?: RouteInstance<any>;
    cleanup?: boolean | Partial<QueryCleanupStrategy>;
};
declare function querySync<T extends Record<string, Store<any>>>(params: QuerySyncParams<T>): void;

type BuildPathParams<Params extends RouteParams> = {
    pathCreator: PathCreator<Params>;
    params: Params;
    query: RouteQuery;
    serialize?: ParamsSerializer;
};
declare function buildPath<Params extends RouteParams>({ pathCreator, params, query, serialize, }: BuildPathParams<Params>): string;
type MatchPathParams<Params extends RouteParams> = {
    pathCreator: PathCreator<Params>;
    actualPath: string;
};
declare function matchPath<Params extends RouteParams>({ pathCreator, actualPath, }: MatchPathParams<Params>): {
    readonly matches: true;
    readonly params: object;
} | {
    readonly matches: false;
    readonly params?: undefined;
};

export { type EmptyObject, type HistoryBackForwardParams, type HistoryPushParams, Kind, type NavigateParams, type ParamsSerializer, type PathCreator, type RouteInstance, type RouteObject, type RouteParams, type RouteParamsAndQuery, type RouteQuery, type UnmappedRouteObject, buildPath, chainRoute, createHistoryRouter, createRoute, createRouterControls, isRoute, matchPath, querySync, redirect };
