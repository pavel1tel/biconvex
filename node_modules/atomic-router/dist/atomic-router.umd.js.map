{"version":3,"file":"atomic-router.umd.js","sources":["../src/methods/create-route.ts","../src/lib/equals.ts","../src/methods/create-router-controls.ts","../node_modules/.pnpm/path-to-regexp@6.2.1/node_modules/path-to-regexp/dist.es2015/index.js","../src/lib/build-path.ts","../src/methods/is-route.ts","../src/lib/history-effects.ts","../src/lib/logic.ts","../src/methods/redirect.ts","../src/types.ts","../src/methods/create-history-router.ts","../src/methods/query-sync.ts","../src/methods/chain-route.ts","../src/lib/remap-route-objects.ts"],"sourcesContent":["import { attach, createEffect, createEvent, createStore, split, Store } from \"effector\";\nimport {\n  RouteParams,\n  RouteParamsAndQuery,\n  RouteQuery,\n  RouteInstance,\n  NavigateParams,\n  Kind,\n  EmptyObject,\n} from \"../types\";\n\ntype CreateRouteParams = {\n  filter?: Store<boolean>;\n};\n\nexport function createRoute<Params extends RouteParams = {}>(\n  params: CreateRouteParams = {},\n): RouteInstance<Params> {\n  const navigateFx = createEffect<NavigateParams<Params>, NavigateParams<Params>>(\n    ({ params, query, replace = false }) => ({\n      params: params || {},\n      query: query || {},\n      replace,\n    }),\n  );\n\n  const openFx = attach({\n    effect: navigateFx,\n    mapParams: (params: Params extends EmptyObject ? void : Params) => ({\n      params: (params || {}) as Params,\n      query: {} as RouteQuery,\n    }),\n  });\n\n  const $isOpened = createStore<boolean>(false);\n  const $params = createStore<Params>({} as Params);\n  const $query = createStore<RouteQuery>({});\n\n  const opened = createEvent<RouteParamsAndQuery<Params>>();\n  const updated = createEvent<RouteParamsAndQuery<Params>>();\n  const closed = createEvent<void>();\n\n  $isOpened.on(opened, () => true).on(closed, () => false);\n\n  $params.on(opened, (_, { params }) => params).on(updated, (_, { params }) => params);\n\n  $query.on(opened, (_, { query }) => query).on(updated, (_, { query }) => query);\n\n  split({\n    source: navigateFx.doneData,\n    match: $isOpened.map((isOpened) => (isOpened ? \"updated\" : \"opened\")),\n    cases: {\n      opened,\n      updated,\n    },\n  });\n\n  // if (params.filter) {\n  //   const filter = params.filter;\n  //   split({\n  //     // @ts-expect-error\n  //     source: sample({ clock: filter }),\n  //     // @ts-expect-error\n  //     match: (filter) => (filter ? 'true' : 'false'),\n  //     cases: {\n  //       true: opened,\n  //       false: closed,\n  //     },\n  //   });\n  // }\n\n  const instance: RouteInstance<Params> = {\n    $isOpened,\n    $params,\n    $query,\n    opened,\n    updated,\n    closed,\n    navigate: navigateFx,\n    open: openFx,\n    kind: Kind.ROUTE,\n    // @ts-expect-error Internal stuff\n    settings: {\n      derived: Boolean(params.filter),\n    },\n  };\n\n  return instance;\n}\n","export function paramsEqual(a: Record<string, any>, b: Record<string, any>) {\n  if (Object.keys(a).length !== Object.keys(b).length) {\n    return false;\n  }\n  for (const k in a) {\n    // NOTE: Parsed URI always returns string parameters\n    // so we force string comparison here\n    // in order to avoid extra updates\n    // whenever user passes numeric params\n    if (`${a[k]}` !== `${b[k]}`) {\n      return false;\n    }\n  }\n  return true;\n}\n","import { createEvent, createStore, type EventCallable, type StoreWritable } from \"effector\";\n\nimport type { RouteQuery } from \"../types\";\nimport { paramsEqual } from \"../lib/equals\";\n\ninterface RouterControls {\n  $query: StoreWritable<RouteQuery>;\n  back: EventCallable<void>;\n  forward: EventCallable<void>;\n}\n\nexport function createRouterControls(): RouterControls {\n  return {\n    $query: createStore({}, { updateFilter: (update, current) => !paramsEqual(current, update) }),\n    back: createEvent(),\n    forward: createEvent(),\n  };\n}\n","/**\n * Tokenize input string.\n */\nfunction lexer(str) {\n    var tokens = [];\n    var i = 0;\n    while (i < str.length) {\n        var char = str[i];\n        if (char === \"*\" || char === \"+\" || char === \"?\") {\n            tokens.push({ type: \"MODIFIER\", index: i, value: str[i++] });\n            continue;\n        }\n        if (char === \"\\\\\") {\n            tokens.push({ type: \"ESCAPED_CHAR\", index: i++, value: str[i++] });\n            continue;\n        }\n        if (char === \"{\") {\n            tokens.push({ type: \"OPEN\", index: i, value: str[i++] });\n            continue;\n        }\n        if (char === \"}\") {\n            tokens.push({ type: \"CLOSE\", index: i, value: str[i++] });\n            continue;\n        }\n        if (char === \":\") {\n            var name = \"\";\n            var j = i + 1;\n            while (j < str.length) {\n                var code = str.charCodeAt(j);\n                if (\n                // `0-9`\n                (code >= 48 && code <= 57) ||\n                    // `A-Z`\n                    (code >= 65 && code <= 90) ||\n                    // `a-z`\n                    (code >= 97 && code <= 122) ||\n                    // `_`\n                    code === 95) {\n                    name += str[j++];\n                    continue;\n                }\n                break;\n            }\n            if (!name)\n                throw new TypeError(\"Missing parameter name at \".concat(i));\n            tokens.push({ type: \"NAME\", index: i, value: name });\n            i = j;\n            continue;\n        }\n        if (char === \"(\") {\n            var count = 1;\n            var pattern = \"\";\n            var j = i + 1;\n            if (str[j] === \"?\") {\n                throw new TypeError(\"Pattern cannot start with \\\"?\\\" at \".concat(j));\n            }\n            while (j < str.length) {\n                if (str[j] === \"\\\\\") {\n                    pattern += str[j++] + str[j++];\n                    continue;\n                }\n                if (str[j] === \")\") {\n                    count--;\n                    if (count === 0) {\n                        j++;\n                        break;\n                    }\n                }\n                else if (str[j] === \"(\") {\n                    count++;\n                    if (str[j + 1] !== \"?\") {\n                        throw new TypeError(\"Capturing groups are not allowed at \".concat(j));\n                    }\n                }\n                pattern += str[j++];\n            }\n            if (count)\n                throw new TypeError(\"Unbalanced pattern at \".concat(i));\n            if (!pattern)\n                throw new TypeError(\"Missing pattern at \".concat(i));\n            tokens.push({ type: \"PATTERN\", index: i, value: pattern });\n            i = j;\n            continue;\n        }\n        tokens.push({ type: \"CHAR\", index: i, value: str[i++] });\n    }\n    tokens.push({ type: \"END\", index: i, value: \"\" });\n    return tokens;\n}\n/**\n * Parse a string for the raw tokens.\n */\nexport function parse(str, options) {\n    if (options === void 0) { options = {}; }\n    var tokens = lexer(str);\n    var _a = options.prefixes, prefixes = _a === void 0 ? \"./\" : _a;\n    var defaultPattern = \"[^\".concat(escapeString(options.delimiter || \"/#?\"), \"]+?\");\n    var result = [];\n    var key = 0;\n    var i = 0;\n    var path = \"\";\n    var tryConsume = function (type) {\n        if (i < tokens.length && tokens[i].type === type)\n            return tokens[i++].value;\n    };\n    var mustConsume = function (type) {\n        var value = tryConsume(type);\n        if (value !== undefined)\n            return value;\n        var _a = tokens[i], nextType = _a.type, index = _a.index;\n        throw new TypeError(\"Unexpected \".concat(nextType, \" at \").concat(index, \", expected \").concat(type));\n    };\n    var consumeText = function () {\n        var result = \"\";\n        var value;\n        while ((value = tryConsume(\"CHAR\") || tryConsume(\"ESCAPED_CHAR\"))) {\n            result += value;\n        }\n        return result;\n    };\n    while (i < tokens.length) {\n        var char = tryConsume(\"CHAR\");\n        var name = tryConsume(\"NAME\");\n        var pattern = tryConsume(\"PATTERN\");\n        if (name || pattern) {\n            var prefix = char || \"\";\n            if (prefixes.indexOf(prefix) === -1) {\n                path += prefix;\n                prefix = \"\";\n            }\n            if (path) {\n                result.push(path);\n                path = \"\";\n            }\n            result.push({\n                name: name || key++,\n                prefix: prefix,\n                suffix: \"\",\n                pattern: pattern || defaultPattern,\n                modifier: tryConsume(\"MODIFIER\") || \"\",\n            });\n            continue;\n        }\n        var value = char || tryConsume(\"ESCAPED_CHAR\");\n        if (value) {\n            path += value;\n            continue;\n        }\n        if (path) {\n            result.push(path);\n            path = \"\";\n        }\n        var open = tryConsume(\"OPEN\");\n        if (open) {\n            var prefix = consumeText();\n            var name_1 = tryConsume(\"NAME\") || \"\";\n            var pattern_1 = tryConsume(\"PATTERN\") || \"\";\n            var suffix = consumeText();\n            mustConsume(\"CLOSE\");\n            result.push({\n                name: name_1 || (pattern_1 ? key++ : \"\"),\n                pattern: name_1 && !pattern_1 ? defaultPattern : pattern_1,\n                prefix: prefix,\n                suffix: suffix,\n                modifier: tryConsume(\"MODIFIER\") || \"\",\n            });\n            continue;\n        }\n        mustConsume(\"END\");\n    }\n    return result;\n}\n/**\n * Compile a string to a template function for the path.\n */\nexport function compile(str, options) {\n    return tokensToFunction(parse(str, options), options);\n}\n/**\n * Expose a method for transforming tokens into the path function.\n */\nexport function tokensToFunction(tokens, options) {\n    if (options === void 0) { options = {}; }\n    var reFlags = flags(options);\n    var _a = options.encode, encode = _a === void 0 ? function (x) { return x; } : _a, _b = options.validate, validate = _b === void 0 ? true : _b;\n    // Compile all the tokens into regexps.\n    var matches = tokens.map(function (token) {\n        if (typeof token === \"object\") {\n            return new RegExp(\"^(?:\".concat(token.pattern, \")$\"), reFlags);\n        }\n    });\n    return function (data) {\n        var path = \"\";\n        for (var i = 0; i < tokens.length; i++) {\n            var token = tokens[i];\n            if (typeof token === \"string\") {\n                path += token;\n                continue;\n            }\n            var value = data ? data[token.name] : undefined;\n            var optional = token.modifier === \"?\" || token.modifier === \"*\";\n            var repeat = token.modifier === \"*\" || token.modifier === \"+\";\n            if (Array.isArray(value)) {\n                if (!repeat) {\n                    throw new TypeError(\"Expected \\\"\".concat(token.name, \"\\\" to not repeat, but got an array\"));\n                }\n                if (value.length === 0) {\n                    if (optional)\n                        continue;\n                    throw new TypeError(\"Expected \\\"\".concat(token.name, \"\\\" to not be empty\"));\n                }\n                for (var j = 0; j < value.length; j++) {\n                    var segment = encode(value[j], token);\n                    if (validate && !matches[i].test(segment)) {\n                        throw new TypeError(\"Expected all \\\"\".concat(token.name, \"\\\" to match \\\"\").concat(token.pattern, \"\\\", but got \\\"\").concat(segment, \"\\\"\"));\n                    }\n                    path += token.prefix + segment + token.suffix;\n                }\n                continue;\n            }\n            if (typeof value === \"string\" || typeof value === \"number\") {\n                var segment = encode(String(value), token);\n                if (validate && !matches[i].test(segment)) {\n                    throw new TypeError(\"Expected \\\"\".concat(token.name, \"\\\" to match \\\"\").concat(token.pattern, \"\\\", but got \\\"\").concat(segment, \"\\\"\"));\n                }\n                path += token.prefix + segment + token.suffix;\n                continue;\n            }\n            if (optional)\n                continue;\n            var typeOfMessage = repeat ? \"an array\" : \"a string\";\n            throw new TypeError(\"Expected \\\"\".concat(token.name, \"\\\" to be \").concat(typeOfMessage));\n        }\n        return path;\n    };\n}\n/**\n * Create path match function from `path-to-regexp` spec.\n */\nexport function match(str, options) {\n    var keys = [];\n    var re = pathToRegexp(str, keys, options);\n    return regexpToFunction(re, keys, options);\n}\n/**\n * Create a path match function from `path-to-regexp` output.\n */\nexport function regexpToFunction(re, keys, options) {\n    if (options === void 0) { options = {}; }\n    var _a = options.decode, decode = _a === void 0 ? function (x) { return x; } : _a;\n    return function (pathname) {\n        var m = re.exec(pathname);\n        if (!m)\n            return false;\n        var path = m[0], index = m.index;\n        var params = Object.create(null);\n        var _loop_1 = function (i) {\n            if (m[i] === undefined)\n                return \"continue\";\n            var key = keys[i - 1];\n            if (key.modifier === \"*\" || key.modifier === \"+\") {\n                params[key.name] = m[i].split(key.prefix + key.suffix).map(function (value) {\n                    return decode(value, key);\n                });\n            }\n            else {\n                params[key.name] = decode(m[i], key);\n            }\n        };\n        for (var i = 1; i < m.length; i++) {\n            _loop_1(i);\n        }\n        return { path: path, index: index, params: params };\n    };\n}\n/**\n * Escape a regular expression string.\n */\nfunction escapeString(str) {\n    return str.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, \"\\\\$1\");\n}\n/**\n * Get the flags for a regexp from the options.\n */\nfunction flags(options) {\n    return options && options.sensitive ? \"\" : \"i\";\n}\n/**\n * Pull out keys from a regexp.\n */\nfunction regexpToRegexp(path, keys) {\n    if (!keys)\n        return path;\n    var groupsRegex = /\\((?:\\?<(.*?)>)?(?!\\?)/g;\n    var index = 0;\n    var execResult = groupsRegex.exec(path.source);\n    while (execResult) {\n        keys.push({\n            // Use parenthesized substring match if available, index otherwise\n            name: execResult[1] || index++,\n            prefix: \"\",\n            suffix: \"\",\n            modifier: \"\",\n            pattern: \"\",\n        });\n        execResult = groupsRegex.exec(path.source);\n    }\n    return path;\n}\n/**\n * Transform an array into a regexp.\n */\nfunction arrayToRegexp(paths, keys, options) {\n    var parts = paths.map(function (path) { return pathToRegexp(path, keys, options).source; });\n    return new RegExp(\"(?:\".concat(parts.join(\"|\"), \")\"), flags(options));\n}\n/**\n * Create a path regexp from string input.\n */\nfunction stringToRegexp(path, keys, options) {\n    return tokensToRegexp(parse(path, options), keys, options);\n}\n/**\n * Expose a function for taking tokens and returning a RegExp.\n */\nexport function tokensToRegexp(tokens, keys, options) {\n    if (options === void 0) { options = {}; }\n    var _a = options.strict, strict = _a === void 0 ? false : _a, _b = options.start, start = _b === void 0 ? true : _b, _c = options.end, end = _c === void 0 ? true : _c, _d = options.encode, encode = _d === void 0 ? function (x) { return x; } : _d, _e = options.delimiter, delimiter = _e === void 0 ? \"/#?\" : _e, _f = options.endsWith, endsWith = _f === void 0 ? \"\" : _f;\n    var endsWithRe = \"[\".concat(escapeString(endsWith), \"]|$\");\n    var delimiterRe = \"[\".concat(escapeString(delimiter), \"]\");\n    var route = start ? \"^\" : \"\";\n    // Iterate over the tokens and create our regexp string.\n    for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {\n        var token = tokens_1[_i];\n        if (typeof token === \"string\") {\n            route += escapeString(encode(token));\n        }\n        else {\n            var prefix = escapeString(encode(token.prefix));\n            var suffix = escapeString(encode(token.suffix));\n            if (token.pattern) {\n                if (keys)\n                    keys.push(token);\n                if (prefix || suffix) {\n                    if (token.modifier === \"+\" || token.modifier === \"*\") {\n                        var mod = token.modifier === \"*\" ? \"?\" : \"\";\n                        route += \"(?:\".concat(prefix, \"((?:\").concat(token.pattern, \")(?:\").concat(suffix).concat(prefix, \"(?:\").concat(token.pattern, \"))*)\").concat(suffix, \")\").concat(mod);\n                    }\n                    else {\n                        route += \"(?:\".concat(prefix, \"(\").concat(token.pattern, \")\").concat(suffix, \")\").concat(token.modifier);\n                    }\n                }\n                else {\n                    if (token.modifier === \"+\" || token.modifier === \"*\") {\n                        route += \"((?:\".concat(token.pattern, \")\").concat(token.modifier, \")\");\n                    }\n                    else {\n                        route += \"(\".concat(token.pattern, \")\").concat(token.modifier);\n                    }\n                }\n            }\n            else {\n                route += \"(?:\".concat(prefix).concat(suffix, \")\").concat(token.modifier);\n            }\n        }\n    }\n    if (end) {\n        if (!strict)\n            route += \"\".concat(delimiterRe, \"?\");\n        route += !options.endsWith ? \"$\" : \"(?=\".concat(endsWithRe, \")\");\n    }\n    else {\n        var endToken = tokens[tokens.length - 1];\n        var isEndDelimited = typeof endToken === \"string\"\n            ? delimiterRe.indexOf(endToken[endToken.length - 1]) > -1\n            : endToken === undefined;\n        if (!strict) {\n            route += \"(?:\".concat(delimiterRe, \"(?=\").concat(endsWithRe, \"))?\");\n        }\n        if (!isEndDelimited) {\n            route += \"(?=\".concat(delimiterRe, \"|\").concat(endsWithRe, \")\");\n        }\n    }\n    return new RegExp(route, flags(options));\n}\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n */\nexport function pathToRegexp(path, keys, options) {\n    if (path instanceof RegExp)\n        return regexpToRegexp(path, keys);\n    if (Array.isArray(path))\n        return arrayToRegexp(path, keys, options);\n    return stringToRegexp(path, keys, options);\n}\n//# sourceMappingURL=index.js.map","import { match, compile } from \"path-to-regexp\";\n\nimport type { RouteParams, PathCreator, RouteQuery, ParamsSerializer } from \"../types\";\n\n// NOTE: If path is URL - provide it as is\n// Otherwise - extract pathname and hash\nconst getComparablePath = (path: string) => {\n  if (path.match(/^[a-z0-9]+\\:\\/\\//i)) {\n    return path;\n  }\n  const url = new URL(`http://_${path}`);\n  return [url.pathname, url.hash].join(\"\");\n};\n\n// NOTE: path-to-regexp treats \":\" in \"https://\" as param start\n// So we escape it\nfunction normalizePathCreator(pathCreator: string) {\n  return pathCreator.replace(\"://\", \"\\\\://\");\n}\n\ntype BuildPathParams<Params extends RouteParams> = {\n  pathCreator: PathCreator<Params>;\n  params: Params;\n  query: RouteQuery;\n  serialize?: ParamsSerializer;\n};\nexport function buildPath<Params extends RouteParams>({\n  pathCreator,\n  params,\n  query,\n  serialize,\n}: BuildPathParams<Params>) {\n  const pathname = compile(pathCreator)(params);\n  const serializedParams = serialize?.write(query) ?? new URLSearchParams(query);\n  const qs = Object.keys(query).length ? `?${serializedParams}` : \"\";\n  const url = `${pathname}${qs}`;\n  return url;\n}\n\ntype MatchPathParams<Params extends RouteParams> = {\n  pathCreator: PathCreator<Params>;\n  actualPath: string;\n};\nexport function matchPath<Params extends RouteParams>({\n  pathCreator,\n  actualPath,\n}: MatchPathParams<Params>) {\n  const matches = match(normalizePathCreator(pathCreator))(getComparablePath(actualPath));\n  if (matches) {\n    return { matches: true, params: matches.params } as const;\n  }\n  return { matches: false } as const;\n}\n","import { Kind, RouteInstance, RouteInstanceInternal } from \"../types\";\n\n/** Detects whether passed value is a `RouteInstance<any>` or not */\nexport function isRoute(route: RouteInstance<any> | unknown): route is RouteInstance<any> {\n  return (\n    typeof route === \"object\" && route !== null && \"kind\" in route && route.kind === Kind.ROUTE\n  );\n}\n\nexport function isRouteInternal(\n  route: RouteInstanceInternal<any> | unknown,\n): route is RouteInstanceInternal<any> {\n  return isRoute(route);\n}\n","import { History } from \"history\";\nimport { createEffect } from \"effector\";\n\nimport { HistoryBackForwardParams, HistoryPushParams } from \"../types\";\n\nfunction assertHistory(history: History) {\n  if (!history) {\n    throw new Error(\"[Atomic-Router] No history provided\");\n  }\n}\n\nexport const historyPushFx = createEffect((params: HistoryPushParams) => {\n  assertHistory(params.history);\n  params.history[params.method](params.path, {});\n  return params;\n});\n\nexport const historyBackFx = createEffect((history: HistoryBackForwardParams) => {\n  assertHistory(history);\n  history.back();\n  return history;\n});\n\nexport const historyForwardFx = createEffect((history: HistoryBackForwardParams) => {\n  assertHistory(history);\n  history.forward();\n  return history;\n});\n","import { Store } from \"effector\";\n\nexport function not<T>(source: Store<T>): Store<boolean> {\n  return source.map((value) => !value);\n}\n","import { Clock, createEvent, createStore, Event, is, sample, Store } from \"effector\";\nimport { EmptyObject, RouteInstance, RouteParams, RouteQuery } from \"../types\";\n\ntype RedirectParams<T, Params extends RouteParams> = Params extends EmptyObject\n  ? {\n      clock?: Clock<T>;\n      route: RouteInstance<Params>;\n      query?: ((clock: T) => RouteQuery) | Store<RouteQuery> | RouteQuery;\n      replace?: ((clock: T) => boolean) | Store<boolean> | boolean;\n    }\n  :\n      | {\n          clock?: Clock<T>;\n          route: RouteInstance<Params>;\n          params: ((clock: T) => Params) | Store<Params> | Params;\n          query?: ((clock: T) => RouteQuery) | Store<RouteQuery> | RouteQuery;\n          replace?: ((clock: T) => boolean) | Store<boolean> | boolean;\n        }\n      | {\n          clock?: Clock<{\n            params: Params;\n            query?: RouteQuery;\n            replace?: boolean;\n          }>;\n          route: RouteInstance<Params>;\n          params?: ((clock: T) => Params) | Store<Params> | Params;\n          query?: ((clock: T) => RouteQuery) | Store<RouteQuery> | RouteQuery;\n          replace?: ((clock: T) => boolean) | Store<boolean> | boolean;\n        };\n\n/** Opens passed `route` upon `clock` trigger */\nexport function redirect<T, Params extends RouteParams>(options: RedirectParams<T, Params>) {\n  const clock: Event<T> = options.clock\n    ? sample({ clock: options.clock as Event<T> })\n    : createEvent<T>();\n\n  const params = toStore(options.params || {});\n  const query = toStore(options.query || {});\n  const replace = toStore(options.replace || false);\n\n  sample({\n    clock: clock,\n    source: { params, query, replace },\n    fn: ({ params, query, replace }, clock) => ({\n      params: typeof params === \"function\" ? params(clock) : params,\n      query: typeof query === \"function\" ? query(clock) : query,\n      replace: typeof replace === \"function\" ? replace(clock) : replace,\n    }),\n    target: options.route.navigate,\n  });\n\n  return clock;\n}\n\nfunction toStore<T>(payload: T | Store<T>): Store<T> {\n  return is.store(payload) ? payload : createStore(payload as T);\n}\n","import { History } from \"history\";\nimport { Effect, Store, Event, EventCallable } from \"effector\";\n\nexport type RouteParams = Record<string, any>;\n\nexport type RouteQuery = Record<string, any>;\n\nexport type RouteParamsAndQuery<Params extends RouteParams> = {\n  params: Params;\n  query: RouteQuery;\n};\n\nexport interface NavigateParams<Params extends RouteParams> extends RouteParamsAndQuery<Params> {\n  replace?: boolean;\n}\n\nexport type RouteInstance<Params extends RouteParams> = {\n  $isOpened: Store<boolean>;\n  $params: Store<Params>;\n  $query: Store<RouteQuery>;\n  opened: Event<RouteParamsAndQuery<Params>>;\n  updated: Event<RouteParamsAndQuery<Params>>;\n  closed: Event<void>;\n  navigate: Effect<NavigateParams<Params>, NavigateParams<Params>>;\n  open: Effect<Params extends EmptyObject ? void : Params, RouteParamsAndQuery<Params>>;\n  kind: typeof Kind.ROUTE;\n};\n\nexport interface RouteInstanceInternal<Params extends RouteParams> extends RouteInstance<Params> {\n  opened: EventCallable<RouteParamsAndQuery<Params>>;\n  updated: EventCallable<RouteParamsAndQuery<Params>>;\n  closed: EventCallable<void>;\n}\n\nexport type RouteObject<Params extends RouteParams> = {\n  route: RouteInstance<Params>;\n  path: string;\n};\n\nexport interface RouteObjectInternal<Params extends RouteParams> extends RouteObject<Params> {\n  route: RouteInstanceInternal<Params>;\n}\n\nexport type UnmappedRouteObject<Params extends RouteParams> = {\n  route: RouteInstance<Params> | RouteInstance<Params>[];\n  path: string;\n};\n\nexport type HistoryPushParams = {\n  history: History;\n  path: string;\n  params: RouteParams;\n  query: RouteQuery;\n  method: \"replace\" | \"push\";\n};\n\nexport type HistoryBackForwardParams = History;\n\nexport type ParamsSerializer = {\n  write: (params: RouteParams) => string;\n  read: (query: string) => RouteParams;\n};\n\n// @ts-expect-error 'Params' is declared but its value is never read. ts(6133)\nexport type PathCreator<Params extends RouteParams> = string;\n\nexport const Kind = {\n  ROUTE: Symbol(),\n};\n\nexport type EmptyObject = { [key in string]: never };\n","import { History } from \"history\";\nimport { attach, combine, createEvent, createStore, sample, scopeBind } from \"effector\";\nimport { createRouterControls } from \"./create-router-controls\";\nimport {\n  HistoryPushParams,\n  ParamsSerializer,\n  RouteInstance,\n  RouteObject,\n  RouteParams,\n  RouteQuery,\n  UnmappedRouteObject,\n} from \"../types\";\nimport { remapRouteObjects } from \"../lib/remap-route-objects\";\nimport { paramsEqual } from \"../lib/equals\";\nimport { buildPath, matchPath } from \"../lib/build-path\";\nimport { isRouteInternal } from \"./is-route\";\nimport { historyBackFx, historyForwardFx, historyPushFx } from \"../lib/history-effects\";\nimport { not } from \"../lib/logic\";\n\nexport function createHistoryRouter({\n  base,\n  routes,\n  notFoundRoute,\n  hydrate,\n  serialize,\n  controls = createRouterControls(),\n}: {\n  base?: string;\n  routes: UnmappedRouteObject<any>[];\n  notFoundRoute?: RouteInstance<any>;\n  serialize?: ParamsSerializer;\n  hydrate?: boolean;\n  controls?: ReturnType<typeof createRouterControls>;\n}) {\n  const $hydrateMode = createStore(hydrate ?? false, {\n    /**\n     * It is explicitly set in the config and not as a Store,\n     * so value from config should be used at all times - we don't want to serialize this value\n     */\n    serialize: \"ignore\",\n  });\n  const remappedRoutes = remapRouteObjects(routes, base);\n\n  const setHistory = createEvent<History>();\n  const navigateFromRouteTriggered = createEvent<{\n    route: RouteObject<any>;\n    params: RouteParams;\n    query: RouteQuery;\n    replace: boolean;\n  }>();\n  const historyUpdated = createEvent();\n  const recalculateTriggered = createEvent<{\n    path: string;\n    query: RouteQuery;\n    hash: string;\n  }>();\n  const recalculated = createEvent<{\n    path: string;\n    query: RouteQuery;\n    matching: RecalculationResult<any>[];\n    mismatching: RecalculationResult<any>[];\n  }>();\n  const routesMatched = createEvent<RecalculationResult<any>[]>();\n  const routesMismatched = createEvent<RecalculationResult<any>[]>();\n  const routeNotFound = createEvent();\n  const initialized = createEvent<{\n    activeRoutes: RouteInstance<any>[];\n    path: string;\n    query: RouteQuery;\n  }>();\n\n  const $path = createStore(\"\");\n  const $query = createStore<RouteQuery>(\n    {},\n    {\n      name: \"historyRouter.$query\",\n      updateFilter: (newQuery, oldQuery) => !paramsEqual(newQuery, oldQuery),\n    },\n  );\n  const $activeRoutes = createStore<RouteInstance<any>[]>([], {\n    serialize: \"ignore\",\n  });\n  // @ts-expect-error\n  const $history = createStore<History>(null, {\n    serialize: \"ignore\",\n  });\n  const $isFirstCheckPassed = createStore(false);\n  const $isRouteNavigateInProgress = createStore(false);\n\n  const pushFx = attach({\n    source: $history,\n    effect(history, params: Omit<HistoryPushParams, \"history\">) {\n      return historyPushFx({\n        history,\n        ...params,\n      });\n    },\n  });\n\n  const subscribeHistoryFx = attach({\n    source: $history,\n    effect(history) {\n      let scopedHistoryUpdated = historyUpdated;\n      try {\n        // @ts-expect-error\n        scopedHistoryUpdated = scopeBind(historyUpdated);\n      } catch (err) {}\n      history.listen(() => {\n        scopedHistoryUpdated();\n      });\n      return true;\n    },\n  });\n\n  const historyUpdatedParsed = sample({\n    clock: hydrate ? [historyUpdated] : [historyUpdated, subscribeHistoryFx.done],\n    source: $history,\n    filter: Boolean,\n    fn: (history) => ({\n      path: history.location.pathname,\n      query:\n        serialize?.read(history.location.search) ??\n        Object.fromEntries(new URLSearchParams(history.location.search)),\n    }),\n  });\n\n  // If `hydrate` flag is set,\n  // don't trigger recheck on history init\n  const historyUpdateTriggered = sample({\n    clock: historyUpdatedParsed,\n    source: {\n      path: $path,\n      query: $query,\n    },\n    filter: ({ path: savedPath, query: savedQuery }, history) =>\n      history.path !== savedPath || !paramsEqual(history.query, savedQuery),\n    fn: (_, history) => history,\n  });\n\n  /// History subscription\n  $history.on(setHistory, (_, history) => history);\n\n  sample({\n    clock: $history,\n    target: subscribeHistoryFx,\n  });\n\n  sample({\n    clock: historyUpdateTriggered,\n    source: $history,\n    filter: Boolean,\n    fn(history) {\n      const path = history?.location.pathname;\n      const hash = history?.location.hash;\n      const query: RouteQuery =\n        serialize?.read(history?.location.search) ??\n        Object.fromEntries(new URLSearchParams(history?.location.search));\n      return { path, query, hash };\n    },\n    target: recalculateTriggered,\n  });\n\n  /// Routes updates handling\n  for (const routeObj of remappedRoutes) {\n    const currentRouteMatched = routesMatched.filterMap(containsCurrentRoute(routeObj));\n    const currentRouteMismatched = routesMismatched.filterMap(containsCurrentRoute(routeObj));\n    const routeStateChangeRequested = {\n      /**\n       * Special case:\n       * - Scope is initied from server data, route.$isOpened -> true\n       * - but `hydrate` flag is set to false\n       *\n       * So route.opened() should be called after router.setHistory anyway to respect that\n       */\n      initialized: sample({\n        clock: subscribeHistoryFx.done,\n        filter: combine(\n          routeObj.route.$isOpened,\n          $hydrateMode,\n          (isOpened, hydrateMode) => isOpened && !hydrateMode,\n        ),\n      }),\n      opened: sample({\n        clock: currentRouteMatched,\n        filter: not(routeObj.route.$isOpened),\n      }),\n      updated: sample({\n        clock: currentRouteMatched,\n        filter: routeObj.route.$isOpened,\n      }),\n      closed: sample({\n        clock: currentRouteMismatched,\n        filter: routeObj.route.$isOpened,\n      }),\n    };\n\n    /**\n     * Trigger .opened() for special case with scope being initialized from server data\n     */\n    sample({\n      clock: routeStateChangeRequested.initialized,\n      source: {\n        params: routeObj.route.$params,\n        query: routeObj.route.$query,\n      },\n      target: routeObj.route.opened,\n    });\n\n    // Trigger .updated() for the routes marked as \"matched\" but already opened\n    sample({\n      clock: routeStateChangeRequested.updated,\n      source: [routeObj.route.$params, routeObj.route.$query],\n      // Skip .updated() calls if params & query are the same\n      filter: ([params, query], next) =>\n        !paramsEqual(params, next.params) || !paramsEqual(query, next.query),\n      fn: (_, paramsAndQuery) => paramsAndQuery,\n      target: routeObj.route.updated,\n    });\n\n    // Trigger .opened() for the routes marked as \"matched\" but not opened yet\n    sample({\n      clock: routeStateChangeRequested.opened,\n      // TODO: Scratch this?\n      filter: not($isRouteNavigateInProgress),\n      target: routeObj.route.opened,\n    });\n\n    // Trigger .closed() for the routes marked as \"mismatched\" but opened\n    sample({\n      clock: routeStateChangeRequested.closed,\n      target: routeObj.route.closed,\n    });\n  }\n\n  /// Handling route.navigateFx navigation\n  for (const routeObj of remappedRoutes) {\n    // Run \"Handling route.navigateFx navigation\" step\n    sample({\n      clock: routeObj.route.navigate.doneData,\n      fn: ({ params, query, replace }) => ({\n        route: routeObj,\n        params,\n        query,\n        replace: replace ?? false,\n      }),\n      target: navigateFromRouteTriggered,\n    });\n  }\n\n  $isRouteNavigateInProgress.on(navigateFromRouteTriggered, () => true);\n\n  sample({\n    clock: navigateFromRouteTriggered,\n    fn({ route, params, query, replace }) {\n      const path = buildPath({\n        pathCreator: route.path,\n        params,\n        query,\n        serialize,\n      });\n      const method: \"replace\" | \"push\" = replace ? \"replace\" : \"push\";\n      return {\n        path,\n        params,\n        query,\n        method,\n      };\n    },\n    target: pushFx,\n  });\n\n  $isRouteNavigateInProgress.reset([routesMatched, routesMismatched]);\n\n  /// Recalculation\n  // Triggered on every history change + once when history instance is set\n  sample({\n    clock: recalculateTriggered,\n    fn({ path, query, hash }) {\n      const matchingRoutes = [] as RecalculationResult<any>[];\n      const mismatchingRoutes = [] as RecalculationResult<any>[];\n\n      for (const route of remappedRoutes) {\n        // NOTE: Use hash string as well if route.path contains #\n        const actualPath = route.path.includes(\"#\") ? `${path}${hash}` : `${path}`;\n        const { matches, params } = matchPath({\n          pathCreator: route.path,\n          actualPath,\n        });\n\n        const suitableRoutes = matches ? matchingRoutes : mismatchingRoutes;\n        suitableRoutes.push({\n          routeObj: route,\n          params,\n          query,\n        });\n      }\n\n      // Checking for routes we need to close\n      // Remove all that are marked to be opened\n      mismatchingRoutes.forEach((mismatchedRoute, mismatchedIndex) => {\n        const mismatchedRouteExistsInMatchedList = matchingRoutes.some(\n          (matchedRoute) => matchedRoute.routeObj.route === mismatchedRoute.routeObj.route,\n        );\n        if (mismatchedRouteExistsInMatchedList) {\n          mismatchingRoutes.splice(mismatchedIndex, 1);\n        }\n      });\n\n      return {\n        matching: matchingRoutes,\n        mismatching: mismatchingRoutes.filter(Boolean),\n        path,\n        query,\n      };\n    },\n    target: recalculated,\n  });\n\n  $path.on(historyUpdateTriggered, (_, { path }) => path);\n\n  $query.on(historyUpdateTriggered, (_, { query }) => query);\n\n  const matchingRecalculated = recalculated.map(({ matching }) => matching);\n\n  sample({\n    clock: matchingRecalculated,\n    filter: (routes) => routes.length > 0,\n    target: routesMatched,\n  });\n\n  sample({\n    clock: recalculated.map(({ mismatching }) => mismatching),\n    filter: (routes) => routes.length > 0,\n    target: routesMismatched,\n  });\n\n  $activeRoutes.on(recalculated, (_, { matching }) =>\n    matching.map((recheckResult) => recheckResult.routeObj.route),\n  );\n\n  /// Handling 404\n  sample({\n    clock: matchingRecalculated,\n    filter: (routes) => routes.length === 0,\n    target: routeNotFound,\n  });\n\n  if (isRouteInternal(notFoundRoute)) {\n    sample({\n      clock: routeNotFound,\n      source: $query,\n      filter: notFoundRoute.$isOpened,\n      fn: (query) => ({ query, params: {} }),\n      target: notFoundRoute.updated,\n    });\n\n    sample({\n      clock: routeNotFound,\n      source: { query: $query, isOpened: notFoundRoute.$isOpened },\n      filter: ({ isOpened }) => !isOpened,\n      fn: ({ query }) => ({ query, params: {} }),\n      target: notFoundRoute.opened,\n    });\n\n    sample({\n      clock: matchingRecalculated,\n      source: notFoundRoute.$isOpened,\n      filter: (isOpened, matching) => isOpened && matching.length > 0,\n      target: notFoundRoute.closed,\n    });\n  }\n\n  /// Back/forward navigation\n  sample({\n    clock: controls.back,\n    source: $history,\n    target: historyBackFx,\n  });\n\n  sample({\n    clock: controls.forward,\n    source: $history,\n    target: historyForwardFx,\n  });\n\n  /// Query syncing\n  sample({\n    clock: $query,\n    source: { controlsQuery: controls.$query, localQuery: $query },\n    filter: ({ controlsQuery, localQuery }) => !paramsEqual(controlsQuery, localQuery),\n    fn: ({ localQuery }) => localQuery,\n    target: controls.$query,\n  });\n\n  sample({\n    clock: controls.$query,\n    source: {\n      path: $path,\n      localQuery: $query,\n      isNavigateInProgress: $isRouteNavigateInProgress,\n      realHistory: $history,\n    },\n    filter: ({ localQuery, isNavigateInProgress, realHistory }, query) => {\n      const realQuery =\n        serialize?.read(realHistory?.location.search ?? \"\") ??\n        Object.fromEntries(new URLSearchParams(realHistory?.location.search ?? \"\"));\n      return (\n        isNavigateInProgress || !paramsEqual(query, realQuery) || !paramsEqual(localQuery, query)\n      );\n    },\n    fn({ path }, query) {\n      const qs = serialize?.write(query) ?? new URLSearchParams(query);\n      return {\n        path: `${path}${qs ? `?${qs}` : \"\"}`,\n        params: {},\n        query: query,\n        method: \"push\" as const,\n      };\n    },\n    target: pushFx,\n  });\n\n  /// Initialization\n  sample({\n    clock: recalculated,\n    source: {\n      activeRoutes: $activeRoutes,\n      path: $path,\n      query: $query,\n    },\n    filter: $isFirstCheckPassed.map((isFirstCheckPassed) => !isFirstCheckPassed),\n    target: initialized,\n  });\n\n  $isFirstCheckPassed.on(initialized, () => true).reset($history);\n\n  return {\n    $path,\n    $activeRoutes,\n    $history,\n    setHistory,\n    $query: $query,\n    back: controls.back,\n    forward: controls.forward,\n    push: pushFx,\n    routes: remappedRoutes,\n    initialized,\n    routeNotFound,\n  };\n}\n\ntype RecalculationResult<Params extends RouteParams> = {\n  routeObj: RouteObject<Params>;\n  params: Params;\n  query: RouteQuery;\n};\n\nconst containsCurrentRoute =\n  (routeObj: RouteObject<any>) => (recheckResults: RecalculationResult<any>[]) => {\n    const recheck = recheckResults.find(\n      (recheckResult) => recheckResult.routeObj.route === routeObj.route,\n    );\n    if (!recheck) {\n      return;\n    }\n    return {\n      params: recheck.params,\n      query: recheck.query,\n    };\n  };\n","import { Clock, combine, createStore, sample, Store, Unit } from \"effector\";\n\nimport { RouteInstance, RouteQuery } from \"../types\";\nimport { createRouterControls } from \"./create-router-controls\";\n\ntype QueryCleanupStrategy = {\n  irrelevant: boolean;\n  empty: boolean;\n  preserve: string[];\n};\n\ntype QuerySyncParams<T extends Record<string, Store<any>>> = {\n  source: T;\n  clock?: Clock<any>;\n  controls: ReturnType<typeof createRouterControls>;\n  route?: RouteInstance<any>;\n  cleanup?: boolean | Partial<QueryCleanupStrategy>;\n};\n\nexport function querySync<T extends Record<string, Store<any>>>(params: QuerySyncParams<T>) {\n  const $isOpened = params.route?.$isOpened ?? createStore(true);\n  const $source = combine(params.source);\n  const clock = (params.clock ?? $source) as Unit<any>;\n  const cleanupStrategy = !(\"cleanup\" in params)\n    ? cleanupStrategies.default\n    : typeof params.cleanup === \"boolean\"\n      ? cleanupStrategies[params.cleanup ? \"all\" : \"none\"]\n      : { ...cleanupStrategies.default, ...params.cleanup! };\n\n  const queryUpdatedFromHistory = sample({\n    clock: params.controls.$query,\n    filter: $isOpened,\n  });\n\n  sample({\n    clock,\n    source: combine([$source, params.controls.$query]),\n    filter: $isOpened,\n    fn: ([source, currentQuery]) => {\n      let nextQuery: RouteQuery = {};\n      if (cleanupStrategy.irrelevant) {\n        for (const key of cleanupStrategy.preserve) {\n          if (key in currentQuery) {\n            nextQuery[key] = currentQuery[key];\n          }\n        }\n      } else {\n        nextQuery = { ...currentQuery };\n      }\n      for (const key in source) {\n        nextQuery[key] = source[key];\n      }\n      if (cleanupStrategy.empty) {\n        for (const key in source) {\n          if (!cleanupStrategy.preserve.includes(key) && !nextQuery[key]) {\n            delete nextQuery[key];\n          }\n        }\n      }\n      return nextQuery as RouteQuery;\n    },\n    target: params.controls.$query,\n  });\n\n  for (const k in params.source) {\n    const $queryParam = params.source[k as keyof typeof params.source];\n    // @ts-expect-error\n    $queryParam.on(queryUpdatedFromHistory, (_, query) => {\n      return query[k] ?? $queryParam.defaultState;\n    });\n  }\n}\n\nconst cleanupStrategies = {\n  all: {\n    irrelevant: true,\n    empty: true,\n    preserve: [],\n  },\n  default: {\n    irrelevant: false,\n    empty: true,\n    preserve: [],\n  },\n  none: {\n    irrelevant: false,\n    empty: false,\n    preserve: [],\n  },\n};\n","import {\n  is,\n  merge,\n  sample,\n  combine,\n  createStore,\n  Unit,\n  Clock,\n  Effect,\n  StoreValue,\n  createEvent,\n  NoInfer,\n  EffectParams,\n  attach,\n  UnitTargetable,\n} from \"effector\";\n\nimport { createRoute } from \"./create-route\";\nimport {\n  RouteInstance,\n  RouteInstanceInternal,\n  RouteParams,\n  RouteParamsAndQuery,\n  RouteQuery,\n} from \"../types\";\n\nimport { isRouteInternal } from \"./is-route\";\n\ntype ChainRouteParamsInternalAttach<\n  Params extends RouteParams,\n  FX extends Effect<any, any, any>,\n> = {\n  route: RouteInstance<Params>;\n  chainedRoute?: RouteInstance<Params>;\n  beforeOpen: {\n    effect: FX;\n    mapParams: ({\n      params,\n      query,\n    }: {\n      params: Params;\n      query: RouteQuery;\n    }) => NoInfer<EffectParams<FX>>;\n  };\n  openOn?: Clock<any>;\n  cancelOn?: Clock<any>;\n};\n\ntype ChainRouteParamsWithEffect<Params extends RouteParams> = {\n  route: RouteInstance<Params>;\n  chainedRoute?: RouteInstance<Params>;\n  beforeOpen: Effect<RouteParamsAndQuery<Params>, any, any>;\n};\n\ntype ChainRouteParamsAdvanced<Params extends RouteParams> = {\n  route: RouteInstance<Params>;\n  chainedRoute?: RouteInstance<Params>;\n  beforeOpen: Clock<RouteParamsAndQuery<Params>>;\n  openOn: Clock<any>;\n  cancelOn?: Clock<any>;\n};\n\ntype ChainRouteParams<Params extends RouteParams, FX extends Effect<any, any, any>> =\n  | RouteInstance<Params>\n  | ChainRouteParamsWithEffect<Params>\n  | ChainRouteParamsAdvanced<Params>\n  | ChainRouteParamsInternalAttach<Params, FX>;\n\nfunction chainRoute<Params extends RouteParams>(\n  instance: RouteInstance<Params>,\n): RouteInstance<Params>;\n\nfunction chainRoute<Params extends RouteParams>(\n  config: ChainRouteParamsWithEffect<Params>,\n): RouteInstance<Params>;\n\nfunction chainRoute<Params extends RouteParams>(\n  config: ChainRouteParamsAdvanced<Params>,\n): RouteInstance<Params>;\n\nfunction chainRoute<Params extends RouteParams, FX extends Effect<any, any, any>>(\n  config: ChainRouteParamsInternalAttach<Params, FX>,\n): RouteInstance<Params>;\n\n/**\n * Creates chained route\n * @link https://github.com/Kelin2025/atomic-router/issues/10\n * @param {RouteInstance<any>} params.route - Route to listen\n * @param {RouteInstance<any>} [params.chainedRoute]  - Route to be created\n * @param {Clock<any>} params.beforeOpen - Will be triggered when `params.route` open\n * @param {Clock<any>} params.openOn - Will open `chainedRoute` if `params.route` is still opened\n * @param {Clock<any>} params.cancelOn - Cancels chain\n * @returns {RouteInstance<any>} `chainedRoute`\n */\nfunction chainRoute<Params extends RouteParams, FX extends Effect<any, any, any>>(\n  params: ChainRouteParams<Params, FX>,\n) {\n  const { route, chainedRoute, beforeOpen, openOn, cancelOn } = normalizeChainRouteParams(params);\n  const $params = createStore({} as StoreValue<(typeof route)[\"$params\"]>);\n  const $query = createStore({} as StoreValue<(typeof route)[\"$query\"]>);\n  const $hasSameParams = combine(\n    combine([route.$params, route.$query]),\n    combine([$params, $query]),\n    (current, stored) => {\n      return current[0] === stored[0] && current[1] === stored[1];\n    },\n  );\n  const routeTriggered = sample({ clock: [route.opened, route.updated] });\n\n  // 1. Call `beforeOpen` whenever route is opened\n  sample({\n    clock: routeTriggered,\n    target: beforeOpen as UnitTargetable<RouteParamsAndQuery<any>>,\n  });\n\n  $params.on(routeTriggered, (_prev, { params }) => params);\n  $query.on(routeTriggered, (_prev, { query }) => query);\n\n  // 2. Listen to `openOn` if route is still opened on the same position\n  sample({\n    clock: openOn as Unit<any>,\n    source: { params: $params, query: $query },\n    filter: $hasSameParams,\n    target: chainedRoute.navigate,\n  });\n\n  // 4. Cancel loading if page closed or `cancelOn` is called\n  // @ts-expect-error\n  const aborted = merge([route.closed, cancelOn]);\n\n  $params.reset(aborted);\n  $query.reset(aborted);\n\n  sample({\n    clock: aborted,\n    target: chainedRoute.closed,\n  });\n\n  return chainedRoute;\n}\n\n// This is written separately to correctly export all type overloads\nexport { chainRoute };\n\ntype ChainRouteParamsNormalized<Params extends RouteParams> = {\n  route: RouteInstanceInternal<Params>;\n  chainedRoute: RouteInstanceInternal<Params>;\n  beforeOpen: Clock<RouteParamsAndQuery<Params>>;\n  openOn: Clock<any>;\n  cancelOn: Clock<any>;\n};\n\nfunction normalizeChainRouteParams<Params extends RouteParams, FX extends Effect<any, any, any>>(\n  params: ChainRouteParams<Params, FX>,\n): ChainRouteParamsNormalized<Params> {\n  const resultParams: ChainRouteParamsNormalized<Params> = {} as ChainRouteParamsNormalized<Params>;\n\n  if (isRouteInternal(params)) {\n    Object.assign(resultParams, {\n      route: params,\n      chainedRoute: createRoute<Params>(),\n      beforeOpen: createEvent(),\n      openOn: merge([params.opened, params.closed]),\n      cancelOn: merge([]),\n    });\n    return resultParams;\n  }\n  const effectParams = params as ChainRouteParamsWithEffect<Params>;\n  Object.assign(resultParams, {\n    route: effectParams.route,\n    chainedRoute: effectParams.chainedRoute || createRoute<Params>(),\n    beforeOpen: is.unit(effectParams.beforeOpen)\n      ? effectParams.beforeOpen\n      : attach(effectParams.beforeOpen),\n  });\n  if (is.effect(resultParams.beforeOpen as Unit<any>)) {\n    Object.assign(resultParams, {\n      openOn:\n        // @ts-expect-error\n        effectParams.openOn || resultParams.beforeOpen.doneData,\n      cancelOn:\n        // @ts-expect-error\n        effectParams.cancelOn || resultParams.beforeOpen.failData,\n    });\n    return resultParams;\n  }\n  const advancedParams = params as ChainRouteParamsAdvanced<Params>;\n  Object.assign(resultParams, {\n    openOn: sample({ clock: advancedParams.openOn as Unit<any> }),\n    cancelOn: sample({\n      clock: (advancedParams.cancelOn as Unit<any>) || createEvent(),\n    }),\n  });\n  return resultParams;\n}\n","import { UnmappedRouteObject, RouteObject, RouteObjectInternal } from \"../types\";\n\nexport function remapRouteObjects(objects: UnmappedRouteObject<any>[], basePath: string = \"\") {\n  let next: RouteObject<any>[] = [];\n\n  for (const routeObj of objects) {\n    if (Array.isArray(routeObj.route)) {\n      next.push(...routeObj.route.map((route) => ({ ...routeObj, route })));\n    } else {\n      // @ts-expect-error\n      next.push(routeObj);\n    }\n  }\n\n  next = next.map((routeObj) => ({\n    ...routeObj,\n    path: `${basePath}${routeObj.path}`,\n  }));\n\n  const derivedRoutes: RouteObject<any>[] = [];\n  const nonDerivedRoutes: RouteObjectInternal<any>[] = [];\n\n  for (const routeObj of next) {\n    // @ts-expect-error Internals\n    if (routeObj.route.settings.derived) {\n      derivedRoutes.push(routeObj);\n    } else {\n      nonDerivedRoutes.push(routeObj as RouteObjectInternal<any>);\n    }\n  }\n\n  if (derivedRoutes.length) {\n    for (const derivedRoute of derivedRoutes) {\n      console.error(\n        `[Atomic-Router]: createHistoryRouter: ${derivedRoute.path} uses derived route. This won't work`,\n      );\n    }\n  }\n\n  return nonDerivedRoutes;\n}\n"],"names":["createRoute","params","navigateFx","createEffect","_ref","_ref$replace","replace","query","name","sid","openFx","attach","and","effect","mapParams","or","$isOpened","createStore","$params","$query","opened","createEvent","updated","closed","on","_","_ref2","_ref3","_ref4","_ref5","split","source","doneData","match","map","isOpened","cases","navigate","open","kind","Kind","ROUTE","settings","derived","Boolean","filter","paramsEqual","a","b","Object","keys","length","k","createRouterControls","updateFilter","update","current","back","forward","parse","str","options","tokens","i","char","push","type","index","value","count","pattern","j","TypeError","concat","code","charCodeAt","lexer","_a","prefixes","defaultPattern","escapeString","delimiter","result","key","path","tryConsume","mustConsume","undefined","consumeText","indexOf","prefix","suffix","modifier","name_1","pattern_1","re","decode","x","pathname","m","exec","create","_loop_1","regexpToFunction","pathToRegexp","flags","sensitive","RegExp","groupsRegex","execResult","regexpToRegexp","Array","isArray","paths","parts","join","arrayToRegexp","strict","_b","start","_c","end","_d","encode","_e","_f","endsWith","endsWithRe","delimiterRe","route","_i","tokens_1","token","mod","endToken","isEndDelimited","tokensToRegexp","stringToRegexp","buildPath","_serialize$write","serialize","reFlags","validate","matches","data","optional","repeat","segment","test","typeOfMessage","String","tokensToFunction","compile","pathCreator","serializedParams","write","URLSearchParams","matchPath","actualPath","normalizePathCreator","getComparablePath","isRoute","isRouteInternal","assertHistory","history","Error","not","toStore","payload","is","store","Symbol","url","URL","hash","historyPushFx","method","historyBackFx","historyForwardFx","containsCurrentRoute","routeObj","recheckResults","recheck","find","recheckResult","cleanupStrategies","all","irrelevant","empty","preserve","default","none","_normalizeChainRouteP","resultParams","_withFactory","\"-oimir7\"","fn","\"none\"","\"isRouteInternal\"","assign","chainedRoute","\"nxhp9m\"","\"chainedRoute\"","\"createRoute\"","beforeOpen","openOn","merge","cancelOn","effectParams","\"-wf80u2\"","unit","failData","advancedParams","sample","clock","normalizeChainRouteParams","$hasSameParams","combine","stored","routeTriggered","target","_prev","aborted","reset","base","routes","notFoundRoute","hydrate","_ref$controls","controls","\"-eby7\"","\"controls\"","\"createRouterControls\"","$hydrateMode","remappedRoutes","objects","basePath","_step","next","_loop","_next","apply","_objectSpread","_iterator","_createForOfIteratorHelperLoose","done","_step2","derivedRoutes","nonDerivedRoutes","_iterator2","_step3","_iterator3","console","error","remapRouteObjects","setHistory","navigateFromRouteTriggered","historyUpdated","recalculateTriggered","recalculated","routesMatched","routesMismatched","routeNotFound","initialized","$path","newQuery","oldQuery","$activeRoutes","$history","$isFirstCheckPassed","$isRouteNavigateInProgress","pushFx","subscribeHistoryFx","scopedHistoryUpdated","scopeBind","err","listen","historyUpdatedParsed","_serialize$read","location","read","search","fromEntries","historyUpdateTriggered","_serialize$read2","currentRouteMatched","filterMap","currentRouteMismatched","routeStateChangeRequested","hydrateMode","_ref16","paramsAndQuery","_ref17","matchingRoutes","mismatchingRoutes","includes","_matchPath","forEach","mismatchedRoute","mismatchedIndex","some","matchedRoute","splice","matching","mismatching","_ref6","matchingRecalculated","_ref7","_ref8","_ref9","\"-dp1wu2\"","_ref10","_ref11","controlsQuery","localQuery","_ref12","_ref13","isNavigateInProgress","realHistory","_ref14","_serialize$read3","_realHistory$location","_realHistory$location2","realQuery","_ref15","qs","activeRoutes","isFirstCheckPassed","_params$route$$isOpen","_params$route","_params$clock","$source","cleanupStrategy","cleanup","queryUpdatedFromHistory","currentQuery","nextQuery","$queryParam","_query$k","defaultState"],"mappings":"+QAeO,SAASA,EACdC,GAAAA,SAAyB,IAAzBA,EAA4B,CAAA,GAE5B,IAAMC,EAAaC,uBACjBC,IAAA,IAAgBC,EAAAD,EAAEE,QAAe,MAAQ,CACvCL,OADOG,EAANH,QACiB,CAAE,EACpBM,MAFcH,EAALG,OAEO,CAAE,EAClBD,QAHuBD,SAAG,GAAKA,KAI/B,CAAAG,KAAA,aAAAC,IAAA,YAGEC,EAASC,SAAAA,OAAM,CAAAC,IAAC,CACpBC,OAAQX,EACRY,UAAYb,IAAwD,CAClEA,OAASA,GAAU,CAAa,EAChCM,MAAO,CAAC,KAEXQ,GAAA,CAAAP,KAAA,SAAAC,IAAA,aAEKO,EAAYC,SAAWA,aAAU,EAAK,CAAAT,KAAA,YAAAC,IAAA,YACtCS,EAAUD,SAAWA,YAAS,GAAE,CAAAT,KAAA,UAAAC,IAAA,YAChCU,EAASF,SAAWA,YAAa,GAAE,CAAAT,KAAA,SAAAC,IAAA,WAEnCW,EAASC,SAAAA,YAAW,CAAAb,KAAA,SAAAC,IAAA,WACpBa,EAAUD,SAAAA,YAAW,CAAAb,KAAA,UAAAC,IAAA,WACrBc,EAASF,SAAAA,YAAW,CAAAb,KAAA,SAAAC,IAAA,WA+C1B,OA7CAO,EAAUQ,GAAGJ,GAAQ,KAAM,IAAMI,GAAGD,GAAQ,KAAM,IAElDL,EAAQM,GAAGJ,GAAQ,CAACK,EAACC,IAAUA,EAANzB,SAAqBuB,GAAGF,GAAS,CAACG,EAACE,IAAUA,EAAN1B,SAEhEkB,EAAOK,GAAGJ,GAAQ,CAACK,EAACG,IAASA,EAALrB,QAAmBiB,GAAGF,GAAS,CAACG,EAACI,IAASA,EAALtB,QAE7DuB,eAAK,CAAAlB,IAAC,CAAA,CACJmB,OAAQ7B,EAAW8B,SACnBC,MAAOjB,EAAUkB,KAAKC,GAAcA,EAAW,UAAY,WAC3DC,MAAO,CACLhB,OAAAA,EACAE,QAAAA,KAEHP,GAAA,CAAAN,IAAA,YAgBuC,CACtCO,UAAAA,EACAE,QAAAA,EACAC,OAAAA,EACAC,OAAAA,EACAE,QAAAA,EACAC,OAAAA,EACAc,SAAUnC,EACVoC,KAAM5B,EACN6B,KAAMC,EAAKC,MAEXC,SAAU,CACRC,QAASC,QAAQ3C,EAAO4C,SAK9B,8sDCxFO,SAASC,EAAYC,EAAwBC,GAClD,GAAIC,OAAOC,KAAKH,GAAGI,SAAWF,OAAOC,KAAKF,GAAGG,OAC3C,OAAO,EAET,IAAK,IAAMC,KAAKL,EAKd,GAAI,GAAGA,EAAEK,OAAYJ,EAAEI,GACrB,OAAO,EAGX,OAAO,CACT,CCHO,SAASC,IACd,MAAO,CACLlC,OAAQF,SAAWA,YAAC,GAAE,CAAAL,IAAE,CAAE0C,aAAc,CAACC,EAAQC,KAAaV,EAAYU,EAASD,IAAS/C,KAAA,SAAAC,IAAA,YAC5FgD,KAAMpC,SAAAA,YAAW,CAAAb,KAAA,OAAAC,IAAA,WACjBiD,QAASrC,SAAAA,YAAW,CAAAb,KAAA,UAAAC,IAAA,YAExB,CC2EO,SAASkD,EAAMC,EAAKC,GACnBA,SAAY,IAAUA,EAAU,CAAE,GA2BtC,IA1BA,IAAIC,EA3FR,CAAeF,IAGX,IAFA,IAAIE,EAAS,GACTC,EAAI,EACDA,EAAIH,EAAIT,QAAQ,CACnB,IAAIa,EAAOJ,EAAIG,GACf,GAAIC,IAAS,KAAOA,IAAS,KAAOA,IAAS,IAI7C,GAAIA,IAAS,KAIb,GAAIA,IAAS,IAIb,GAAIA,IAAS,IAIb,GAAIA,IAAS,IAyBb,GAAIA,IAAS,IAmCbF,EAAOG,KAAK,CAAEC,KAAM,OAAQC,MAAOJ,EAAGK,MAAOR,EAAIG,WAnCjD,CACI,IAAIM,EAAQ,EACRC,EAAU,GAEd,GAAIV,EADAW,EAAIR,EAAI,KACG,IACX,MAAM,IAAIS,UAAU,sCAAsCC,OAAOF,IAErE,KAAOA,EAAIX,EAAIT,QACX,GAAIS,EAAIW,KAAO,KAAf,CAIA,GAAIX,EAAIW,KAAO,KAEX,KADAF,GACc,EAAG,CACbE,IACA,KACH,OAEA,GAAIX,EAAIW,KAAO,MAChBF,IACIT,EAAIW,EAAI,KAAO,KACf,MAAM,IAAIC,UAAU,uCAAuCC,OAAOF,IAG1ED,GAAWV,EAAIW,IAdd,MAFGD,GAAWV,EAAIW,KAAOX,EAAIW,KAkBlC,GAAIF,EACA,MAAM,IAAIG,UAAU,yBAAyBC,OAAOV,IACxD,IAAKO,EACD,MAAM,IAAIE,UAAU,sBAAsBC,OAAOV,IACrDD,EAAOG,KAAK,CAAEC,KAAM,UAAWC,MAAOJ,EAAGK,MAAOE,IAChDP,EAAIQ,CAEP,KA3DD,CAGI,IAFA,IAAI/D,EAAO,GACP+D,EAAIR,EAAI,EACLQ,EAAIX,EAAIT,QAAQ,CACnB,IAAIuB,EAAOd,EAAIe,WAAWJ,GAC1B,KAECG,GAAQ,IAAMA,GAAQ,IAElBA,GAAQ,IAAMA,GAAQ,IAEtBA,GAAQ,IAAMA,GAAQ,KAEvBA,IAAS,IAIb,MAHIlE,GAAQoD,EAAIW,IAInB,CACD,IAAK/D,EACD,MAAM,IAAIgE,UAAU,6BAA6BC,OAAOV,IAC5DD,EAAOG,KAAK,CAAEC,KAAM,OAAQC,MAAOJ,EAAGK,MAAO5D,IAC7CuD,EAAIQ,CAEP,MA3BGT,EAAOG,KAAK,CAAEC,KAAM,QAASC,MAAOJ,EAAGK,MAAOR,EAAIG,YAJlDD,EAAOG,KAAK,CAAEC,KAAM,OAAQC,MAAOJ,EAAGK,MAAOR,EAAIG,YAJjDD,EAAOG,KAAK,CAAEC,KAAM,eAAgBC,MAAOJ,IAAKK,MAAOR,EAAIG,YAJ3DD,EAAOG,KAAK,CAAEC,KAAM,WAAYC,MAAOJ,EAAGK,MAAOR,EAAIG,MA4E5D,CAED,OADAD,EAAOG,KAAK,CAAEC,KAAM,MAAOC,MAAOJ,EAAGK,MAAO,KACrCN,CACX,EAMiBc,CAAMhB,GACfiB,EAAKhB,EAAQiB,SAAUA,EAAWD,SAAO,EAAS,KAAOA,EACzDE,EAAiB,KAAKN,OAAOO,EAAanB,EAAQoB,WAAa,OAAQ,OACvEC,EAAS,GACTC,EAAM,EACNpB,EAAI,EACJqB,EAAO,GACPC,EAAuBnB,IACvB,GAAIH,EAAID,EAAOX,QAAUW,EAAOC,GAAGG,OAASA,EACxC,OAAOJ,EAAOC,KAAKK,KAC/B,EACQkB,EAAwBpB,IACxB,IAAIE,EAAQiB,EAAWnB,GACvB,GAAIE,SAAUmB,EACV,OAAOnB,EACX,IAAIS,EAAKf,EAAOC,GAAwBI,EAAQU,EAAGV,MACnD,MAAM,IAAIK,UAAU,cAAcC,OADHI,EAAGX,KACiB,QAAQO,OAAON,EAAO,eAAeM,OAAOP,GACvG,EACQsB,EAAc,KAGd,IAFA,IACIpB,EADAc,EAAS,GAELd,EAAQiB,EAAW,SAAWA,EAAW,iBAC7CH,GAAUd,EAEd,OAAOc,CACf,EACWnB,EAAID,EAAOX,QAAQ,CACtB,IAAIa,EAAOqB,EAAW,QAClB7E,EAAO6E,EAAW,QAClBf,EAAUe,EAAW,WACzB,GAAI7E,GAAQ8D,EAEJQ,EAASW,QADTC,EAAS1B,GAAQ,OACa,IAC9BoB,GAAQM,EACRA,EAAS,IAETN,IACAF,EAAOjB,KAAKmB,GACZA,EAAO,IAEXF,EAAOjB,KAAK,CACRzD,KAAMA,GAAQ2E,IACdO,OAAQA,EACRC,OAAQ,GACRrB,QAASA,GAAWS,EACpBa,SAAUP,EAAW,aAAe,SAf5C,CAmBA,IAAIjB,EAAQJ,GAAQqB,EAAW,gBAC/B,GAAIjB,EACAgB,GAAQhB,OAQZ,GALIgB,IACAF,EAAOjB,KAAKmB,GACZA,EAAO,IAEAC,EAAW,QACtB,CACI,IAAIK,EAASF,IACTK,EAASR,EAAW,SAAW,GAC/BS,EAAYT,EAAW,YAAc,GACrCM,EAASH,IACbF,EAAY,SACZJ,EAAOjB,KAAK,CACRzD,KAAMqF,IAAWC,EAAYX,IAAQ,IACrCb,QAASuB,IAAWC,EAAYf,EAAiBe,EACjDJ,OAAQA,EACRC,OAAQA,EACRC,SAAUP,EAAW,aAAe,IAG3C,MACDC,EAAY,MA1BX,CA2BJ,CACD,OAAOJ,CACX,CAoEO,SAASjD,EAAM2B,EAAKC,GACvB,IAAIX,EAAO,GAEX,MAKG,EAA0B6C,EAAI7C,EAAMW,KACnCA,SAAY,IAAUA,EAAU,CAAE,GACtC,IAAIgB,EAAKhB,EAAQmC,OAAQA,EAASnB,SAAO,EAAmBoB,GAAYA,EAAOpB,EAC/E,OAAiBqB,IACb,IAAIC,EAAIJ,EAAGK,KAAKF,GAChB,IAAKC,EACD,OAAO,EAgBX,IAfA,IAAIf,EAAOe,EAAE,GAAIhC,EAAQgC,EAAEhC,MACvBlE,EAASgD,OAAOoD,OAAO,MACvBC,EAAoBvC,IACpB,GAAIoC,EAAEpC,UAAOwB,EACT,MAAO,WACX,IAAIJ,EAAMjC,EAAKa,EAAI,GAEf9D,EAAOkF,EAAI3E,MADX2E,EAAIS,WAAa,KAAOT,EAAIS,WAAa,IACtBO,EAAEpC,GAAGjC,MAAMqD,EAAIO,OAASP,EAAIQ,QAAQzD,KAAckC,GAC1D4B,EAAO5B,EAAOe,KAINa,EAAOG,EAAEpC,GAAIoB,EAEhD,EACiBpB,EAAI,EAAGA,EAAIoC,EAAEhD,OAAQY,IAC1BuC,EAAQvC,GAEZ,MAAO,CAAEqB,KAAMA,EAAMjB,MAAOA,EAAOlE,OAAQA,EACnD,CACA,EAhCWsG,CADEC,EAAa5C,EAAKV,EAAMW,GACLX,EAAMW,EACtC,CAmCA,SAASmB,EAAapB,GAClB,OAAOA,EAAItD,QAAQ,4BAA6B,OACpD,CAIA,SAASmG,EAAM5C,GACX,OAAOA,GAAWA,EAAQ6C,UAAY,GAAK,GAC/C,CA0GO,SAASF,EAAapB,EAAMlC,EAAMW,GACrC,OAAIuB,aAAgBuB,OAvGxB,EAAwBvB,EAAMlC,KAC1B,IAAKA,EACD,OAAOkC,EAIX,IAHA,IAAIwB,EAAc,0BACdzC,EAAQ,EACR0C,EAAaD,EAAYR,KAAKhB,EAAKrD,QAChC8E,GACH3D,EAAKe,KAAK,CAENzD,KAAMqG,EAAW,IAAM1C,IACvBuB,OAAQ,GACRC,OAAQ,GACRC,SAAU,GACVtB,QAAS,KAEbuC,EAAaD,EAAYR,KAAKhB,EAAKrD,QAEvC,OAAOqD,CACX,EAsFe0B,CAAe1B,EAAMlC,GAC5B6D,MAAMC,QAAQ5B,GAnFtB,EAAuB6B,EAAO/D,EAAMW,KAChC,IAAIqD,EAAQD,EAAM/E,KAAckD,GAAeoB,EAAapB,EAAMlC,EAAMW,GAAS9B,SACjF,OAAO,IAAI4E,OAAO,MAAMlC,OAAOyC,EAAMC,KAAK,KAAM,KAAMV,EAAM5C,GAChE,EAiFeuD,CAAchC,EAAMlC,EAAMW,GA7EzC,EAAwBuB,EAAMlC,EAAMW,IAM7B,EAAwBC,EAAQZ,EAAMW,KACrCA,SAAY,IAAUA,EAAU,CAAE,GAMtC,IALA,IAAIgB,EAAKhB,EAAQwD,OAAQA,EAASxC,SAAO,GAAiBA,EAAIyC,EAAKzD,EAAQ0D,MAAOA,EAAQD,SAAO,GAAgBA,EAAIE,EAAK3D,EAAQ4D,IAAKA,EAAMD,SAAO,GAAgBA,EAAIE,EAAK7D,EAAQ8D,OAAQA,EAASD,SAAO,EAAmBzB,GAAYA,EAAOyB,EAAIE,EAAK/D,EAAQoB,UAAWA,EAAY2C,SAAO,EAAS,MAAQA,EAAIC,EAAKhE,EAAQiE,SAChUC,EAAa,IAAItD,OAAOO,EAD6T6C,SAAO,EAAS,GAAKA,GAC1T,OAChDG,EAAc,IAAIvD,OAAOO,EAAaC,GAAY,KAClDgD,EAAQV,EAAQ,IAAM,GAEjBW,EAAK,EAAGC,EAAWrE,EAAQoE,EAAKC,EAAShF,OAAQ+E,IAAM,CAC5D,IAAIE,EAAQD,EAASD,GACrB,UAAWE,GAAU,SACjBH,GAASjD,EAAa2C,EAAOS,QAE5B,CACD,IAAI1C,EAASV,EAAa2C,EAAOS,EAAM1C,SACnCC,EAASX,EAAa2C,EAAOS,EAAMzC,SACvC,GAAIyC,EAAM9D,QAGN,GAFIpB,GACAA,EAAKe,KAAKmE,GACV1C,GAAUC,EACV,GAAIyC,EAAMxC,WAAa,KAAOwC,EAAMxC,WAAa,IAAK,CAClD,IAAIyC,EAAMD,EAAMxC,WAAa,IAAM,IAAM,GACzCqC,GAAS,MAAMxD,OAAOiB,EAAQ,QAAQjB,OAAO2D,EAAM9D,QAAS,QAAQG,OAAOkB,GAAQlB,OAAOiB,EAAQ,OAAOjB,OAAO2D,EAAM9D,QAAS,QAAQG,OAAOkB,EAAQ,KAAKlB,OAAO4D,EACrK,MAEGJ,GAAS,MAAMxD,OAAOiB,EAAQ,KAAKjB,OAAO2D,EAAM9D,QAAS,KAAKG,OAAOkB,EAAQ,KAAKlB,OAAO2D,EAAMxC,eAK/FqC,GADAG,EAAMxC,WAAa,KAAOwC,EAAMxC,WAAa,IACpC,OAAOnB,OAAO2D,EAAM9D,QAAS,KAAKG,OAAO2D,EAAMxC,SAAU,KAGzD,IAAInB,OAAO2D,EAAM9D,QAAS,KAAKG,OAAO2D,EAAMxC,eAK7DqC,GAAS,MAAMxD,OAAOiB,GAAQjB,OAAOkB,EAAQ,KAAKlB,OAAO2D,EAAMxC,SAEtE,CACJ,CACD,GAAI6B,EACKJ,IACDY,GAAS,GAAGxD,OAAOuD,EAAa,MACpCC,GAAUpE,EAAQiE,SAAiB,MAAMrD,OAAOsD,EAAY,KAA/B,QAE5B,CACD,IAAIO,EAAWxE,EAAOA,EAAOX,OAAS,GAClCoF,SAAwBD,GAAa,SACnCN,EAAYvC,QAAQ6C,EAASA,EAASnF,OAAS,KAAO,EACtDmF,SAAa/C,EACd8B,IACDY,GAAS,MAAMxD,OAAOuD,EAAa,OAAOvD,OAAOsD,EAAY,QAE5DQ,IACDN,GAAS,MAAMxD,OAAOuD,EAAa,KAAKvD,OAAOsD,EAAY,KAElE,CACD,OAAO,IAAIpB,OAAOsB,EAAOxB,EAAM5C,GACnC,EAhEW2E,CAAe7E,EAAMyB,EAAMvB,GAAUX,EAAMW,GA6E3C4E,CAAerD,EAAMlC,EAAMW,EACtC,CCpXO,SAAS6E,EAAStI,GAKG,IAAAuI,EAH1B1I,EAAMG,EAANH,OACAM,EAAKH,EAALG,MACAqI,EAASxI,EAATwI,UAEM1C,ED+ID,EAAiBtC,EAAKC,IAMtB,EAA0BC,EAAQD,KACjCA,SAAY,IAAUA,EAAU,CAAE,GACtC,IAAIgF,EAAUpC,EAAM5C,GAChBgB,EAAKhB,EAAQ8D,OAAQA,EAAS9C,SAAO,EAAmBoB,GAAYA,EAAOpB,EAAIyC,EAAKzD,EAAQiF,SAAUA,EAAWxB,SAAO,GAAgBA,EAExIyB,EAAUjF,EAAO5B,KAAckG,IAC/B,UAAWA,GAAU,SACjB,OAAO,IAAIzB,OAAO,OAAOlC,OAAO2D,EAAM9D,QAAS,MAAOuE,EAElE,IACI,OAAiBG,IAEb,IADA,IAAI5D,EAAO,GACFrB,EAAI,EAAGA,EAAID,EAAOX,OAAQY,IAAK,CACpC,IAAIqE,EAAQtE,EAAOC,GACnB,UAAWqE,GAAU,SAArB,CAIA,IAAIhE,EAAQ4E,EAAOA,EAAKZ,EAAM5H,WAAQ+E,EAClC0D,EAAWb,EAAMxC,WAAa,KAAOwC,EAAMxC,WAAa,IACxDsD,EAASd,EAAMxC,WAAa,KAAOwC,EAAMxC,WAAa,IAC1D,GAAImB,MAAMC,QAAQ5C,GAAlB,CACI,IAAK8E,EACD,MAAM,IAAI1E,UAAU,cAAcC,OAAO2D,EAAM5H,KAAM,uCAEzD,GAAI4D,EAAMjB,SAAW,EAAG,CACpB,GAAI8F,EACA,SACJ,MAAM,IAAIzE,UAAU,cAAcC,OAAO2D,EAAM5H,KAAM,sBACxD,CACD,IAAK,IAAI+D,EAAI,EAAGA,EAAIH,EAAMjB,OAAQoB,IAAK,CACnC,IAAI4E,EAAUxB,EAAOvD,EAAMG,GAAI6D,GAC/B,GAAIU,IAAaC,EAAQhF,GAAGqF,KAAKD,GAC7B,MAAM,IAAI3E,UAAU,kBAAkBC,OAAO2D,EAAM5H,KAAM,kBAAkBiE,OAAO2D,EAAM9D,QAAS,kBAAkBG,OAAO0E,EAAS,OAEvI/D,GAAQgD,EAAM1C,OAASyD,EAAUf,EAAMzC,MAC1C,CAEJ,MACD,UAAWvB,GAAU,iBAAmBA,GAAU,UAQlD,IAAI6E,EAAJ,CAEA,IAAII,EAAgBH,EAAS,WAAa,WAC1C,MAAM,IAAI1E,UAAU,cAAcC,OAAO2D,EAAM5H,KAAM,aAAaiE,OAAO4E,GAF5D,MATb,CAEI,GADIF,EAAUxB,EAAO2B,OAAOlF,GAAQgE,GAChCU,IAAaC,EAAQhF,GAAGqF,KAAKD,GAC7B,MAAM,IAAI3E,UAAU,cAAcC,OAAO2D,EAAM5H,KAAM,kBAAkBiE,OAAO2D,EAAM9D,QAAS,kBAAkBG,OAAO0E,EAAS,OAEnI/D,GAAQgD,EAAM1C,OAASyD,EAAUf,EAAMzC,MAE1C,CA7BA,MAFGP,GAAQgD,CAoCf,CACD,OAAOhD,CACf,CACA,EA3DWmE,CAAiB5F,EAAMC,EAAKC,GAAUA,GChJ9B2F,CALNpJ,EAAXqJ,YAKiBD,CAAqBvJ,GAChCyJ,GAAgBf,EAAGC,IAAAA,MAAAA,SAAAA,OAAAA,EAAAA,EAAWe,MAAMpJ,MAAMoI,MAAAA,SAAAA,EAAAA,EAAI,IAAIiB,gBAAgBrJ,GAGxE,OADe2F,GADJjD,OAAOC,KAAK3C,GAAO4C,OAAauG,IAAAA,EAAqB,GAGlE,CAMO,SAASG,EAASnI,GAGG,IAD1BoI,EAAUpI,EAAVoI,WAEMf,EAAU9G,EA/BlB,CAA8BwH,GACrBA,EAAYnJ,QAAQ,MAAO,SA8BZyJ,CAHXrI,EAAX+H,aAGgBxH,CAAyC+H,EAAkBF,IAC3E,OAAIf,EACK,CAAEA,SAAS,EAAM9I,OAAQ8I,EAAQ9I,QAEnC,CAAE8I,SAAS,EACpB,CCjDO,SAASkB,EAAQhC,GACtB,cACSA,GAAU,UAAYA,IAAU,MAAQ,SAAUA,GAASA,EAAM1F,OAASC,EAAKC,KAE1F,CAEO,SAASyH,EACdjC,GAEA,OAAOgC,EAAQhC,EACjB,CCRA,SAASkC,EAAcC,GACrB,IAAKA,EACH,MAAM,IAAIC,MAAM,sCAEpB,CCPO,SAASC,EAAOvI,GACrB,OAAOA,EAAOG,KAAKkC,IAAWA,GAChC,CCkDA,SAASmG,EAAWC,GAClB,OAAOC,SAAEA,GAACC,MAAMF,EAAO,CAAA/J,IAAA,WAAI+J,EAAUvJ,SAAWA,YAACuJ,EAAO,CAAA/J,IAAA,WAC1D,CCUO,IAAM+B,EAAO,CAClBC,MAAOkI,UL7DHX,EAAqB5E,IACzB,GAAIA,EAAKnD,MAAM,qBACb,OAAOmD,EAET,IAAMwF,EAAM,IAAIC,IAAG,WAAYzF,GAC/B,MAAO,CAACwF,EAAI1E,SAAU0E,EAAIE,MAAM3D,KAAK,GACvC,EEDa4D,EAAgB5K,SAAAA,cAAcF,IACzCkK,EAAclK,EAAOmK,SACrBnK,EAAOmK,QAAQnK,EAAO+K,QAAQ/K,EAAOmF,KAAM,CAAA,GACpCnF,IACR,CAAAO,KAAA,gBAAAC,IAAA,WAEYwK,EAAgB9K,SAAAA,cAAciK,IACzCD,EAAcC,GACdA,EAAQ3G,OACD2G,IACR,CAAA5J,KAAA,gBAAAC,IAAA,YAEYyK,EAAmB/K,SAAAA,cAAciK,IAC5CD,EAAcC,GACdA,EAAQ1G,UACD0G,IACR,CAAA5J,KAAA,mBAAAC,IAAA,WI8aK0K,EACHC,GAAgCC,IAC/B,IAAMC,EAAUD,EAAeE,MAC5BC,GAAkBA,EAAcJ,SAASnD,QAAUmD,EAASnD,QAE/D,GAAKqD,EAGL,MAAO,CACLrL,OAAQqL,EAAQrL,OAChBM,MAAO+K,EAAQ/K,QC1YfkL,EAAoB,CACxBC,IAAK,CACHC,YAAY,EACZC,OAAO,EACPC,SAAU,IAEZC,QAAS,CACPH,YAAY,EACZC,OAAO,EACPC,SAAU,IAEZE,KAAM,CACJJ,YAAY,EACZC,OAAO,EACPC,SAAU,yCCQZ5L,IAEA,IAAA+L,EAuDF,CACE/L,IAEA,IAAMgM,EAAmD,CAAA,EAEzD,GAAAC,qBAAA,CAAAzL,IAAA0L,UAAAC,OAAIlC,EAAgBjK,GAAOO,KAAA6L,OAAArB,OAAAsB,oBAQzB,OAPArJ,OAAOsJ,OAAON,EAAc,CAC1BhE,MAAOhI,EACPuM,aAAYN,SAAAA,YAAA,CAAAzL,IAAAgM,SAAAL,OAAEpM,IAAqBQ,KAAAkM,eAAA1B,OAAA2B,gBACnCC,WAAYvL,SAAAA,YAAW,CAAAb,KAAA,aAAAC,IAAA,YACvBoM,OAAQC,SAAKA,MAAC,CAAC7M,EAAOmB,OAAQnB,EAAOsB,QAAO,CAAAf,KAAA,SAAAC,IAAA,YAC5CsM,SAAUD,SAAKA,MAAC,GAAE,CAAAtM,KAAA,WAAAC,IAAA,cAEbwL,EAET,IAAMe,EAAe/M,EAQrB,GAPAgD,OAAOsJ,OAAON,EAAc,CAC1BhE,MAAO+E,EAAa/E,MACpBuE,aAAcQ,EAAaR,cAAYN,qBAAA,CAAAzL,IAAAwM,UAAAb,OAAIpM,IAAqBQ,KAAAkM,eAAA1B,OAAA2B,gBAChEC,WAAYnC,SAAAA,GAAGyC,KAAKF,EAAaJ,YAC7BI,EAAaJ,WACbjM,gBAAM,CAAAC,IAACoM,EAAaJ,WAAU7L,GAAA,CAAAP,KAAA,aAAAC,IAAA,eAEhCgK,YAAG5J,OAAOoL,EAAaW,WAAU,CAAAnM,IAAA,YASnC,OARAwC,OAAOsJ,OAAON,EAAc,CAC1BY,OAEEG,EAAaH,QAAUZ,EAAaW,WAAW5K,SACjD+K,SAEEC,EAAaD,UAAYd,EAAaW,WAAWO,WAE9ClB,EAET,IAAMmB,EAAiBnN,EAOvB,OANAgD,OAAOsJ,OAAON,EAAc,CAC1BY,OAAQQ,SAAAA,OAAM,CAAAzM,IAAC,CAAA,CAAE0M,MAAOF,EAAeP,SAAqB9L,GAAA,CAAAP,KAAA,SAAAC,IAAA,YAC5DsM,SAAUM,SAAAA,OAAM,CAAAzM,IAAC,CAAA,CACf0M,MAAQF,EAAeL,UAA0B1L,qBAAW,CAAAb,KAAA,QAAAC,IAAA,cAC7DM,GAAA,CAAAP,KAAA,WAAAC,IAAA,cAEIwL,CACT,EAjGgEsB,CAA0BtN,GAAhFgI,EAAK+D,EAAL/D,MAAOuE,EAAYR,EAAZQ,aAAcI,EAAUZ,EAAVY,WAAYC,EAAMb,EAANa,OAAQE,EAAQf,EAARe,SAC3C7L,EAAUD,SAAWA,YAAC,GAAE,CAAAT,KAAA,UAAAC,IAAA,YACxBU,EAASF,SAAWA,YAAC,GAAE,CAAAT,KAAA,SAAAC,IAAA,WACvB+M,EAAiBC,SAAAA,QAAO,CAAA7M,KAC5B6M,SAAAA,QAAO,CAAA7M,IAAA,CAAC,CAACqH,EAAM/G,QAAS+G,EAAM9G,SAAOJ,GAAA,CAAAP,KAAA,MAAAC,IAAA,YACrCgN,SAAAA,QAAO,CAAA7M,IAAC,CAAA,CAACM,EAASC,IAAOJ,GAAA,CAAAP,KAAA,MAAAC,IAAA,YACzB,CAAC+C,EAASkK,IACDlK,EAAQ,KAAOkK,EAAO,IAAMlK,EAAQ,KAAOkK,EAAO,IAC1D3M,GAAA,CAAAP,KAAA,iBAAAC,IAAA,YAEGkN,EAAiBN,SAAAA,OAAM,CAAAzM,IAAC,CAAA,CAAE0M,MAAO,CAACrF,EAAM7G,OAAQ6G,EAAM3G,WAAUP,GAAA,CAAAP,KAAA,iBAAAC,IAAA,aAGtE4M,gBAAM,CAAAzM,IAAC,CAAA,CACL0M,MAAOK,EACPC,OAAQhB,IACT7L,GAAA,CAAAN,IAAA,aAEDS,EAAQM,GAAGmM,GAAgB,CAACE,EAAKzN,IAAUA,EAANH,SACrCkB,EAAOK,GAAGmM,GAAgB,CAACE,EAAKnM,IAASA,EAALnB,QAGpC8M,gBAAM,CAAAzM,IAAC,CAAA,CACL0M,MAAOT,EACP9K,OAAQ,CAAE9B,OAAQiB,EAASX,MAAOY,GAClC0B,OAAQ2K,EACRI,OAAQpB,EAAanK,WACtBtB,GAAA,CAAAN,IAAA,aAID,IAAMqN,EAAUhB,SAAAA,MAAM,CAAC7E,EAAM1G,OAAQwL,GAAS,CAAAvM,KAAA,UAAAC,IAAA,WAU9C,OARAS,EAAQ6M,MAAMD,GACd3M,EAAO4M,MAAMD,GAEbT,gBAAM,CAAAzM,IAAC,CAAA,CACL0M,MAAOQ,EACPF,OAAQpB,EAAajL,SACtBR,GAAA,CAAAN,IAAA,aAEM+L,CACT,wBFxHmCpM,IAchC,IAbD4N,EAAI5N,EAAJ4N,KACAC,EAAM7N,EAAN6N,OACAC,EAAa9N,EAAb8N,cACAC,EAAO/N,EAAP+N,QACAvF,EAASxI,EAATwI,UAASwF,EAAAhO,EACTiO,SAAAA,EAAQD,SAAA,EAAAlC,qBAAA,CAAAzL,IAAA6N,QAAAlC,OAAG/I,IAAsB7C,KAAA+N,WAAAvD,OAAAwD,yBAAAJ,EAS3BK,EAAexN,SAAWA,YAACkN,UAAAA,SAAO,GAAPA,EAAgB,CAAAvN,IAAE,CAKjDgI,UAAW,UACZpI,KAAA,eAAAC,IAAA,YACKiO,EGvCD,EAA2BC,EAAqCC,KAAAA,SAAgB,IAAhBA,EAAmB,IAGxF,IAFA,IAE8BC,EAF1BC,EAA2B,GAAGC,EAAAA,KAEF,IACKC,EAD1B5D,EAAQyD,EAAAzK,MACb2C,MAAMC,QAAQoE,EAASnD,QACzB+G,EAAAF,GAAK7K,KAAIgL,MAAAD,EAAI5D,EAASnD,MAAM/F,KAAK+F,GAAKiH,EAAAA,EAAA,CAAA,EAAW9D,GAAQ,CAAA,EAAA,CAAEnD,MAAAA,OAG3D6G,EAAK7K,KAAKmH,IALd+D,EAAAC,EAAuBT,KAAOE,EAAAM,KAAAE,MAAAN,IAS9BD,EAAOA,EAAK5M,KAAKkJ,GAAQ8D,EAAAA,EAAA,CAAA,EACpB9D,GAAQ,CAAA,EAAA,CACXhG,KAASwJ,GAAAA,EAAWxD,EAAShG,SAM/B,IAHA,IAG2BkK,EAHrBC,EAAoC,GACpCC,EAA+C,GAErDC,EAAAL,EAAuBN,KAAIQ,EAAAG,KAAAJ,MAAE,CAAA,IAAlBjE,EAAQkE,EAAAlL,MAEbgH,EAASnD,MAAMvF,SAASC,QAC1B4M,EAActL,KAAKmH,GAEnBoE,EAAiBvL,KAAKmH,EAE1B,CAEA,GAAImE,EAAcpM,OAChB,IAAA,IAAwCuM,EAAxCC,EAAAP,EAA2BG,KAAaG,EAAAC,KAAAN,MACtCO,QAAQC,MAAK,yCADQH,EAAAtL,MAEmCgB,6CAK5D,OAAOoK,CACT,EHCyBM,CAAkB7B,EAAQD,GAE3C+B,EAAa1O,SAAAA,YAAW,CAAAb,KAAA,aAAAC,IAAA,WACxBuP,EAA6B3O,SAAAA,YAAW,CAAAb,KAAA,6BAAAC,IAAA,WAMxCwP,EAAiB5O,SAAAA,YAAW,CAAAb,KAAA,iBAAAC,IAAA,WAC5ByP,EAAuB7O,SAAAA,YAAW,CAAAb,KAAA,uBAAAC,IAAA,WAKlC0P,EAAe9O,SAAAA,YAAW,CAAAb,KAAA,eAAAC,IAAA,WAM1B2P,EAAgB/O,SAAAA,YAAW,CAAAb,KAAA,gBAAAC,IAAA,YAC3B4P,EAAmBhP,SAAAA,YAAW,CAAAb,KAAA,mBAAAC,IAAA,WAC9B6P,EAAgBjP,SAAAA,YAAW,CAAAb,KAAA,gBAAAC,IAAA,YAC3B8P,EAAclP,SAAAA,YAAW,CAAAb,KAAA,cAAAC,IAAA,WAMzB+P,EAAQvP,SAAWA,YAAC,GAAE,CAAAT,KAAA,QAAAC,IAAA,WACtBU,EAASF,SAAWA,YACxB,GAAE,CAAAL,IACF,CACEJ,KAAM,uBACN8C,aAAc,CAACmN,EAAUC,KAAc5N,EAAY2N,EAAUC,IAC9DlQ,KAAA,SAAAC,IAAA,WAEGkQ,EAAgB1P,SAAWA,YAAuB,GAAE,CAAAL,IAAE,CAC1DgI,UAAW,UACZpI,KAAA,gBAAAC,IAAA,YAEKmQ,EAAW3P,SAAWA,YAAU,KAAI,CAAAL,IAAE,CAC1CgI,UAAW,UACZpI,KAAA,WAAAC,IAAA,WACKoQ,EAAsB5P,SAAWA,aAAC,EAAK,CAAAT,KAAA,sBAAAC,IAAA,WACvCqQ,EAA6B7P,SAAWA,aAAC,EAAK,CAAAT,KAAA,6BAAAC,IAAA,YAE9CsQ,EAASpQ,SAAAA,OAAM,CAAAC,IAAC,CACpBmB,OAAQ6O,EACR/P,OAAMA,CAACuJ,EAASnK,IACP8K,EAAamE,EAAA,CAClB9E,QAAAA,GACGnK,KAGRc,GAAA,CAAAP,KAAA,SAAAC,IAAA,YAEKuQ,EAAqBrQ,SAAAA,OAAM,CAAAC,IAAC,CAChCmB,OAAQ6O,EACR/P,OAAOuJ,IACL,IAAI6G,EAAuBhB,EAC3B,IAEEgB,EAAuBC,SAAAA,UAAUjB,EACnC,CAAE,MAAOkB,GAAM,CAIf,OAHA/G,EAAQgH,QAAO,KACbH,GACF,KACO,CACT,GACDlQ,GAAA,CAAAP,KAAA,qBAAAC,IAAA,YAEK4Q,EAAuBhE,SAAAA,OAAM,CAAAzM,IAAC,CAAA,CAClC0M,MAAOa,EAAU,CAAC8B,GAAkB,CAACA,EAAgBe,EAAmB3B,MACxEtN,OAAQ6O,EACR/N,OAAQD,QACRwJ,GAAKhC,IAAO,IAAAkH,EAAA,MAAM,CAChBlM,KAAMgF,EAAQmH,SAASrL,SACvB3F,OAAK+Q,EACH1I,UAAAA,SAAS,OAAA,EAATA,EAAW4I,KAAKpH,EAAQmH,SAASE,WAAOH,MAAAA,SAAAA,EAAAA,EACxCrO,OAAOyO,YAAY,IAAI9H,gBAAgBQ,EAAQmH,SAASE,SAC3D,IACF1Q,GAAA,CAAAP,KAAA,uBAAAC,IAAA,YAIKkR,EAAyBtE,SAAAA,OAAM,CAAAzM,IAAC,CAAA,CACpC0M,MAAO+D,EACPtP,OAAQ,CACNqD,KAAMoL,EACNjQ,MAAOY,GAET0B,OAAQ,CAAAnB,EAAyC0I,IAC/CA,EAAQhF,OADgB1D,EAAf0D,OACsBtC,EAAYsH,EAAQ7J,MADRmB,EAAjBnB,OAE5B6L,GAAI,CAAC3K,EAAG2I,IAAYA,IACrBrJ,GAAA,CAAAP,KAAA,yBAAAC,IAAA,aAGDmQ,EAASpP,GAAGuO,GAAY,CAACtO,EAAG2I,IAAYA,IAExCiD,gBAAM,CAAAzM,IAAC,CAAA,CACL0M,MAAOsD,EACPhD,OAAQoD,IACTjQ,GAAA,CAAAN,IAAA,YAED4M,gBAAM,CAAAzM,IAAC,CAAA,CACL0M,MAAOqE,EACP5P,OAAQ6O,EACR/N,OAAQD,QACRwJ,GAAGhC,IAAS,IAAAwH,EAEJ9G,EAAOV,IAAAA,MAAAA,kBAAAA,EAASmH,SAASzG,KAI/B,MAAO,CAAE1F,KALIgF,IAAAA,MAAAA,kBAAAA,EAASmH,SAASrL,SAKhB3F,OAHQqR,EACrBhJ,IAAAA,MAAAA,kBAAAA,EAAW4I,KAAKpH,UAAAA,SAAO,OAAA,EAAPA,EAASmH,SAASE,iBAAOG,SAAA,EAAAA,EACzC3O,OAAOyO,YAAY,IAAI9H,gBAAgBQ,IAAAA,MAAAA,kBAAAA,EAASmH,SAASE,SACrC3G,KAAAA,EACvB,EACD8C,OAAQsC,IACTnP,GAAA,CAAAN,IAAA,YAGD,IAAA,IAAqCoO,EAArCM,EAAAC,EAAuBV,KAAcG,EAAAM,KAAAE,MAAE,CAAA,IAA5BjE,EAAQyD,EAAAzK,MACXyN,EAAsBzB,EAAc0B,UAAU3G,EAAqBC,IACnE2G,EAAyB1B,EAAiByB,UAAU3G,EAAqBC,IACzE4G,EAA4B,CAQhCzB,YAAalD,SAAAA,OAAM,CAAAzM,IAAC,CAAA,CAClB0M,MAAO0D,EAAmB3B,KAC1BxM,OAAQ4K,SAAAA,QAAO,CAAA7M,IACbwK,CAAAA,EAASnD,MAAMjH,UACfyN,EACA,CAACtM,EAAU8P,IAAgB9P,IAAa8P,GAAWlR,GAAA,CAAAP,KAAA,SAAAC,IAAA,cAEtDM,GAAA,CAAAP,KAAA,cAAAC,IAAA,aACDW,OAAQiM,SAAAA,OAAM,CAAAzM,IAAC,CAAA,CACb0M,MAAOuE,EACPhP,OAAQyH,EAAIc,EAASnD,MAAMjH,aAC5BD,GAAA,CAAAP,KAAA,SAAAC,IAAA,YACDa,QAAS+L,SAAAA,OAAM,CAAAzM,IAAC,CAAA,CACd0M,MAAOuE,EACPhP,OAAQuI,EAASnD,MAAMjH,YACxBD,GAAA,CAAAP,KAAA,UAAAC,IAAA,aACDc,OAAQ8L,SAAAA,OAAM,CAAAzM,IAAC,CAAA,CACb0M,MAAOyE,EACPlP,OAAQuI,EAASnD,MAAMjH,YACxBD,GAAA,CAAAP,KAAA,SAAAC,IAAA,aAMH4M,gBAAM,CAAAzM,IAAC,CAAA,CACL0M,MAAO0E,EAA0BzB,YACjCxO,OAAQ,CACN9B,OAAQmL,EAASnD,MAAM/G,QACvBX,MAAO6K,EAASnD,MAAM9G,QAExByM,OAAQxC,EAASnD,MAAM7G,SACxBL,GAAA,CAAAN,IAAA,aAGD4M,gBAAM,CAAAzM,IAAC,CAAA,CACL0M,MAAO0E,EAA0B1Q,QACjCS,OAAQ,CAACqJ,EAASnD,MAAM/G,QAASkK,EAASnD,MAAM9G,QAEhD0B,OAAQ,CAAAqP,EAAkBpD,KAAI,IAAZvO,EAAK2R,EAAA,GAAA,OACpBpP,EADaoP,EAAA,GACOpD,EAAK7O,UAAY6C,EAAYvC,EAAOuO,EAAKvO,MAAM,EACtE6L,GAAI,CAAC3K,EAAG0Q,IAAmBA,EAC3BvE,OAAQxC,EAASnD,MAAM3G,UACxBP,GAAA,CAAAN,IAAA,aAGD4M,gBAAM,CAAAzM,IAAC,CAAA,CACL0M,MAAO0E,EAA0B5Q,OAEjCyB,OAAQyH,EAAIwG,GACZlD,OAAQxC,EAASnD,MAAM7G,SACxBL,GAAA,CAAAN,IAAA,aAGD4M,gBAAM,CAAAzM,IAAC,CAAA,CACL0M,MAAO0E,EAA0BzQ,OACjCqM,OAAQxC,EAASnD,MAAM1G,SACxBR,GAAA,CAAAN,IAAA,YACH,CAGA,IADA,IACqC6O,EADrCP,EAAAA,KACuC,IAA5B3D,EAAQkE,EAAAlL,MAEjBiJ,gBAAM,CAAAzM,IAAC,CAAA,CACL0M,MAAOlC,EAASnD,MAAM5F,SAASL,SAC/BoK,GAAIgG,IAAA,IAAkB9R,EAAO8R,EAAP9R,QAAO,MAAQ,CACnC2H,MAAOmD,EACPnL,OAFWmS,EAANnS,OAGLM,MAHkB6R,EAAL7R,MAIbD,QAASA,IAAO,MAAPA,SAAO,GAAPA,EACT,EACFsN,OAAQoC,IACTjP,GAAA,CAAAN,IAAA,cAXHgP,EAAAL,EAAuBV,KAAcY,EAAAG,KAAAJ,MAAAN,IAcrC+B,EAA2BtP,GAAGwO,GAA4B,KAAM,IAEhE3C,gBAAM,CAAAzM,IAAC,CAAA,CACL0M,MAAO0C,EACP5D,GAAEzK,IAAoC,IAA1B1B,EAAM0B,EAAN1B,OAAQM,EAAKoB,EAALpB,MAAOD,EAAOqB,EAAPrB,QAQzB,MAAO,CACL8E,KARWsD,EAAU,CACrBe,YAFM9H,EAALsG,MAEkB7C,KACnBnF,OAAAA,EACAM,MAAAA,EACAqI,UAAAA,IAKA3I,OAAAA,EACAM,MAAAA,EACAyK,OALiC1K,EAAU,UAAY,OAO1D,EACDsN,OAAQmD,IACThQ,GAAA,CAAAN,IAAA,aAEDqQ,EAA2B/C,MAAM,CAACqC,EAAeC,IAIjDhD,gBAAM,CAAAzM,IAAC,CAAA,CACL0M,MAAO4C,EACP9D,GAAExK,IAIA,IAJwB,IAIU8N,EAJ/BtK,EAAIxD,EAAJwD,KAAM7E,EAAKqB,EAALrB,MAAOuK,EAAIlJ,EAAJkJ,KACVuH,EAAiB,GACjBC,EAAoB,GAE1B3C,EAAAP,EAAoBV,KAAcgB,EAAAC,KAAAN,MAAE,CAAA,IAAzBpH,EAAKyH,EAAAtL,MAER0F,EAAa7B,EAAM7C,KAAKmN,SAAS,KAAUnN,GAAAA,EAAO0F,KAAY1F,EACpEoN,EAA4B3I,EAAU,CACpCJ,YAAaxB,EAAM7C,KACnB0E,WAAAA,KAFa0I,EAAPzJ,QAKyBsJ,EAAiBC,GACnCrO,KAAK,CAClBmH,SAAUnD,EACVhI,OARqBuS,EAANvS,OASfM,MAAAA,GAEJ,CAaA,OATA+R,EAAkBG,SAAQ,CAACC,EAAiBC,KACCN,EAAeO,MACvDC,GAAiBA,EAAazH,SAASnD,QAAUyK,EAAgBtH,SAASnD,SAG3EqK,EAAkBQ,OAAOH,EAAiB,EAE9C,IAEO,CACLI,SAAUV,EACVW,YAAaV,EAAkBzP,OAAOD,SACtCwC,KAAAA,EACA7E,MAAAA,EAEH,EACDqN,OAAQuC,IACTpP,GAAA,CAAAN,IAAA,aAED+P,EAAMhP,GAAGmQ,GAAwB,CAAClQ,EAACI,IAAQA,EAAJuD,OAEvCjE,EAAOK,GAAGmQ,GAAwB,CAAClQ,EAACwR,IAASA,EAAL1S,QAExC,IAAM2S,EAAuB/C,EAAajO,KAAIiR,GAAWA,EAARJ,WAkHjD,OAhHA1F,gBAAM,CAAAzM,IAAC,CAAA,CACL0M,MAAO4F,EACPrQ,OAASoL,GAAWA,EAAO9K,OAAS,EACpCyK,OAAQwC,IACTrP,GAAA,CAAAN,IAAA,aAED4M,gBAAM,CAAAzM,IAAC,CAAA,CACL0M,MAAO6C,EAAajO,KAAIkR,GAAcA,EAAXJ,cAC3BnQ,OAASoL,GAAWA,EAAO9K,OAAS,EACpCyK,OAAQyC,IACTtP,GAAA,CAAAN,IAAA,aAEDkQ,EAAcnP,GAAG2O,GAAc,CAAC1O,EAAC4R,IAAYA,EAARN,SAC1B7Q,KAAKsJ,GAAkBA,EAAcJ,SAASnD,UAIzDoF,gBAAM,CAAAzM,IAAC,CAAA,CACL0M,MAAO4F,EACPrQ,OAASoL,GAAWA,EAAO9K,SAAW,EACtCyK,OAAQ0C,IACTvP,GAAA,CAAAN,IAAA,aAEDyL,qBAAA,CAAAzL,IAAA6S,UAAAlH,OAAIlC,EAAgBgE,GAAc1N,KAAA6L,OAAArB,OAAAsB,sBAChCe,gBAAM,CAAAzM,IAAC,CAAA,CACL0M,MAAOgD,EACPvO,OAAQZ,EACR0B,OAAQqL,EAAclN,UACtBoL,GAAK7L,IAAW,CAAEA,MAAAA,EAAON,OAAQ,CAAC,IAClC2N,OAAQM,EAAc5M,UACvBP,GAAA,CAAAN,IAAA,aAED4M,gBAAM,CAAAzM,IAAC,CAAA,CACL0M,MAAOgD,EACPvO,OAAQ,CAAExB,MAAOY,EAAQgB,SAAU+L,EAAclN,WACjD6B,OAAQ0Q,IAAWA,EAARpR,SACXiK,GAAIoH,IAAgB,CAAEjT,MAAViT,EAALjT,MAAsBN,OAAQ,CAAC,IACtC2N,OAAQM,EAAc9M,SACvBL,GAAA,CAAAN,IAAA,aAED4M,gBAAM,CAAAzM,IAAC,CAAA,CACL0M,MAAO4F,EACPnR,OAAQmM,EAAclN,UACtB6B,OAAQ,CAACV,EAAU4Q,IAAa5Q,GAAY4Q,EAAS5P,OAAS,EAC9DyK,OAAQM,EAAc3M,SACvBR,GAAA,CAAAN,IAAA,cAIH4M,gBAAM,CAAAzM,IAAC,CAAA,CACL0M,MAAOe,EAAS5K,KAChB1B,OAAQ6O,EACRhD,OAAQ3C,IACTlK,GAAA,CAAAN,IAAA,aAED4M,gBAAM,CAAAzM,IAAC,CAAA,CACL0M,MAAOe,EAAS3K,QAChB3B,OAAQ6O,EACRhD,OAAQ1C,IACTnK,GAAA,CAAAN,IAAA,aAGD4M,gBAAM,CAAAzM,IAAC,CAAA,CACL0M,MAAOnM,EACPY,OAAQ,CAAE0R,cAAepF,EAASlN,OAAQuS,WAAYvS,GACtD0B,OAAQ8Q,IAAoC7Q,EAApB6Q,EAAbF,cAAyBE,EAAVD,YAC1BtH,GAAIwH,GAAaA,EAAVF,WACP9F,OAAQS,EAASlN,SAClBJ,GAAA,CAAAN,IAAA,aAED4M,gBAAM,CAAAzM,IAAC,CAAA,CACL0M,MAAOe,EAASlN,OAChBY,OAAQ,CACNqD,KAAMoL,EACNkD,WAAYvS,EACZ0S,qBAAsB/C,EACtBgD,YAAalD,GAEf/N,OAAQ,CAAAkR,EAAoDxT,KAAU,IAAAyT,EAAAC,EAAAC,EAA3DR,EAAUK,EAAVL,WAAYG,EAAoBE,EAApBF,qBAAsBC,EAAWC,EAAXD,YACrCK,GAASH,EACbpL,IAAS,MAATA,SAAS,OAAA,EAATA,EAAW4I,MAAIyC,EAACH,IAAW,MAAXA,SAAW,OAAA,EAAXA,EAAavC,SAASE,UAAM,MAAAwC,SAAA,EAAAA,EAAI,OAAGD,MAAAA,SAAAA,EAAAA,EACnD/Q,OAAOyO,YAAY,IAAI9H,iBAAesK,EAACJ,IAAW,MAAXA,SAAW,OAAA,EAAXA,EAAavC,SAASE,UAAM,MAAAyC,SAAA,EAAAA,EAAI,KACzE,OACEL,IAAyB/Q,EAAYvC,EAAO4T,KAAerR,EAAY4Q,EAAYnT,EAEtF,EACD6L,GAAEA,CAAAgI,EAAW7T,KAAO,IAAAoI,EAAfvD,EAAIgP,EAAJhP,KACGiP,GAAE1L,EAAGC,IAAAA,MAAAA,SAAAA,OAAAA,EAAAA,EAAWe,MAAMpJ,MAAMoI,MAAAA,SAAAA,EAAAA,EAAI,IAAIiB,gBAAgBrJ,GAC1D,MAAO,CACL6E,KAASA,GAAOiP,MAASA,EAAO,IAChCpU,OAAQ,CAAE,EACVM,MAAOA,EACPyK,OAAQ,OAEX,EACD4C,OAAQmD,IACThQ,GAAA,CAAAN,IAAA,aAGD4M,gBAAM,CAAAzM,IAAC,CAAA,CACL0M,MAAO6C,EACPpO,OAAQ,CACNuS,aAAc3D,EACdvL,KAAMoL,EACNjQ,MAAOY,GAET0B,OAAQgO,EAAoB3O,KAAKqS,IAAwBA,IACzD3G,OAAQ2C,IACTxP,GAAA,CAAAN,IAAA,WAEDoQ,EAAoBrP,GAAG+O,GAAa,KAAM,IAAMxC,MAAM6C,GAE/C,CACLJ,MAAAA,EACAG,cAAAA,EACAC,SAAAA,EACAb,WAAAA,EACA5O,OAAQA,EACRsC,KAAM4K,EAAS5K,KACfC,QAAS2K,EAAS3K,QAClBO,KAAM8M,EACN9C,OAAQS,EACR6B,YAAAA,EACAD,cAAAA,EAEJ,iFC9agErQ,IAA4B,IAAAuU,EAAAC,EAAAC,EACpF1T,GAASwT,GAAAC,EAAGxU,EAAOgI,SAAKwM,MAAAA,kBAAZA,EAAczT,aAASwT,MAAAA,WAAAA,EAAIvT,SAAWA,aAAC,EAAI,CAAAT,KAAA,YAAAC,IAAA,YACvDkU,EAAUlH,SAAAA,QAAO,CAAA7M,IAAA,CAACX,EAAO8B,QAAMhB,GAAA,CAAAP,KAAA,UAAAC,IAAA,aAC/B6M,GAAKoH,EAAIzU,EAAOqN,SAAK,MAAAoH,SAAA,EAAAA,EAAIC,EACzBC,EAAoB,YAAa3U,SAE5BA,EAAO4U,SAAY,UACxBpJ,EAAkBxL,EAAO4U,QAAU,MAAQ,QAAO3F,EAAAA,KAC7CzD,EAAiB,SAAaxL,EAAO4U,SAH5CpJ,EAAiB,QAKfqJ,EAA0BzH,SAAAA,OAAM,CAAAzM,IAAC,CAAA,CACrC0M,MAAOrN,EAAOoO,SAASlN,OACvB0B,OAAQ7B,IACTD,GAAA,CAAAP,KAAA,0BAAAC,IAAA,YAED4M,gBAAM,CAAAzM,IAAC,CAAA,CACL0M,MAAAA,EACAvL,OAAQ0L,SAAAA,QAAO,CAAA7M,IAAA,CAAC,CAAC+T,EAAS1U,EAAOoO,SAASlN,SAAOJ,GAAA,CAAAP,KAAA,SAAAC,IAAA,aACjDoC,OAAQ7B,EACRoL,GAAIhM,IAA4B,IAA1B2B,EAAM3B,EAAA,GAAE2U,EAAY3U,EAAA,GACpB4U,EAAwB,CAAA,EAC5B,GAAIJ,EAAgBjJ,WAClB,IAAA,IAA0CkD,EAA1CM,EAAAC,EAAkBwF,EAAgB/I,YAAQgD,EAAAM,KAAAE,MAAE,CAAA,IAAjClK,EAAG0J,EAAAzK,MACRe,KAAO4P,IACTC,EAAU7P,GAAO4P,EAAa5P,GAElC,MAEA6P,EAAS9F,EAAQ6F,GAAAA,GAEnB,IAAK,IAAM5P,KAAOpD,EAChBiT,EAAU7P,GAAOpD,EAAOoD,GAE1B,GAAIyP,EAAgBhJ,MAClB,IAAK,IAAMzG,KAAOpD,EACX6S,EAAgB/I,SAAS0G,SAASpN,IAAS6P,EAAU7P,WACjD6P,EAAU7P,GAIvB,OAAO6P,CACR,EACDpH,OAAQ3N,EAAOoO,SAASlN,SACzBJ,GAAA,CAAAN,IAAA,YAAE,IAAAsO,EAAA3L,IAGD,IAAM6R,EAAchV,EAAO8B,OAAOqB,GAElC6R,EAAYzT,GAAGsT,GAAyB,CAACrT,EAAGlB,KAAU,IAAA2U,EACpD,OAAAA,EAAO3U,EAAM6C,MAAE8R,MAAAA,SAAAA,EAAAA,EAAID,EAAYE,YACjC,KALF,IAAK,IAAM/R,KAAKnD,EAAO8B,OAAMgN,EAAA3L,EAO/B,aHxCwDS,IACtD,IAAMyJ,EAAkBzJ,EAAQyJ,MAC5BD,gBAAM,CAAAzM,IAAC,CAAA,CAAE0M,MAAOzJ,EAAQyJ,QAAmBvM,GAAA,CAAAP,KAAA,QAAAC,IAAA,aAC3CY,SAAAA,YAAW,CAAAb,KAAA,QAAAC,IAAA,YAETR,EAASsK,EAAQ1G,EAAQ5D,QAAU,CAAE,GACrCM,EAAQgK,EAAQ1G,EAAQtD,OAAS,CAAE,GACnCD,EAAUiK,EAAQ1G,EAAQvD,UAAW,GAa3C,OAXA+M,gBAAM,CAAAzM,IAAC,CAAA,CACL0M,MAAOA,EACPvL,OAAQ,CAAE9B,OAAAA,EAAQM,MAAAA,EAAOD,QAAAA,GACzB8L,GAAI,CAAAhM,EAA6BkN,KAAK,IAA/BrN,EAAMG,EAANH,OAAQM,EAAKH,EAALG,MAAOD,EAAOF,EAAPE,QAAO,MAAe,CAC1CL,cAAeA,GAAW,WAAaA,EAAOqN,GAASrN,EACvDM,aAAcA,GAAU,WAAaA,EAAM+M,GAAS/M,EACpDD,eAAgBA,GAAY,WAAaA,EAAQgN,GAAShN,EAC1D,EACFsN,OAAQ/J,EAAQoE,MAAM5F,WACvBtB,GAAA,CAAAN,IAAA,YAEM6M,CACT","x_google_ignoreList":[3]}