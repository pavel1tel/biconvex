{"version":3,"file":"atomic-router.mjs","sources":["../src/methods/create-route.ts","../src/lib/equals.ts","../src/methods/create-router-controls.ts","../src/lib/build-path.ts","../src/methods/is-route.ts","../src/lib/history-effects.ts","../src/lib/logic.ts","../src/methods/create-history-router.ts","../src/lib/remap-route-objects.ts","../src/methods/redirect.ts","../src/methods/chain-route.ts","../src/methods/query-sync.ts","../src/types.ts"],"sourcesContent":["import { attach, createEffect, createEvent, createStore, split, Store } from \"effector\";\nimport {\n  RouteParams,\n  RouteParamsAndQuery,\n  RouteQuery,\n  RouteInstance,\n  NavigateParams,\n  Kind,\n  EmptyObject,\n} from \"../types\";\n\ntype CreateRouteParams = {\n  filter?: Store<boolean>;\n};\n\nexport function createRoute<Params extends RouteParams = {}>(\n  params: CreateRouteParams = {},\n): RouteInstance<Params> {\n  const navigateFx = createEffect<NavigateParams<Params>, NavigateParams<Params>>(\n    ({ params, query, replace = false }) => ({\n      params: params || {},\n      query: query || {},\n      replace,\n    }),\n  );\n\n  const openFx = attach({\n    effect: navigateFx,\n    mapParams: (params: Params extends EmptyObject ? void : Params) => ({\n      params: (params || {}) as Params,\n      query: {} as RouteQuery,\n    }),\n  });\n\n  const $isOpened = createStore<boolean>(false);\n  const $params = createStore<Params>({} as Params);\n  const $query = createStore<RouteQuery>({});\n\n  const opened = createEvent<RouteParamsAndQuery<Params>>();\n  const updated = createEvent<RouteParamsAndQuery<Params>>();\n  const closed = createEvent<void>();\n\n  $isOpened.on(opened, () => true).on(closed, () => false);\n\n  $params.on(opened, (_, { params }) => params).on(updated, (_, { params }) => params);\n\n  $query.on(opened, (_, { query }) => query).on(updated, (_, { query }) => query);\n\n  split({\n    source: navigateFx.doneData,\n    match: $isOpened.map((isOpened) => (isOpened ? \"updated\" : \"opened\")),\n    cases: {\n      opened,\n      updated,\n    },\n  });\n\n  // if (params.filter) {\n  //   const filter = params.filter;\n  //   split({\n  //     // @ts-expect-error\n  //     source: sample({ clock: filter }),\n  //     // @ts-expect-error\n  //     match: (filter) => (filter ? 'true' : 'false'),\n  //     cases: {\n  //       true: opened,\n  //       false: closed,\n  //     },\n  //   });\n  // }\n\n  const instance: RouteInstance<Params> = {\n    $isOpened,\n    $params,\n    $query,\n    opened,\n    updated,\n    closed,\n    navigate: navigateFx,\n    open: openFx,\n    kind: Kind.ROUTE,\n    // @ts-expect-error Internal stuff\n    settings: {\n      derived: Boolean(params.filter),\n    },\n  };\n\n  return instance;\n}\n","export function paramsEqual(a: Record<string, any>, b: Record<string, any>) {\n  if (Object.keys(a).length !== Object.keys(b).length) {\n    return false;\n  }\n  for (const k in a) {\n    // NOTE: Parsed URI always returns string parameters\n    // so we force string comparison here\n    // in order to avoid extra updates\n    // whenever user passes numeric params\n    if (`${a[k]}` !== `${b[k]}`) {\n      return false;\n    }\n  }\n  return true;\n}\n","import { createEvent, createStore, type EventCallable, type StoreWritable } from \"effector\";\n\nimport type { RouteQuery } from \"../types\";\nimport { paramsEqual } from \"../lib/equals\";\n\ninterface RouterControls {\n  $query: StoreWritable<RouteQuery>;\n  back: EventCallable<void>;\n  forward: EventCallable<void>;\n}\n\nexport function createRouterControls(): RouterControls {\n  return {\n    $query: createStore({}, { updateFilter: (update, current) => !paramsEqual(current, update) }),\n    back: createEvent(),\n    forward: createEvent(),\n  };\n}\n","import { match, compile } from \"path-to-regexp\";\n\nimport type { RouteParams, PathCreator, RouteQuery, ParamsSerializer } from \"../types\";\n\n// NOTE: If path is URL - provide it as is\n// Otherwise - extract pathname and hash\nconst getComparablePath = (path: string) => {\n  if (path.match(/^[a-z0-9]+\\:\\/\\//i)) {\n    return path;\n  }\n  const url = new URL(`http://_${path}`);\n  return [url.pathname, url.hash].join(\"\");\n};\n\n// NOTE: path-to-regexp treats \":\" in \"https://\" as param start\n// So we escape it\nfunction normalizePathCreator(pathCreator: string) {\n  return pathCreator.replace(\"://\", \"\\\\://\");\n}\n\ntype BuildPathParams<Params extends RouteParams> = {\n  pathCreator: PathCreator<Params>;\n  params: Params;\n  query: RouteQuery;\n  serialize?: ParamsSerializer;\n};\nexport function buildPath<Params extends RouteParams>({\n  pathCreator,\n  params,\n  query,\n  serialize,\n}: BuildPathParams<Params>) {\n  const pathname = compile(pathCreator)(params);\n  const serializedParams = serialize?.write(query) ?? new URLSearchParams(query);\n  const qs = Object.keys(query).length ? `?${serializedParams}` : \"\";\n  const url = `${pathname}${qs}`;\n  return url;\n}\n\ntype MatchPathParams<Params extends RouteParams> = {\n  pathCreator: PathCreator<Params>;\n  actualPath: string;\n};\nexport function matchPath<Params extends RouteParams>({\n  pathCreator,\n  actualPath,\n}: MatchPathParams<Params>) {\n  const matches = match(normalizePathCreator(pathCreator))(getComparablePath(actualPath));\n  if (matches) {\n    return { matches: true, params: matches.params } as const;\n  }\n  return { matches: false } as const;\n}\n","import { Kind, RouteInstance, RouteInstanceInternal } from \"../types\";\n\n/** Detects whether passed value is a `RouteInstance<any>` or not */\nexport function isRoute(route: RouteInstance<any> | unknown): route is RouteInstance<any> {\n  return (\n    typeof route === \"object\" && route !== null && \"kind\" in route && route.kind === Kind.ROUTE\n  );\n}\n\nexport function isRouteInternal(\n  route: RouteInstanceInternal<any> | unknown,\n): route is RouteInstanceInternal<any> {\n  return isRoute(route);\n}\n","import { History } from \"history\";\nimport { createEffect } from \"effector\";\n\nimport { HistoryBackForwardParams, HistoryPushParams } from \"../types\";\n\nfunction assertHistory(history: History) {\n  if (!history) {\n    throw new Error(\"[Atomic-Router] No history provided\");\n  }\n}\n\nexport const historyPushFx = createEffect((params: HistoryPushParams) => {\n  assertHistory(params.history);\n  params.history[params.method](params.path, {});\n  return params;\n});\n\nexport const historyBackFx = createEffect((history: HistoryBackForwardParams) => {\n  assertHistory(history);\n  history.back();\n  return history;\n});\n\nexport const historyForwardFx = createEffect((history: HistoryBackForwardParams) => {\n  assertHistory(history);\n  history.forward();\n  return history;\n});\n","import { Store } from \"effector\";\n\nexport function not<T>(source: Store<T>): Store<boolean> {\n  return source.map((value) => !value);\n}\n","import { History } from \"history\";\nimport { attach, combine, createEvent, createStore, sample, scopeBind } from \"effector\";\nimport { createRouterControls } from \"./create-router-controls\";\nimport {\n  HistoryPushParams,\n  ParamsSerializer,\n  RouteInstance,\n  RouteObject,\n  RouteParams,\n  RouteQuery,\n  UnmappedRouteObject,\n} from \"../types\";\nimport { remapRouteObjects } from \"../lib/remap-route-objects\";\nimport { paramsEqual } from \"../lib/equals\";\nimport { buildPath, matchPath } from \"../lib/build-path\";\nimport { isRouteInternal } from \"./is-route\";\nimport { historyBackFx, historyForwardFx, historyPushFx } from \"../lib/history-effects\";\nimport { not } from \"../lib/logic\";\n\nexport function createHistoryRouter({\n  base,\n  routes,\n  notFoundRoute,\n  hydrate,\n  serialize,\n  controls = createRouterControls(),\n}: {\n  base?: string;\n  routes: UnmappedRouteObject<any>[];\n  notFoundRoute?: RouteInstance<any>;\n  serialize?: ParamsSerializer;\n  hydrate?: boolean;\n  controls?: ReturnType<typeof createRouterControls>;\n}) {\n  const $hydrateMode = createStore(hydrate ?? false, {\n    /**\n     * It is explicitly set in the config and not as a Store,\n     * so value from config should be used at all times - we don't want to serialize this value\n     */\n    serialize: \"ignore\",\n  });\n  const remappedRoutes = remapRouteObjects(routes, base);\n\n  const setHistory = createEvent<History>();\n  const navigateFromRouteTriggered = createEvent<{\n    route: RouteObject<any>;\n    params: RouteParams;\n    query: RouteQuery;\n    replace: boolean;\n  }>();\n  const historyUpdated = createEvent();\n  const recalculateTriggered = createEvent<{\n    path: string;\n    query: RouteQuery;\n    hash: string;\n  }>();\n  const recalculated = createEvent<{\n    path: string;\n    query: RouteQuery;\n    matching: RecalculationResult<any>[];\n    mismatching: RecalculationResult<any>[];\n  }>();\n  const routesMatched = createEvent<RecalculationResult<any>[]>();\n  const routesMismatched = createEvent<RecalculationResult<any>[]>();\n  const routeNotFound = createEvent();\n  const initialized = createEvent<{\n    activeRoutes: RouteInstance<any>[];\n    path: string;\n    query: RouteQuery;\n  }>();\n\n  const $path = createStore(\"\");\n  const $query = createStore<RouteQuery>(\n    {},\n    {\n      name: \"historyRouter.$query\",\n      updateFilter: (newQuery, oldQuery) => !paramsEqual(newQuery, oldQuery),\n    },\n  );\n  const $activeRoutes = createStore<RouteInstance<any>[]>([], {\n    serialize: \"ignore\",\n  });\n  // @ts-expect-error\n  const $history = createStore<History>(null, {\n    serialize: \"ignore\",\n  });\n  const $isFirstCheckPassed = createStore(false);\n  const $isRouteNavigateInProgress = createStore(false);\n\n  const pushFx = attach({\n    source: $history,\n    effect(history, params: Omit<HistoryPushParams, \"history\">) {\n      return historyPushFx({\n        history,\n        ...params,\n      });\n    },\n  });\n\n  const subscribeHistoryFx = attach({\n    source: $history,\n    effect(history) {\n      let scopedHistoryUpdated = historyUpdated;\n      try {\n        // @ts-expect-error\n        scopedHistoryUpdated = scopeBind(historyUpdated);\n      } catch (err) {}\n      history.listen(() => {\n        scopedHistoryUpdated();\n      });\n      return true;\n    },\n  });\n\n  const historyUpdatedParsed = sample({\n    clock: hydrate ? [historyUpdated] : [historyUpdated, subscribeHistoryFx.done],\n    source: $history,\n    filter: Boolean,\n    fn: (history) => ({\n      path: history.location.pathname,\n      query:\n        serialize?.read(history.location.search) ??\n        Object.fromEntries(new URLSearchParams(history.location.search)),\n    }),\n  });\n\n  // If `hydrate` flag is set,\n  // don't trigger recheck on history init\n  const historyUpdateTriggered = sample({\n    clock: historyUpdatedParsed,\n    source: {\n      path: $path,\n      query: $query,\n    },\n    filter: ({ path: savedPath, query: savedQuery }, history) =>\n      history.path !== savedPath || !paramsEqual(history.query, savedQuery),\n    fn: (_, history) => history,\n  });\n\n  /// History subscription\n  $history.on(setHistory, (_, history) => history);\n\n  sample({\n    clock: $history,\n    target: subscribeHistoryFx,\n  });\n\n  sample({\n    clock: historyUpdateTriggered,\n    source: $history,\n    filter: Boolean,\n    fn(history) {\n      const path = history?.location.pathname;\n      const hash = history?.location.hash;\n      const query: RouteQuery =\n        serialize?.read(history?.location.search) ??\n        Object.fromEntries(new URLSearchParams(history?.location.search));\n      return { path, query, hash };\n    },\n    target: recalculateTriggered,\n  });\n\n  /// Routes updates handling\n  for (const routeObj of remappedRoutes) {\n    const currentRouteMatched = routesMatched.filterMap(containsCurrentRoute(routeObj));\n    const currentRouteMismatched = routesMismatched.filterMap(containsCurrentRoute(routeObj));\n    const routeStateChangeRequested = {\n      /**\n       * Special case:\n       * - Scope is initied from server data, route.$isOpened -> true\n       * - but `hydrate` flag is set to false\n       *\n       * So route.opened() should be called after router.setHistory anyway to respect that\n       */\n      initialized: sample({\n        clock: subscribeHistoryFx.done,\n        filter: combine(\n          routeObj.route.$isOpened,\n          $hydrateMode,\n          (isOpened, hydrateMode) => isOpened && !hydrateMode,\n        ),\n      }),\n      opened: sample({\n        clock: currentRouteMatched,\n        filter: not(routeObj.route.$isOpened),\n      }),\n      updated: sample({\n        clock: currentRouteMatched,\n        filter: routeObj.route.$isOpened,\n      }),\n      closed: sample({\n        clock: currentRouteMismatched,\n        filter: routeObj.route.$isOpened,\n      }),\n    };\n\n    /**\n     * Trigger .opened() for special case with scope being initialized from server data\n     */\n    sample({\n      clock: routeStateChangeRequested.initialized,\n      source: {\n        params: routeObj.route.$params,\n        query: routeObj.route.$query,\n      },\n      target: routeObj.route.opened,\n    });\n\n    // Trigger .updated() for the routes marked as \"matched\" but already opened\n    sample({\n      clock: routeStateChangeRequested.updated,\n      source: [routeObj.route.$params, routeObj.route.$query],\n      // Skip .updated() calls if params & query are the same\n      filter: ([params, query], next) =>\n        !paramsEqual(params, next.params) || !paramsEqual(query, next.query),\n      fn: (_, paramsAndQuery) => paramsAndQuery,\n      target: routeObj.route.updated,\n    });\n\n    // Trigger .opened() for the routes marked as \"matched\" but not opened yet\n    sample({\n      clock: routeStateChangeRequested.opened,\n      // TODO: Scratch this?\n      filter: not($isRouteNavigateInProgress),\n      target: routeObj.route.opened,\n    });\n\n    // Trigger .closed() for the routes marked as \"mismatched\" but opened\n    sample({\n      clock: routeStateChangeRequested.closed,\n      target: routeObj.route.closed,\n    });\n  }\n\n  /// Handling route.navigateFx navigation\n  for (const routeObj of remappedRoutes) {\n    // Run \"Handling route.navigateFx navigation\" step\n    sample({\n      clock: routeObj.route.navigate.doneData,\n      fn: ({ params, query, replace }) => ({\n        route: routeObj,\n        params,\n        query,\n        replace: replace ?? false,\n      }),\n      target: navigateFromRouteTriggered,\n    });\n  }\n\n  $isRouteNavigateInProgress.on(navigateFromRouteTriggered, () => true);\n\n  sample({\n    clock: navigateFromRouteTriggered,\n    fn({ route, params, query, replace }) {\n      const path = buildPath({\n        pathCreator: route.path,\n        params,\n        query,\n        serialize,\n      });\n      const method: \"replace\" | \"push\" = replace ? \"replace\" : \"push\";\n      return {\n        path,\n        params,\n        query,\n        method,\n      };\n    },\n    target: pushFx,\n  });\n\n  $isRouteNavigateInProgress.reset([routesMatched, routesMismatched]);\n\n  /// Recalculation\n  // Triggered on every history change + once when history instance is set\n  sample({\n    clock: recalculateTriggered,\n    fn({ path, query, hash }) {\n      const matchingRoutes = [] as RecalculationResult<any>[];\n      const mismatchingRoutes = [] as RecalculationResult<any>[];\n\n      for (const route of remappedRoutes) {\n        // NOTE: Use hash string as well if route.path contains #\n        const actualPath = route.path.includes(\"#\") ? `${path}${hash}` : `${path}`;\n        const { matches, params } = matchPath({\n          pathCreator: route.path,\n          actualPath,\n        });\n\n        const suitableRoutes = matches ? matchingRoutes : mismatchingRoutes;\n        suitableRoutes.push({\n          routeObj: route,\n          params,\n          query,\n        });\n      }\n\n      // Checking for routes we need to close\n      // Remove all that are marked to be opened\n      mismatchingRoutes.forEach((mismatchedRoute, mismatchedIndex) => {\n        const mismatchedRouteExistsInMatchedList = matchingRoutes.some(\n          (matchedRoute) => matchedRoute.routeObj.route === mismatchedRoute.routeObj.route,\n        );\n        if (mismatchedRouteExistsInMatchedList) {\n          mismatchingRoutes.splice(mismatchedIndex, 1);\n        }\n      });\n\n      return {\n        matching: matchingRoutes,\n        mismatching: mismatchingRoutes.filter(Boolean),\n        path,\n        query,\n      };\n    },\n    target: recalculated,\n  });\n\n  $path.on(historyUpdateTriggered, (_, { path }) => path);\n\n  $query.on(historyUpdateTriggered, (_, { query }) => query);\n\n  const matchingRecalculated = recalculated.map(({ matching }) => matching);\n\n  sample({\n    clock: matchingRecalculated,\n    filter: (routes) => routes.length > 0,\n    target: routesMatched,\n  });\n\n  sample({\n    clock: recalculated.map(({ mismatching }) => mismatching),\n    filter: (routes) => routes.length > 0,\n    target: routesMismatched,\n  });\n\n  $activeRoutes.on(recalculated, (_, { matching }) =>\n    matching.map((recheckResult) => recheckResult.routeObj.route),\n  );\n\n  /// Handling 404\n  sample({\n    clock: matchingRecalculated,\n    filter: (routes) => routes.length === 0,\n    target: routeNotFound,\n  });\n\n  if (isRouteInternal(notFoundRoute)) {\n    sample({\n      clock: routeNotFound,\n      source: $query,\n      filter: notFoundRoute.$isOpened,\n      fn: (query) => ({ query, params: {} }),\n      target: notFoundRoute.updated,\n    });\n\n    sample({\n      clock: routeNotFound,\n      source: { query: $query, isOpened: notFoundRoute.$isOpened },\n      filter: ({ isOpened }) => !isOpened,\n      fn: ({ query }) => ({ query, params: {} }),\n      target: notFoundRoute.opened,\n    });\n\n    sample({\n      clock: matchingRecalculated,\n      source: notFoundRoute.$isOpened,\n      filter: (isOpened, matching) => isOpened && matching.length > 0,\n      target: notFoundRoute.closed,\n    });\n  }\n\n  /// Back/forward navigation\n  sample({\n    clock: controls.back,\n    source: $history,\n    target: historyBackFx,\n  });\n\n  sample({\n    clock: controls.forward,\n    source: $history,\n    target: historyForwardFx,\n  });\n\n  /// Query syncing\n  sample({\n    clock: $query,\n    source: { controlsQuery: controls.$query, localQuery: $query },\n    filter: ({ controlsQuery, localQuery }) => !paramsEqual(controlsQuery, localQuery),\n    fn: ({ localQuery }) => localQuery,\n    target: controls.$query,\n  });\n\n  sample({\n    clock: controls.$query,\n    source: {\n      path: $path,\n      localQuery: $query,\n      isNavigateInProgress: $isRouteNavigateInProgress,\n      realHistory: $history,\n    },\n    filter: ({ localQuery, isNavigateInProgress, realHistory }, query) => {\n      const realQuery =\n        serialize?.read(realHistory?.location.search ?? \"\") ??\n        Object.fromEntries(new URLSearchParams(realHistory?.location.search ?? \"\"));\n      return (\n        isNavigateInProgress || !paramsEqual(query, realQuery) || !paramsEqual(localQuery, query)\n      );\n    },\n    fn({ path }, query) {\n      const qs = serialize?.write(query) ?? new URLSearchParams(query);\n      return {\n        path: `${path}${qs ? `?${qs}` : \"\"}`,\n        params: {},\n        query: query,\n        method: \"push\" as const,\n      };\n    },\n    target: pushFx,\n  });\n\n  /// Initialization\n  sample({\n    clock: recalculated,\n    source: {\n      activeRoutes: $activeRoutes,\n      path: $path,\n      query: $query,\n    },\n    filter: $isFirstCheckPassed.map((isFirstCheckPassed) => !isFirstCheckPassed),\n    target: initialized,\n  });\n\n  $isFirstCheckPassed.on(initialized, () => true).reset($history);\n\n  return {\n    $path,\n    $activeRoutes,\n    $history,\n    setHistory,\n    $query: $query,\n    back: controls.back,\n    forward: controls.forward,\n    push: pushFx,\n    routes: remappedRoutes,\n    initialized,\n    routeNotFound,\n  };\n}\n\ntype RecalculationResult<Params extends RouteParams> = {\n  routeObj: RouteObject<Params>;\n  params: Params;\n  query: RouteQuery;\n};\n\nconst containsCurrentRoute =\n  (routeObj: RouteObject<any>) => (recheckResults: RecalculationResult<any>[]) => {\n    const recheck = recheckResults.find(\n      (recheckResult) => recheckResult.routeObj.route === routeObj.route,\n    );\n    if (!recheck) {\n      return;\n    }\n    return {\n      params: recheck.params,\n      query: recheck.query,\n    };\n  };\n","import { UnmappedRouteObject, RouteObject, RouteObjectInternal } from \"../types\";\n\nexport function remapRouteObjects(objects: UnmappedRouteObject<any>[], basePath: string = \"\") {\n  let next: RouteObject<any>[] = [];\n\n  for (const routeObj of objects) {\n    if (Array.isArray(routeObj.route)) {\n      next.push(...routeObj.route.map((route) => ({ ...routeObj, route })));\n    } else {\n      // @ts-expect-error\n      next.push(routeObj);\n    }\n  }\n\n  next = next.map((routeObj) => ({\n    ...routeObj,\n    path: `${basePath}${routeObj.path}`,\n  }));\n\n  const derivedRoutes: RouteObject<any>[] = [];\n  const nonDerivedRoutes: RouteObjectInternal<any>[] = [];\n\n  for (const routeObj of next) {\n    // @ts-expect-error Internals\n    if (routeObj.route.settings.derived) {\n      derivedRoutes.push(routeObj);\n    } else {\n      nonDerivedRoutes.push(routeObj as RouteObjectInternal<any>);\n    }\n  }\n\n  if (derivedRoutes.length) {\n    for (const derivedRoute of derivedRoutes) {\n      console.error(\n        `[Atomic-Router]: createHistoryRouter: ${derivedRoute.path} uses derived route. This won't work`,\n      );\n    }\n  }\n\n  return nonDerivedRoutes;\n}\n","import { Clock, createEvent, createStore, Event, is, sample, Store } from \"effector\";\nimport { EmptyObject, RouteInstance, RouteParams, RouteQuery } from \"../types\";\n\ntype RedirectParams<T, Params extends RouteParams> = Params extends EmptyObject\n  ? {\n      clock?: Clock<T>;\n      route: RouteInstance<Params>;\n      query?: ((clock: T) => RouteQuery) | Store<RouteQuery> | RouteQuery;\n      replace?: ((clock: T) => boolean) | Store<boolean> | boolean;\n    }\n  :\n      | {\n          clock?: Clock<T>;\n          route: RouteInstance<Params>;\n          params: ((clock: T) => Params) | Store<Params> | Params;\n          query?: ((clock: T) => RouteQuery) | Store<RouteQuery> | RouteQuery;\n          replace?: ((clock: T) => boolean) | Store<boolean> | boolean;\n        }\n      | {\n          clock?: Clock<{\n            params: Params;\n            query?: RouteQuery;\n            replace?: boolean;\n          }>;\n          route: RouteInstance<Params>;\n          params?: ((clock: T) => Params) | Store<Params> | Params;\n          query?: ((clock: T) => RouteQuery) | Store<RouteQuery> | RouteQuery;\n          replace?: ((clock: T) => boolean) | Store<boolean> | boolean;\n        };\n\n/** Opens passed `route` upon `clock` trigger */\nexport function redirect<T, Params extends RouteParams>(options: RedirectParams<T, Params>) {\n  const clock: Event<T> = options.clock\n    ? sample({ clock: options.clock as Event<T> })\n    : createEvent<T>();\n\n  const params = toStore(options.params || {});\n  const query = toStore(options.query || {});\n  const replace = toStore(options.replace || false);\n\n  sample({\n    clock: clock,\n    source: { params, query, replace },\n    fn: ({ params, query, replace }, clock) => ({\n      params: typeof params === \"function\" ? params(clock) : params,\n      query: typeof query === \"function\" ? query(clock) : query,\n      replace: typeof replace === \"function\" ? replace(clock) : replace,\n    }),\n    target: options.route.navigate,\n  });\n\n  return clock;\n}\n\nfunction toStore<T>(payload: T | Store<T>): Store<T> {\n  return is.store(payload) ? payload : createStore(payload as T);\n}\n","import {\n  is,\n  merge,\n  sample,\n  combine,\n  createStore,\n  Unit,\n  Clock,\n  Effect,\n  StoreValue,\n  createEvent,\n  NoInfer,\n  EffectParams,\n  attach,\n  UnitTargetable,\n} from \"effector\";\n\nimport { createRoute } from \"./create-route\";\nimport {\n  RouteInstance,\n  RouteInstanceInternal,\n  RouteParams,\n  RouteParamsAndQuery,\n  RouteQuery,\n} from \"../types\";\n\nimport { isRouteInternal } from \"./is-route\";\n\ntype ChainRouteParamsInternalAttach<\n  Params extends RouteParams,\n  FX extends Effect<any, any, any>,\n> = {\n  route: RouteInstance<Params>;\n  chainedRoute?: RouteInstance<Params>;\n  beforeOpen: {\n    effect: FX;\n    mapParams: ({\n      params,\n      query,\n    }: {\n      params: Params;\n      query: RouteQuery;\n    }) => NoInfer<EffectParams<FX>>;\n  };\n  openOn?: Clock<any>;\n  cancelOn?: Clock<any>;\n};\n\ntype ChainRouteParamsWithEffect<Params extends RouteParams> = {\n  route: RouteInstance<Params>;\n  chainedRoute?: RouteInstance<Params>;\n  beforeOpen: Effect<RouteParamsAndQuery<Params>, any, any>;\n};\n\ntype ChainRouteParamsAdvanced<Params extends RouteParams> = {\n  route: RouteInstance<Params>;\n  chainedRoute?: RouteInstance<Params>;\n  beforeOpen: Clock<RouteParamsAndQuery<Params>>;\n  openOn: Clock<any>;\n  cancelOn?: Clock<any>;\n};\n\ntype ChainRouteParams<Params extends RouteParams, FX extends Effect<any, any, any>> =\n  | RouteInstance<Params>\n  | ChainRouteParamsWithEffect<Params>\n  | ChainRouteParamsAdvanced<Params>\n  | ChainRouteParamsInternalAttach<Params, FX>;\n\nfunction chainRoute<Params extends RouteParams>(\n  instance: RouteInstance<Params>,\n): RouteInstance<Params>;\n\nfunction chainRoute<Params extends RouteParams>(\n  config: ChainRouteParamsWithEffect<Params>,\n): RouteInstance<Params>;\n\nfunction chainRoute<Params extends RouteParams>(\n  config: ChainRouteParamsAdvanced<Params>,\n): RouteInstance<Params>;\n\nfunction chainRoute<Params extends RouteParams, FX extends Effect<any, any, any>>(\n  config: ChainRouteParamsInternalAttach<Params, FX>,\n): RouteInstance<Params>;\n\n/**\n * Creates chained route\n * @link https://github.com/Kelin2025/atomic-router/issues/10\n * @param {RouteInstance<any>} params.route - Route to listen\n * @param {RouteInstance<any>} [params.chainedRoute]  - Route to be created\n * @param {Clock<any>} params.beforeOpen - Will be triggered when `params.route` open\n * @param {Clock<any>} params.openOn - Will open `chainedRoute` if `params.route` is still opened\n * @param {Clock<any>} params.cancelOn - Cancels chain\n * @returns {RouteInstance<any>} `chainedRoute`\n */\nfunction chainRoute<Params extends RouteParams, FX extends Effect<any, any, any>>(\n  params: ChainRouteParams<Params, FX>,\n) {\n  const { route, chainedRoute, beforeOpen, openOn, cancelOn } = normalizeChainRouteParams(params);\n  const $params = createStore({} as StoreValue<(typeof route)[\"$params\"]>);\n  const $query = createStore({} as StoreValue<(typeof route)[\"$query\"]>);\n  const $hasSameParams = combine(\n    combine([route.$params, route.$query]),\n    combine([$params, $query]),\n    (current, stored) => {\n      return current[0] === stored[0] && current[1] === stored[1];\n    },\n  );\n  const routeTriggered = sample({ clock: [route.opened, route.updated] });\n\n  // 1. Call `beforeOpen` whenever route is opened\n  sample({\n    clock: routeTriggered,\n    target: beforeOpen as UnitTargetable<RouteParamsAndQuery<any>>,\n  });\n\n  $params.on(routeTriggered, (_prev, { params }) => params);\n  $query.on(routeTriggered, (_prev, { query }) => query);\n\n  // 2. Listen to `openOn` if route is still opened on the same position\n  sample({\n    clock: openOn as Unit<any>,\n    source: { params: $params, query: $query },\n    filter: $hasSameParams,\n    target: chainedRoute.navigate,\n  });\n\n  // 4. Cancel loading if page closed or `cancelOn` is called\n  // @ts-expect-error\n  const aborted = merge([route.closed, cancelOn]);\n\n  $params.reset(aborted);\n  $query.reset(aborted);\n\n  sample({\n    clock: aborted,\n    target: chainedRoute.closed,\n  });\n\n  return chainedRoute;\n}\n\n// This is written separately to correctly export all type overloads\nexport { chainRoute };\n\ntype ChainRouteParamsNormalized<Params extends RouteParams> = {\n  route: RouteInstanceInternal<Params>;\n  chainedRoute: RouteInstanceInternal<Params>;\n  beforeOpen: Clock<RouteParamsAndQuery<Params>>;\n  openOn: Clock<any>;\n  cancelOn: Clock<any>;\n};\n\nfunction normalizeChainRouteParams<Params extends RouteParams, FX extends Effect<any, any, any>>(\n  params: ChainRouteParams<Params, FX>,\n): ChainRouteParamsNormalized<Params> {\n  const resultParams: ChainRouteParamsNormalized<Params> = {} as ChainRouteParamsNormalized<Params>;\n\n  if (isRouteInternal(params)) {\n    Object.assign(resultParams, {\n      route: params,\n      chainedRoute: createRoute<Params>(),\n      beforeOpen: createEvent(),\n      openOn: merge([params.opened, params.closed]),\n      cancelOn: merge([]),\n    });\n    return resultParams;\n  }\n  const effectParams = params as ChainRouteParamsWithEffect<Params>;\n  Object.assign(resultParams, {\n    route: effectParams.route,\n    chainedRoute: effectParams.chainedRoute || createRoute<Params>(),\n    beforeOpen: is.unit(effectParams.beforeOpen)\n      ? effectParams.beforeOpen\n      : attach(effectParams.beforeOpen),\n  });\n  if (is.effect(resultParams.beforeOpen as Unit<any>)) {\n    Object.assign(resultParams, {\n      openOn:\n        // @ts-expect-error\n        effectParams.openOn || resultParams.beforeOpen.doneData,\n      cancelOn:\n        // @ts-expect-error\n        effectParams.cancelOn || resultParams.beforeOpen.failData,\n    });\n    return resultParams;\n  }\n  const advancedParams = params as ChainRouteParamsAdvanced<Params>;\n  Object.assign(resultParams, {\n    openOn: sample({ clock: advancedParams.openOn as Unit<any> }),\n    cancelOn: sample({\n      clock: (advancedParams.cancelOn as Unit<any>) || createEvent(),\n    }),\n  });\n  return resultParams;\n}\n","import { Clock, combine, createStore, sample, Store, Unit } from \"effector\";\n\nimport { RouteInstance, RouteQuery } from \"../types\";\nimport { createRouterControls } from \"./create-router-controls\";\n\ntype QueryCleanupStrategy = {\n  irrelevant: boolean;\n  empty: boolean;\n  preserve: string[];\n};\n\ntype QuerySyncParams<T extends Record<string, Store<any>>> = {\n  source: T;\n  clock?: Clock<any>;\n  controls: ReturnType<typeof createRouterControls>;\n  route?: RouteInstance<any>;\n  cleanup?: boolean | Partial<QueryCleanupStrategy>;\n};\n\nexport function querySync<T extends Record<string, Store<any>>>(params: QuerySyncParams<T>) {\n  const $isOpened = params.route?.$isOpened ?? createStore(true);\n  const $source = combine(params.source);\n  const clock = (params.clock ?? $source) as Unit<any>;\n  const cleanupStrategy = !(\"cleanup\" in params)\n    ? cleanupStrategies.default\n    : typeof params.cleanup === \"boolean\"\n      ? cleanupStrategies[params.cleanup ? \"all\" : \"none\"]\n      : { ...cleanupStrategies.default, ...params.cleanup! };\n\n  const queryUpdatedFromHistory = sample({\n    clock: params.controls.$query,\n    filter: $isOpened,\n  });\n\n  sample({\n    clock,\n    source: combine([$source, params.controls.$query]),\n    filter: $isOpened,\n    fn: ([source, currentQuery]) => {\n      let nextQuery: RouteQuery = {};\n      if (cleanupStrategy.irrelevant) {\n        for (const key of cleanupStrategy.preserve) {\n          if (key in currentQuery) {\n            nextQuery[key] = currentQuery[key];\n          }\n        }\n      } else {\n        nextQuery = { ...currentQuery };\n      }\n      for (const key in source) {\n        nextQuery[key] = source[key];\n      }\n      if (cleanupStrategy.empty) {\n        for (const key in source) {\n          if (!cleanupStrategy.preserve.includes(key) && !nextQuery[key]) {\n            delete nextQuery[key];\n          }\n        }\n      }\n      return nextQuery as RouteQuery;\n    },\n    target: params.controls.$query,\n  });\n\n  for (const k in params.source) {\n    const $queryParam = params.source[k as keyof typeof params.source];\n    // @ts-expect-error\n    $queryParam.on(queryUpdatedFromHistory, (_, query) => {\n      return query[k] ?? $queryParam.defaultState;\n    });\n  }\n}\n\nconst cleanupStrategies = {\n  all: {\n    irrelevant: true,\n    empty: true,\n    preserve: [],\n  },\n  default: {\n    irrelevant: false,\n    empty: true,\n    preserve: [],\n  },\n  none: {\n    irrelevant: false,\n    empty: false,\n    preserve: [],\n  },\n};\n","import { History } from \"history\";\nimport { Effect, Store, Event, EventCallable } from \"effector\";\n\nexport type RouteParams = Record<string, any>;\n\nexport type RouteQuery = Record<string, any>;\n\nexport type RouteParamsAndQuery<Params extends RouteParams> = {\n  params: Params;\n  query: RouteQuery;\n};\n\nexport interface NavigateParams<Params extends RouteParams> extends RouteParamsAndQuery<Params> {\n  replace?: boolean;\n}\n\nexport type RouteInstance<Params extends RouteParams> = {\n  $isOpened: Store<boolean>;\n  $params: Store<Params>;\n  $query: Store<RouteQuery>;\n  opened: Event<RouteParamsAndQuery<Params>>;\n  updated: Event<RouteParamsAndQuery<Params>>;\n  closed: Event<void>;\n  navigate: Effect<NavigateParams<Params>, NavigateParams<Params>>;\n  open: Effect<Params extends EmptyObject ? void : Params, RouteParamsAndQuery<Params>>;\n  kind: typeof Kind.ROUTE;\n};\n\nexport interface RouteInstanceInternal<Params extends RouteParams> extends RouteInstance<Params> {\n  opened: EventCallable<RouteParamsAndQuery<Params>>;\n  updated: EventCallable<RouteParamsAndQuery<Params>>;\n  closed: EventCallable<void>;\n}\n\nexport type RouteObject<Params extends RouteParams> = {\n  route: RouteInstance<Params>;\n  path: string;\n};\n\nexport interface RouteObjectInternal<Params extends RouteParams> extends RouteObject<Params> {\n  route: RouteInstanceInternal<Params>;\n}\n\nexport type UnmappedRouteObject<Params extends RouteParams> = {\n  route: RouteInstance<Params> | RouteInstance<Params>[];\n  path: string;\n};\n\nexport type HistoryPushParams = {\n  history: History;\n  path: string;\n  params: RouteParams;\n  query: RouteQuery;\n  method: \"replace\" | \"push\";\n};\n\nexport type HistoryBackForwardParams = History;\n\nexport type ParamsSerializer = {\n  write: (params: RouteParams) => string;\n  read: (query: string) => RouteParams;\n};\n\n// @ts-expect-error 'Params' is declared but its value is never read. ts(6133)\nexport type PathCreator<Params extends RouteParams> = string;\n\nexport const Kind = {\n  ROUTE: Symbol(),\n};\n\nexport type EmptyObject = { [key in string]: never };\n"],"names":["createRoute","params","navigateFx","createEffect","_ref","_ref$replace","replace","query","name","sid","openFx","attach","and","effect","mapParams","or","$isOpened","createStore","$params","$query","opened","createEvent","updated","closed","on","_","_ref2","_ref3","_ref4","_ref5","split","source","doneData","match","map","isOpened","cases","navigate","open","kind","Kind","ROUTE","settings","derived","Boolean","filter","paramsEqual","a","b","Object","keys","length","k","createRouterControls","updateFilter","update","current","back","forward","buildPath","_serialize$write","serialize","pathname","compile","pathCreator","serializedParams","write","URLSearchParams","matchPath","actualPath","matches","getComparablePath","isRoute","route","isRouteInternal","assertHistory","history","Error","not","value","createHistoryRouter","base","routes","notFoundRoute","hydrate","_ref$controls","controls","_withFactory","\"-eby7\"","fn","\"controls\"","method","\"createRouterControls\"","$hydrateMode","remappedRoutes","objects","basePath","_step","next","_loop","_next","routeObj","Array","isArray","push","apply","_objectSpread","_iterator","_createForOfIteratorHelperLoose","done","path","_step2","derivedRoutes","nonDerivedRoutes","_iterator2","_step3","_iterator3","console","error","remapRouteObjects","setHistory","navigateFromRouteTriggered","historyUpdated","recalculateTriggered","recalculated","routesMatched","routesMismatched","routeNotFound","initialized","$path","newQuery","oldQuery","$activeRoutes","$history","$isFirstCheckPassed","$isRouteNavigateInProgress","pushFx","historyPushFx","subscribeHistoryFx","scopedHistoryUpdated","scopeBind","err","listen","historyUpdatedParsed","sample","clock","_serialize$read","location","read","search","fromEntries","historyUpdateTriggered","target","_serialize$read2","hash","currentRouteMatched","filterMap","containsCurrentRoute","currentRouteMismatched","routeStateChangeRequested","combine","hydrateMode","_ref16","paramsAndQuery","_ref17","reset","matchingRoutes","mismatchingRoutes","includes","_matchPath","forEach","mismatchedRoute","mismatchedIndex","some","matchedRoute","splice","matching","mismatching","_ref6","matchingRecalculated","_ref7","_ref8","_ref9","recheckResult","\"-dp1wu2\"","\"none\"","\"isRouteInternal\"","_ref10","_ref11","historyBackFx","historyForwardFx","controlsQuery","localQuery","_ref12","_ref13","isNavigateInProgress","realHistory","_ref14","_serialize$read3","_realHistory$location","_realHistory$location2","realQuery","_ref15","qs","activeRoutes","isFirstCheckPassed","redirect","options","toStore","payload","is","store","chainRoute","_normalizeChainRouteP","resultParams","\"-oimir7\"","assign","chainedRoute","\"nxhp9m\"","\"chainedRoute\"","\"createRoute\"","beforeOpen","openOn","merge","cancelOn","effectParams","\"-wf80u2\"","unit","failData","advancedParams","normalizeChainRouteParams","$hasSameParams","stored","routeTriggered","_prev","aborted","querySync","_params$route$$isOpen","_params$route","_params$clock","$source","cleanupStrategy","cleanup","cleanupStrategies","queryUpdatedFromHistory","currentQuery","nextQuery","irrelevant","preserve","key","empty","$queryParam","_query$k","defaultState","Symbol","url","URL","join","recheckResults","recheck","find","all","default","none"],"mappings":"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"}