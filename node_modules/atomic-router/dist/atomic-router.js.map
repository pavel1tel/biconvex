{"version":3,"file":"atomic-router.js","sources":["../src/methods/create-route.ts","../src/lib/equals.ts","../src/methods/create-router-controls.ts","../src/lib/build-path.ts","../src/methods/is-route.ts","../src/lib/history-effects.ts","../src/lib/logic.ts","../src/methods/redirect.ts","../src/types.ts","../src/methods/create-history-router.ts","../src/methods/query-sync.ts","../src/methods/chain-route.ts","../src/lib/remap-route-objects.ts"],"sourcesContent":["import { attach, createEffect, createEvent, createStore, split, Store } from \"effector\";\nimport {\n  RouteParams,\n  RouteParamsAndQuery,\n  RouteQuery,\n  RouteInstance,\n  NavigateParams,\n  Kind,\n  EmptyObject,\n} from \"../types\";\n\ntype CreateRouteParams = {\n  filter?: Store<boolean>;\n};\n\nexport function createRoute<Params extends RouteParams = {}>(\n  params: CreateRouteParams = {},\n): RouteInstance<Params> {\n  const navigateFx = createEffect<NavigateParams<Params>, NavigateParams<Params>>(\n    ({ params, query, replace = false }) => ({\n      params: params || {},\n      query: query || {},\n      replace,\n    }),\n  );\n\n  const openFx = attach({\n    effect: navigateFx,\n    mapParams: (params: Params extends EmptyObject ? void : Params) => ({\n      params: (params || {}) as Params,\n      query: {} as RouteQuery,\n    }),\n  });\n\n  const $isOpened = createStore<boolean>(false);\n  const $params = createStore<Params>({} as Params);\n  const $query = createStore<RouteQuery>({});\n\n  const opened = createEvent<RouteParamsAndQuery<Params>>();\n  const updated = createEvent<RouteParamsAndQuery<Params>>();\n  const closed = createEvent<void>();\n\n  $isOpened.on(opened, () => true).on(closed, () => false);\n\n  $params.on(opened, (_, { params }) => params).on(updated, (_, { params }) => params);\n\n  $query.on(opened, (_, { query }) => query).on(updated, (_, { query }) => query);\n\n  split({\n    source: navigateFx.doneData,\n    match: $isOpened.map((isOpened) => (isOpened ? \"updated\" : \"opened\")),\n    cases: {\n      opened,\n      updated,\n    },\n  });\n\n  // if (params.filter) {\n  //   const filter = params.filter;\n  //   split({\n  //     // @ts-expect-error\n  //     source: sample({ clock: filter }),\n  //     // @ts-expect-error\n  //     match: (filter) => (filter ? 'true' : 'false'),\n  //     cases: {\n  //       true: opened,\n  //       false: closed,\n  //     },\n  //   });\n  // }\n\n  const instance: RouteInstance<Params> = {\n    $isOpened,\n    $params,\n    $query,\n    opened,\n    updated,\n    closed,\n    navigate: navigateFx,\n    open: openFx,\n    kind: Kind.ROUTE,\n    // @ts-expect-error Internal stuff\n    settings: {\n      derived: Boolean(params.filter),\n    },\n  };\n\n  return instance;\n}\n","export function paramsEqual(a: Record<string, any>, b: Record<string, any>) {\n  if (Object.keys(a).length !== Object.keys(b).length) {\n    return false;\n  }\n  for (const k in a) {\n    // NOTE: Parsed URI always returns string parameters\n    // so we force string comparison here\n    // in order to avoid extra updates\n    // whenever user passes numeric params\n    if (`${a[k]}` !== `${b[k]}`) {\n      return false;\n    }\n  }\n  return true;\n}\n","import { createEvent, createStore, type EventCallable, type StoreWritable } from \"effector\";\n\nimport type { RouteQuery } from \"../types\";\nimport { paramsEqual } from \"../lib/equals\";\n\ninterface RouterControls {\n  $query: StoreWritable<RouteQuery>;\n  back: EventCallable<void>;\n  forward: EventCallable<void>;\n}\n\nexport function createRouterControls(): RouterControls {\n  return {\n    $query: createStore({}, { updateFilter: (update, current) => !paramsEqual(current, update) }),\n    back: createEvent(),\n    forward: createEvent(),\n  };\n}\n","import { match, compile } from \"path-to-regexp\";\n\nimport type { RouteParams, PathCreator, RouteQuery, ParamsSerializer } from \"../types\";\n\n// NOTE: If path is URL - provide it as is\n// Otherwise - extract pathname and hash\nconst getComparablePath = (path: string) => {\n  if (path.match(/^[a-z0-9]+\\:\\/\\//i)) {\n    return path;\n  }\n  const url = new URL(`http://_${path}`);\n  return [url.pathname, url.hash].join(\"\");\n};\n\n// NOTE: path-to-regexp treats \":\" in \"https://\" as param start\n// So we escape it\nfunction normalizePathCreator(pathCreator: string) {\n  return pathCreator.replace(\"://\", \"\\\\://\");\n}\n\ntype BuildPathParams<Params extends RouteParams> = {\n  pathCreator: PathCreator<Params>;\n  params: Params;\n  query: RouteQuery;\n  serialize?: ParamsSerializer;\n};\nexport function buildPath<Params extends RouteParams>({\n  pathCreator,\n  params,\n  query,\n  serialize,\n}: BuildPathParams<Params>) {\n  const pathname = compile(pathCreator)(params);\n  const serializedParams = serialize?.write(query) ?? new URLSearchParams(query);\n  const qs = Object.keys(query).length ? `?${serializedParams}` : \"\";\n  const url = `${pathname}${qs}`;\n  return url;\n}\n\ntype MatchPathParams<Params extends RouteParams> = {\n  pathCreator: PathCreator<Params>;\n  actualPath: string;\n};\nexport function matchPath<Params extends RouteParams>({\n  pathCreator,\n  actualPath,\n}: MatchPathParams<Params>) {\n  const matches = match(normalizePathCreator(pathCreator))(getComparablePath(actualPath));\n  if (matches) {\n    return { matches: true, params: matches.params } as const;\n  }\n  return { matches: false } as const;\n}\n","import { Kind, RouteInstance, RouteInstanceInternal } from \"../types\";\n\n/** Detects whether passed value is a `RouteInstance<any>` or not */\nexport function isRoute(route: RouteInstance<any> | unknown): route is RouteInstance<any> {\n  return (\n    typeof route === \"object\" && route !== null && \"kind\" in route && route.kind === Kind.ROUTE\n  );\n}\n\nexport function isRouteInternal(\n  route: RouteInstanceInternal<any> | unknown,\n): route is RouteInstanceInternal<any> {\n  return isRoute(route);\n}\n","import { History } from \"history\";\nimport { createEffect } from \"effector\";\n\nimport { HistoryBackForwardParams, HistoryPushParams } from \"../types\";\n\nfunction assertHistory(history: History) {\n  if (!history) {\n    throw new Error(\"[Atomic-Router] No history provided\");\n  }\n}\n\nexport const historyPushFx = createEffect((params: HistoryPushParams) => {\n  assertHistory(params.history);\n  params.history[params.method](params.path, {});\n  return params;\n});\n\nexport const historyBackFx = createEffect((history: HistoryBackForwardParams) => {\n  assertHistory(history);\n  history.back();\n  return history;\n});\n\nexport const historyForwardFx = createEffect((history: HistoryBackForwardParams) => {\n  assertHistory(history);\n  history.forward();\n  return history;\n});\n","import { Store } from \"effector\";\n\nexport function not<T>(source: Store<T>): Store<boolean> {\n  return source.map((value) => !value);\n}\n","import { Clock, createEvent, createStore, Event, is, sample, Store } from \"effector\";\nimport { EmptyObject, RouteInstance, RouteParams, RouteQuery } from \"../types\";\n\ntype RedirectParams<T, Params extends RouteParams> = Params extends EmptyObject\n  ? {\n      clock?: Clock<T>;\n      route: RouteInstance<Params>;\n      query?: ((clock: T) => RouteQuery) | Store<RouteQuery> | RouteQuery;\n      replace?: ((clock: T) => boolean) | Store<boolean> | boolean;\n    }\n  :\n      | {\n          clock?: Clock<T>;\n          route: RouteInstance<Params>;\n          params: ((clock: T) => Params) | Store<Params> | Params;\n          query?: ((clock: T) => RouteQuery) | Store<RouteQuery> | RouteQuery;\n          replace?: ((clock: T) => boolean) | Store<boolean> | boolean;\n        }\n      | {\n          clock?: Clock<{\n            params: Params;\n            query?: RouteQuery;\n            replace?: boolean;\n          }>;\n          route: RouteInstance<Params>;\n          params?: ((clock: T) => Params) | Store<Params> | Params;\n          query?: ((clock: T) => RouteQuery) | Store<RouteQuery> | RouteQuery;\n          replace?: ((clock: T) => boolean) | Store<boolean> | boolean;\n        };\n\n/** Opens passed `route` upon `clock` trigger */\nexport function redirect<T, Params extends RouteParams>(options: RedirectParams<T, Params>) {\n  const clock: Event<T> = options.clock\n    ? sample({ clock: options.clock as Event<T> })\n    : createEvent<T>();\n\n  const params = toStore(options.params || {});\n  const query = toStore(options.query || {});\n  const replace = toStore(options.replace || false);\n\n  sample({\n    clock: clock,\n    source: { params, query, replace },\n    fn: ({ params, query, replace }, clock) => ({\n      params: typeof params === \"function\" ? params(clock) : params,\n      query: typeof query === \"function\" ? query(clock) : query,\n      replace: typeof replace === \"function\" ? replace(clock) : replace,\n    }),\n    target: options.route.navigate,\n  });\n\n  return clock;\n}\n\nfunction toStore<T>(payload: T | Store<T>): Store<T> {\n  return is.store(payload) ? payload : createStore(payload as T);\n}\n","import { History } from \"history\";\nimport { Effect, Store, Event, EventCallable } from \"effector\";\n\nexport type RouteParams = Record<string, any>;\n\nexport type RouteQuery = Record<string, any>;\n\nexport type RouteParamsAndQuery<Params extends RouteParams> = {\n  params: Params;\n  query: RouteQuery;\n};\n\nexport interface NavigateParams<Params extends RouteParams> extends RouteParamsAndQuery<Params> {\n  replace?: boolean;\n}\n\nexport type RouteInstance<Params extends RouteParams> = {\n  $isOpened: Store<boolean>;\n  $params: Store<Params>;\n  $query: Store<RouteQuery>;\n  opened: Event<RouteParamsAndQuery<Params>>;\n  updated: Event<RouteParamsAndQuery<Params>>;\n  closed: Event<void>;\n  navigate: Effect<NavigateParams<Params>, NavigateParams<Params>>;\n  open: Effect<Params extends EmptyObject ? void : Params, RouteParamsAndQuery<Params>>;\n  kind: typeof Kind.ROUTE;\n};\n\nexport interface RouteInstanceInternal<Params extends RouteParams> extends RouteInstance<Params> {\n  opened: EventCallable<RouteParamsAndQuery<Params>>;\n  updated: EventCallable<RouteParamsAndQuery<Params>>;\n  closed: EventCallable<void>;\n}\n\nexport type RouteObject<Params extends RouteParams> = {\n  route: RouteInstance<Params>;\n  path: string;\n};\n\nexport interface RouteObjectInternal<Params extends RouteParams> extends RouteObject<Params> {\n  route: RouteInstanceInternal<Params>;\n}\n\nexport type UnmappedRouteObject<Params extends RouteParams> = {\n  route: RouteInstance<Params> | RouteInstance<Params>[];\n  path: string;\n};\n\nexport type HistoryPushParams = {\n  history: History;\n  path: string;\n  params: RouteParams;\n  query: RouteQuery;\n  method: \"replace\" | \"push\";\n};\n\nexport type HistoryBackForwardParams = History;\n\nexport type ParamsSerializer = {\n  write: (params: RouteParams) => string;\n  read: (query: string) => RouteParams;\n};\n\n// @ts-expect-error 'Params' is declared but its value is never read. ts(6133)\nexport type PathCreator<Params extends RouteParams> = string;\n\nexport const Kind = {\n  ROUTE: Symbol(),\n};\n\nexport type EmptyObject = { [key in string]: never };\n","import { History } from \"history\";\nimport { attach, combine, createEvent, createStore, sample, scopeBind } from \"effector\";\nimport { createRouterControls } from \"./create-router-controls\";\nimport {\n  HistoryPushParams,\n  ParamsSerializer,\n  RouteInstance,\n  RouteObject,\n  RouteParams,\n  RouteQuery,\n  UnmappedRouteObject,\n} from \"../types\";\nimport { remapRouteObjects } from \"../lib/remap-route-objects\";\nimport { paramsEqual } from \"../lib/equals\";\nimport { buildPath, matchPath } from \"../lib/build-path\";\nimport { isRouteInternal } from \"./is-route\";\nimport { historyBackFx, historyForwardFx, historyPushFx } from \"../lib/history-effects\";\nimport { not } from \"../lib/logic\";\n\nexport function createHistoryRouter({\n  base,\n  routes,\n  notFoundRoute,\n  hydrate,\n  serialize,\n  controls = createRouterControls(),\n}: {\n  base?: string;\n  routes: UnmappedRouteObject<any>[];\n  notFoundRoute?: RouteInstance<any>;\n  serialize?: ParamsSerializer;\n  hydrate?: boolean;\n  controls?: ReturnType<typeof createRouterControls>;\n}) {\n  const $hydrateMode = createStore(hydrate ?? false, {\n    /**\n     * It is explicitly set in the config and not as a Store,\n     * so value from config should be used at all times - we don't want to serialize this value\n     */\n    serialize: \"ignore\",\n  });\n  const remappedRoutes = remapRouteObjects(routes, base);\n\n  const setHistory = createEvent<History>();\n  const navigateFromRouteTriggered = createEvent<{\n    route: RouteObject<any>;\n    params: RouteParams;\n    query: RouteQuery;\n    replace: boolean;\n  }>();\n  const historyUpdated = createEvent();\n  const recalculateTriggered = createEvent<{\n    path: string;\n    query: RouteQuery;\n    hash: string;\n  }>();\n  const recalculated = createEvent<{\n    path: string;\n    query: RouteQuery;\n    matching: RecalculationResult<any>[];\n    mismatching: RecalculationResult<any>[];\n  }>();\n  const routesMatched = createEvent<RecalculationResult<any>[]>();\n  const routesMismatched = createEvent<RecalculationResult<any>[]>();\n  const routeNotFound = createEvent();\n  const initialized = createEvent<{\n    activeRoutes: RouteInstance<any>[];\n    path: string;\n    query: RouteQuery;\n  }>();\n\n  const $path = createStore(\"\");\n  const $query = createStore<RouteQuery>(\n    {},\n    {\n      name: \"historyRouter.$query\",\n      updateFilter: (newQuery, oldQuery) => !paramsEqual(newQuery, oldQuery),\n    },\n  );\n  const $activeRoutes = createStore<RouteInstance<any>[]>([], {\n    serialize: \"ignore\",\n  });\n  // @ts-expect-error\n  const $history = createStore<History>(null, {\n    serialize: \"ignore\",\n  });\n  const $isFirstCheckPassed = createStore(false);\n  const $isRouteNavigateInProgress = createStore(false);\n\n  const pushFx = attach({\n    source: $history,\n    effect(history, params: Omit<HistoryPushParams, \"history\">) {\n      return historyPushFx({\n        history,\n        ...params,\n      });\n    },\n  });\n\n  const subscribeHistoryFx = attach({\n    source: $history,\n    effect(history) {\n      let scopedHistoryUpdated = historyUpdated;\n      try {\n        // @ts-expect-error\n        scopedHistoryUpdated = scopeBind(historyUpdated);\n      } catch (err) {}\n      history.listen(() => {\n        scopedHistoryUpdated();\n      });\n      return true;\n    },\n  });\n\n  const historyUpdatedParsed = sample({\n    clock: hydrate ? [historyUpdated] : [historyUpdated, subscribeHistoryFx.done],\n    source: $history,\n    filter: Boolean,\n    fn: (history) => ({\n      path: history.location.pathname,\n      query:\n        serialize?.read(history.location.search) ??\n        Object.fromEntries(new URLSearchParams(history.location.search)),\n    }),\n  });\n\n  // If `hydrate` flag is set,\n  // don't trigger recheck on history init\n  const historyUpdateTriggered = sample({\n    clock: historyUpdatedParsed,\n    source: {\n      path: $path,\n      query: $query,\n    },\n    filter: ({ path: savedPath, query: savedQuery }, history) =>\n      history.path !== savedPath || !paramsEqual(history.query, savedQuery),\n    fn: (_, history) => history,\n  });\n\n  /// History subscription\n  $history.on(setHistory, (_, history) => history);\n\n  sample({\n    clock: $history,\n    target: subscribeHistoryFx,\n  });\n\n  sample({\n    clock: historyUpdateTriggered,\n    source: $history,\n    filter: Boolean,\n    fn(history) {\n      const path = history?.location.pathname;\n      const hash = history?.location.hash;\n      const query: RouteQuery =\n        serialize?.read(history?.location.search) ??\n        Object.fromEntries(new URLSearchParams(history?.location.search));\n      return { path, query, hash };\n    },\n    target: recalculateTriggered,\n  });\n\n  /// Routes updates handling\n  for (const routeObj of remappedRoutes) {\n    const currentRouteMatched = routesMatched.filterMap(containsCurrentRoute(routeObj));\n    const currentRouteMismatched = routesMismatched.filterMap(containsCurrentRoute(routeObj));\n    const routeStateChangeRequested = {\n      /**\n       * Special case:\n       * - Scope is initied from server data, route.$isOpened -> true\n       * - but `hydrate` flag is set to false\n       *\n       * So route.opened() should be called after router.setHistory anyway to respect that\n       */\n      initialized: sample({\n        clock: subscribeHistoryFx.done,\n        filter: combine(\n          routeObj.route.$isOpened,\n          $hydrateMode,\n          (isOpened, hydrateMode) => isOpened && !hydrateMode,\n        ),\n      }),\n      opened: sample({\n        clock: currentRouteMatched,\n        filter: not(routeObj.route.$isOpened),\n      }),\n      updated: sample({\n        clock: currentRouteMatched,\n        filter: routeObj.route.$isOpened,\n      }),\n      closed: sample({\n        clock: currentRouteMismatched,\n        filter: routeObj.route.$isOpened,\n      }),\n    };\n\n    /**\n     * Trigger .opened() for special case with scope being initialized from server data\n     */\n    sample({\n      clock: routeStateChangeRequested.initialized,\n      source: {\n        params: routeObj.route.$params,\n        query: routeObj.route.$query,\n      },\n      target: routeObj.route.opened,\n    });\n\n    // Trigger .updated() for the routes marked as \"matched\" but already opened\n    sample({\n      clock: routeStateChangeRequested.updated,\n      source: [routeObj.route.$params, routeObj.route.$query],\n      // Skip .updated() calls if params & query are the same\n      filter: ([params, query], next) =>\n        !paramsEqual(params, next.params) || !paramsEqual(query, next.query),\n      fn: (_, paramsAndQuery) => paramsAndQuery,\n      target: routeObj.route.updated,\n    });\n\n    // Trigger .opened() for the routes marked as \"matched\" but not opened yet\n    sample({\n      clock: routeStateChangeRequested.opened,\n      // TODO: Scratch this?\n      filter: not($isRouteNavigateInProgress),\n      target: routeObj.route.opened,\n    });\n\n    // Trigger .closed() for the routes marked as \"mismatched\" but opened\n    sample({\n      clock: routeStateChangeRequested.closed,\n      target: routeObj.route.closed,\n    });\n  }\n\n  /// Handling route.navigateFx navigation\n  for (const routeObj of remappedRoutes) {\n    // Run \"Handling route.navigateFx navigation\" step\n    sample({\n      clock: routeObj.route.navigate.doneData,\n      fn: ({ params, query, replace }) => ({\n        route: routeObj,\n        params,\n        query,\n        replace: replace ?? false,\n      }),\n      target: navigateFromRouteTriggered,\n    });\n  }\n\n  $isRouteNavigateInProgress.on(navigateFromRouteTriggered, () => true);\n\n  sample({\n    clock: navigateFromRouteTriggered,\n    fn({ route, params, query, replace }) {\n      const path = buildPath({\n        pathCreator: route.path,\n        params,\n        query,\n        serialize,\n      });\n      const method: \"replace\" | \"push\" = replace ? \"replace\" : \"push\";\n      return {\n        path,\n        params,\n        query,\n        method,\n      };\n    },\n    target: pushFx,\n  });\n\n  $isRouteNavigateInProgress.reset([routesMatched, routesMismatched]);\n\n  /// Recalculation\n  // Triggered on every history change + once when history instance is set\n  sample({\n    clock: recalculateTriggered,\n    fn({ path, query, hash }) {\n      const matchingRoutes = [] as RecalculationResult<any>[];\n      const mismatchingRoutes = [] as RecalculationResult<any>[];\n\n      for (const route of remappedRoutes) {\n        // NOTE: Use hash string as well if route.path contains #\n        const actualPath = route.path.includes(\"#\") ? `${path}${hash}` : `${path}`;\n        const { matches, params } = matchPath({\n          pathCreator: route.path,\n          actualPath,\n        });\n\n        const suitableRoutes = matches ? matchingRoutes : mismatchingRoutes;\n        suitableRoutes.push({\n          routeObj: route,\n          params,\n          query,\n        });\n      }\n\n      // Checking for routes we need to close\n      // Remove all that are marked to be opened\n      mismatchingRoutes.forEach((mismatchedRoute, mismatchedIndex) => {\n        const mismatchedRouteExistsInMatchedList = matchingRoutes.some(\n          (matchedRoute) => matchedRoute.routeObj.route === mismatchedRoute.routeObj.route,\n        );\n        if (mismatchedRouteExistsInMatchedList) {\n          mismatchingRoutes.splice(mismatchedIndex, 1);\n        }\n      });\n\n      return {\n        matching: matchingRoutes,\n        mismatching: mismatchingRoutes.filter(Boolean),\n        path,\n        query,\n      };\n    },\n    target: recalculated,\n  });\n\n  $path.on(historyUpdateTriggered, (_, { path }) => path);\n\n  $query.on(historyUpdateTriggered, (_, { query }) => query);\n\n  const matchingRecalculated = recalculated.map(({ matching }) => matching);\n\n  sample({\n    clock: matchingRecalculated,\n    filter: (routes) => routes.length > 0,\n    target: routesMatched,\n  });\n\n  sample({\n    clock: recalculated.map(({ mismatching }) => mismatching),\n    filter: (routes) => routes.length > 0,\n    target: routesMismatched,\n  });\n\n  $activeRoutes.on(recalculated, (_, { matching }) =>\n    matching.map((recheckResult) => recheckResult.routeObj.route),\n  );\n\n  /// Handling 404\n  sample({\n    clock: matchingRecalculated,\n    filter: (routes) => routes.length === 0,\n    target: routeNotFound,\n  });\n\n  if (isRouteInternal(notFoundRoute)) {\n    sample({\n      clock: routeNotFound,\n      source: $query,\n      filter: notFoundRoute.$isOpened,\n      fn: (query) => ({ query, params: {} }),\n      target: notFoundRoute.updated,\n    });\n\n    sample({\n      clock: routeNotFound,\n      source: { query: $query, isOpened: notFoundRoute.$isOpened },\n      filter: ({ isOpened }) => !isOpened,\n      fn: ({ query }) => ({ query, params: {} }),\n      target: notFoundRoute.opened,\n    });\n\n    sample({\n      clock: matchingRecalculated,\n      source: notFoundRoute.$isOpened,\n      filter: (isOpened, matching) => isOpened && matching.length > 0,\n      target: notFoundRoute.closed,\n    });\n  }\n\n  /// Back/forward navigation\n  sample({\n    clock: controls.back,\n    source: $history,\n    target: historyBackFx,\n  });\n\n  sample({\n    clock: controls.forward,\n    source: $history,\n    target: historyForwardFx,\n  });\n\n  /// Query syncing\n  sample({\n    clock: $query,\n    source: { controlsQuery: controls.$query, localQuery: $query },\n    filter: ({ controlsQuery, localQuery }) => !paramsEqual(controlsQuery, localQuery),\n    fn: ({ localQuery }) => localQuery,\n    target: controls.$query,\n  });\n\n  sample({\n    clock: controls.$query,\n    source: {\n      path: $path,\n      localQuery: $query,\n      isNavigateInProgress: $isRouteNavigateInProgress,\n      realHistory: $history,\n    },\n    filter: ({ localQuery, isNavigateInProgress, realHistory }, query) => {\n      const realQuery =\n        serialize?.read(realHistory?.location.search ?? \"\") ??\n        Object.fromEntries(new URLSearchParams(realHistory?.location.search ?? \"\"));\n      return (\n        isNavigateInProgress || !paramsEqual(query, realQuery) || !paramsEqual(localQuery, query)\n      );\n    },\n    fn({ path }, query) {\n      const qs = serialize?.write(query) ?? new URLSearchParams(query);\n      return {\n        path: `${path}${qs ? `?${qs}` : \"\"}`,\n        params: {},\n        query: query,\n        method: \"push\" as const,\n      };\n    },\n    target: pushFx,\n  });\n\n  /// Initialization\n  sample({\n    clock: recalculated,\n    source: {\n      activeRoutes: $activeRoutes,\n      path: $path,\n      query: $query,\n    },\n    filter: $isFirstCheckPassed.map((isFirstCheckPassed) => !isFirstCheckPassed),\n    target: initialized,\n  });\n\n  $isFirstCheckPassed.on(initialized, () => true).reset($history);\n\n  return {\n    $path,\n    $activeRoutes,\n    $history,\n    setHistory,\n    $query: $query,\n    back: controls.back,\n    forward: controls.forward,\n    push: pushFx,\n    routes: remappedRoutes,\n    initialized,\n    routeNotFound,\n  };\n}\n\ntype RecalculationResult<Params extends RouteParams> = {\n  routeObj: RouteObject<Params>;\n  params: Params;\n  query: RouteQuery;\n};\n\nconst containsCurrentRoute =\n  (routeObj: RouteObject<any>) => (recheckResults: RecalculationResult<any>[]) => {\n    const recheck = recheckResults.find(\n      (recheckResult) => recheckResult.routeObj.route === routeObj.route,\n    );\n    if (!recheck) {\n      return;\n    }\n    return {\n      params: recheck.params,\n      query: recheck.query,\n    };\n  };\n","import { Clock, combine, createStore, sample, Store, Unit } from \"effector\";\n\nimport { RouteInstance, RouteQuery } from \"../types\";\nimport { createRouterControls } from \"./create-router-controls\";\n\ntype QueryCleanupStrategy = {\n  irrelevant: boolean;\n  empty: boolean;\n  preserve: string[];\n};\n\ntype QuerySyncParams<T extends Record<string, Store<any>>> = {\n  source: T;\n  clock?: Clock<any>;\n  controls: ReturnType<typeof createRouterControls>;\n  route?: RouteInstance<any>;\n  cleanup?: boolean | Partial<QueryCleanupStrategy>;\n};\n\nexport function querySync<T extends Record<string, Store<any>>>(params: QuerySyncParams<T>) {\n  const $isOpened = params.route?.$isOpened ?? createStore(true);\n  const $source = combine(params.source);\n  const clock = (params.clock ?? $source) as Unit<any>;\n  const cleanupStrategy = !(\"cleanup\" in params)\n    ? cleanupStrategies.default\n    : typeof params.cleanup === \"boolean\"\n      ? cleanupStrategies[params.cleanup ? \"all\" : \"none\"]\n      : { ...cleanupStrategies.default, ...params.cleanup! };\n\n  const queryUpdatedFromHistory = sample({\n    clock: params.controls.$query,\n    filter: $isOpened,\n  });\n\n  sample({\n    clock,\n    source: combine([$source, params.controls.$query]),\n    filter: $isOpened,\n    fn: ([source, currentQuery]) => {\n      let nextQuery: RouteQuery = {};\n      if (cleanupStrategy.irrelevant) {\n        for (const key of cleanupStrategy.preserve) {\n          if (key in currentQuery) {\n            nextQuery[key] = currentQuery[key];\n          }\n        }\n      } else {\n        nextQuery = { ...currentQuery };\n      }\n      for (const key in source) {\n        nextQuery[key] = source[key];\n      }\n      if (cleanupStrategy.empty) {\n        for (const key in source) {\n          if (!cleanupStrategy.preserve.includes(key) && !nextQuery[key]) {\n            delete nextQuery[key];\n          }\n        }\n      }\n      return nextQuery as RouteQuery;\n    },\n    target: params.controls.$query,\n  });\n\n  for (const k in params.source) {\n    const $queryParam = params.source[k as keyof typeof params.source];\n    // @ts-expect-error\n    $queryParam.on(queryUpdatedFromHistory, (_, query) => {\n      return query[k] ?? $queryParam.defaultState;\n    });\n  }\n}\n\nconst cleanupStrategies = {\n  all: {\n    irrelevant: true,\n    empty: true,\n    preserve: [],\n  },\n  default: {\n    irrelevant: false,\n    empty: true,\n    preserve: [],\n  },\n  none: {\n    irrelevant: false,\n    empty: false,\n    preserve: [],\n  },\n};\n","import {\n  is,\n  merge,\n  sample,\n  combine,\n  createStore,\n  Unit,\n  Clock,\n  Effect,\n  StoreValue,\n  createEvent,\n  NoInfer,\n  EffectParams,\n  attach,\n  UnitTargetable,\n} from \"effector\";\n\nimport { createRoute } from \"./create-route\";\nimport {\n  RouteInstance,\n  RouteInstanceInternal,\n  RouteParams,\n  RouteParamsAndQuery,\n  RouteQuery,\n} from \"../types\";\n\nimport { isRouteInternal } from \"./is-route\";\n\ntype ChainRouteParamsInternalAttach<\n  Params extends RouteParams,\n  FX extends Effect<any, any, any>,\n> = {\n  route: RouteInstance<Params>;\n  chainedRoute?: RouteInstance<Params>;\n  beforeOpen: {\n    effect: FX;\n    mapParams: ({\n      params,\n      query,\n    }: {\n      params: Params;\n      query: RouteQuery;\n    }) => NoInfer<EffectParams<FX>>;\n  };\n  openOn?: Clock<any>;\n  cancelOn?: Clock<any>;\n};\n\ntype ChainRouteParamsWithEffect<Params extends RouteParams> = {\n  route: RouteInstance<Params>;\n  chainedRoute?: RouteInstance<Params>;\n  beforeOpen: Effect<RouteParamsAndQuery<Params>, any, any>;\n};\n\ntype ChainRouteParamsAdvanced<Params extends RouteParams> = {\n  route: RouteInstance<Params>;\n  chainedRoute?: RouteInstance<Params>;\n  beforeOpen: Clock<RouteParamsAndQuery<Params>>;\n  openOn: Clock<any>;\n  cancelOn?: Clock<any>;\n};\n\ntype ChainRouteParams<Params extends RouteParams, FX extends Effect<any, any, any>> =\n  | RouteInstance<Params>\n  | ChainRouteParamsWithEffect<Params>\n  | ChainRouteParamsAdvanced<Params>\n  | ChainRouteParamsInternalAttach<Params, FX>;\n\nfunction chainRoute<Params extends RouteParams>(\n  instance: RouteInstance<Params>,\n): RouteInstance<Params>;\n\nfunction chainRoute<Params extends RouteParams>(\n  config: ChainRouteParamsWithEffect<Params>,\n): RouteInstance<Params>;\n\nfunction chainRoute<Params extends RouteParams>(\n  config: ChainRouteParamsAdvanced<Params>,\n): RouteInstance<Params>;\n\nfunction chainRoute<Params extends RouteParams, FX extends Effect<any, any, any>>(\n  config: ChainRouteParamsInternalAttach<Params, FX>,\n): RouteInstance<Params>;\n\n/**\n * Creates chained route\n * @link https://github.com/Kelin2025/atomic-router/issues/10\n * @param {RouteInstance<any>} params.route - Route to listen\n * @param {RouteInstance<any>} [params.chainedRoute]  - Route to be created\n * @param {Clock<any>} params.beforeOpen - Will be triggered when `params.route` open\n * @param {Clock<any>} params.openOn - Will open `chainedRoute` if `params.route` is still opened\n * @param {Clock<any>} params.cancelOn - Cancels chain\n * @returns {RouteInstance<any>} `chainedRoute`\n */\nfunction chainRoute<Params extends RouteParams, FX extends Effect<any, any, any>>(\n  params: ChainRouteParams<Params, FX>,\n) {\n  const { route, chainedRoute, beforeOpen, openOn, cancelOn } = normalizeChainRouteParams(params);\n  const $params = createStore({} as StoreValue<(typeof route)[\"$params\"]>);\n  const $query = createStore({} as StoreValue<(typeof route)[\"$query\"]>);\n  const $hasSameParams = combine(\n    combine([route.$params, route.$query]),\n    combine([$params, $query]),\n    (current, stored) => {\n      return current[0] === stored[0] && current[1] === stored[1];\n    },\n  );\n  const routeTriggered = sample({ clock: [route.opened, route.updated] });\n\n  // 1. Call `beforeOpen` whenever route is opened\n  sample({\n    clock: routeTriggered,\n    target: beforeOpen as UnitTargetable<RouteParamsAndQuery<any>>,\n  });\n\n  $params.on(routeTriggered, (_prev, { params }) => params);\n  $query.on(routeTriggered, (_prev, { query }) => query);\n\n  // 2. Listen to `openOn` if route is still opened on the same position\n  sample({\n    clock: openOn as Unit<any>,\n    source: { params: $params, query: $query },\n    filter: $hasSameParams,\n    target: chainedRoute.navigate,\n  });\n\n  // 4. Cancel loading if page closed or `cancelOn` is called\n  // @ts-expect-error\n  const aborted = merge([route.closed, cancelOn]);\n\n  $params.reset(aborted);\n  $query.reset(aborted);\n\n  sample({\n    clock: aborted,\n    target: chainedRoute.closed,\n  });\n\n  return chainedRoute;\n}\n\n// This is written separately to correctly export all type overloads\nexport { chainRoute };\n\ntype ChainRouteParamsNormalized<Params extends RouteParams> = {\n  route: RouteInstanceInternal<Params>;\n  chainedRoute: RouteInstanceInternal<Params>;\n  beforeOpen: Clock<RouteParamsAndQuery<Params>>;\n  openOn: Clock<any>;\n  cancelOn: Clock<any>;\n};\n\nfunction normalizeChainRouteParams<Params extends RouteParams, FX extends Effect<any, any, any>>(\n  params: ChainRouteParams<Params, FX>,\n): ChainRouteParamsNormalized<Params> {\n  const resultParams: ChainRouteParamsNormalized<Params> = {} as ChainRouteParamsNormalized<Params>;\n\n  if (isRouteInternal(params)) {\n    Object.assign(resultParams, {\n      route: params,\n      chainedRoute: createRoute<Params>(),\n      beforeOpen: createEvent(),\n      openOn: merge([params.opened, params.closed]),\n      cancelOn: merge([]),\n    });\n    return resultParams;\n  }\n  const effectParams = params as ChainRouteParamsWithEffect<Params>;\n  Object.assign(resultParams, {\n    route: effectParams.route,\n    chainedRoute: effectParams.chainedRoute || createRoute<Params>(),\n    beforeOpen: is.unit(effectParams.beforeOpen)\n      ? effectParams.beforeOpen\n      : attach(effectParams.beforeOpen),\n  });\n  if (is.effect(resultParams.beforeOpen as Unit<any>)) {\n    Object.assign(resultParams, {\n      openOn:\n        // @ts-expect-error\n        effectParams.openOn || resultParams.beforeOpen.doneData,\n      cancelOn:\n        // @ts-expect-error\n        effectParams.cancelOn || resultParams.beforeOpen.failData,\n    });\n    return resultParams;\n  }\n  const advancedParams = params as ChainRouteParamsAdvanced<Params>;\n  Object.assign(resultParams, {\n    openOn: sample({ clock: advancedParams.openOn as Unit<any> }),\n    cancelOn: sample({\n      clock: (advancedParams.cancelOn as Unit<any>) || createEvent(),\n    }),\n  });\n  return resultParams;\n}\n","import { UnmappedRouteObject, RouteObject, RouteObjectInternal } from \"../types\";\n\nexport function remapRouteObjects(objects: UnmappedRouteObject<any>[], basePath: string = \"\") {\n  let next: RouteObject<any>[] = [];\n\n  for (const routeObj of objects) {\n    if (Array.isArray(routeObj.route)) {\n      next.push(...routeObj.route.map((route) => ({ ...routeObj, route })));\n    } else {\n      // @ts-expect-error\n      next.push(routeObj);\n    }\n  }\n\n  next = next.map((routeObj) => ({\n    ...routeObj,\n    path: `${basePath}${routeObj.path}`,\n  }));\n\n  const derivedRoutes: RouteObject<any>[] = [];\n  const nonDerivedRoutes: RouteObjectInternal<any>[] = [];\n\n  for (const routeObj of next) {\n    // @ts-expect-error Internals\n    if (routeObj.route.settings.derived) {\n      derivedRoutes.push(routeObj);\n    } else {\n      nonDerivedRoutes.push(routeObj as RouteObjectInternal<any>);\n    }\n  }\n\n  if (derivedRoutes.length) {\n    for (const derivedRoute of derivedRoutes) {\n      console.error(\n        `[Atomic-Router]: createHistoryRouter: ${derivedRoute.path} uses derived route. This won't work`,\n      );\n    }\n  }\n\n  return nonDerivedRoutes;\n}\n"],"names":["createRoute","params","navigateFx","createEffect","_ref","_ref$replace","replace","query","name","sid","openFx","attach","and","effect","mapParams","or","$isOpened","createStore","$params","$query","opened","createEvent","updated","closed","on","_","_ref2","_ref3","_ref4","_ref5","split","source","doneData","match","map","isOpened","cases","navigate","open","kind","Kind","ROUTE","settings","derived","Boolean","filter","paramsEqual","a","b","Object","keys","length","k","createRouterControls","updateFilter","update","current","back","forward","buildPath","_serialize$write","serialize","pathname","compile","pathCreator","serializedParams","write","URLSearchParams","matchPath","actualPath","matches","getComparablePath","isRoute","route","isRouteInternal","assertHistory","history","Error","not","value","toStore","payload","is","store","Symbol","path","url","URL","hash","join","historyPushFx","method","historyBackFx","historyForwardFx","containsCurrentRoute","routeObj","recheckResults","recheck","find","recheckResult","cleanupStrategies","all","irrelevant","empty","preserve","default","none","_normalizeChainRouteP","resultParams","_withFactory","\"-oimir7\"","fn","\"none\"","\"isRouteInternal\"","assign","chainedRoute","\"nxhp9m\"","\"chainedRoute\"","\"createRoute\"","beforeOpen","openOn","merge","cancelOn","effectParams","\"-wf80u2\"","unit","failData","advancedParams","sample","clock","normalizeChainRouteParams","$hasSameParams","combine","stored","routeTriggered","target","_prev","aborted","reset","base","routes","notFoundRoute","hydrate","_ref$controls","controls","\"-eby7\"","\"controls\"","\"createRouterControls\"","$hydrateMode","remappedRoutes","objects","basePath","_step","next","_loop","_next","Array","isArray","push","apply","_objectSpread","_iterator","_createForOfIteratorHelperLoose","done","_step2","derivedRoutes","nonDerivedRoutes","_iterator2","_step3","_iterator3","console","error","remapRouteObjects","setHistory","navigateFromRouteTriggered","historyUpdated","recalculateTriggered","recalculated","routesMatched","routesMismatched","routeNotFound","initialized","$path","newQuery","oldQuery","$activeRoutes","$history","$isFirstCheckPassed","$isRouteNavigateInProgress","pushFx","subscribeHistoryFx","scopedHistoryUpdated","scopeBind","err","listen","historyUpdatedParsed","_serialize$read","location","read","search","fromEntries","historyUpdateTriggered","_serialize$read2","currentRouteMatched","filterMap","currentRouteMismatched","routeStateChangeRequested","hydrateMode","_ref16","paramsAndQuery","_ref17","matchingRoutes","mismatchingRoutes","includes","_matchPath","forEach","mismatchedRoute","mismatchedIndex","some","matchedRoute","splice","matching","mismatching","_ref6","matchingRecalculated","_ref7","_ref8","_ref9","\"-dp1wu2\"","_ref10","_ref11","controlsQuery","localQuery","_ref12","_ref13","isNavigateInProgress","realHistory","_ref14","_serialize$read3","_realHistory$location","_realHistory$location2","realQuery","_ref15","qs","activeRoutes","isFirstCheckPassed","_params$route$$isOpen","_params$route","_params$clock","$source","cleanupStrategy","cleanup","queryUpdatedFromHistory","currentQuery","nextQuery","key","$queryParam","_query$k","defaultState","options"],"mappings":"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"}