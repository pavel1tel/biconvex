{
  "version": 3,
  "sources": ["../../path-to-regexp/src/index.ts", "../../atomic-router/src/methods/create-route.ts", "../../atomic-router/src/lib/equals.ts", "../../atomic-router/src/methods/create-router-controls.ts", "../../atomic-router/src/lib/build-path.ts", "../../atomic-router/src/methods/is-route.ts", "../../atomic-router/src/lib/history-effects.ts", "../../atomic-router/src/lib/logic.ts", "../../atomic-router/src/methods/create-history-router.ts", "../../atomic-router/src/lib/remap-route-objects.ts", "../../atomic-router/src/methods/redirect.ts", "../../atomic-router/src/methods/chain-route.ts", "../../atomic-router/src/methods/query-sync.ts", "../../atomic-router/src/types.ts"],
  "sourcesContent": ["/**\n * Tokenizer results.\n */\ninterface LexToken {\n  type:\n    | \"OPEN\"\n    | \"CLOSE\"\n    | \"PATTERN\"\n    | \"NAME\"\n    | \"CHAR\"\n    | \"ESCAPED_CHAR\"\n    | \"MODIFIER\"\n    | \"END\";\n  index: number;\n  value: string;\n}\n\n/**\n * Tokenize input string.\n */\nfunction lexer(str: string): LexToken[] {\n  const tokens: LexToken[] = [];\n  let i = 0;\n\n  while (i < str.length) {\n    const char = str[i];\n\n    if (char === \"*\" || char === \"+\" || char === \"?\") {\n      tokens.push({ type: \"MODIFIER\", index: i, value: str[i++] });\n      continue;\n    }\n\n    if (char === \"\\\\\") {\n      tokens.push({ type: \"ESCAPED_CHAR\", index: i++, value: str[i++] });\n      continue;\n    }\n\n    if (char === \"{\") {\n      tokens.push({ type: \"OPEN\", index: i, value: str[i++] });\n      continue;\n    }\n\n    if (char === \"}\") {\n      tokens.push({ type: \"CLOSE\", index: i, value: str[i++] });\n      continue;\n    }\n\n    if (char === \":\") {\n      let name = \"\";\n      let j = i + 1;\n\n      while (j < str.length) {\n        const code = str.charCodeAt(j);\n\n        if (\n          // `0-9`\n          (code >= 48 && code <= 57) ||\n          // `A-Z`\n          (code >= 65 && code <= 90) ||\n          // `a-z`\n          (code >= 97 && code <= 122) ||\n          // `_`\n          code === 95\n        ) {\n          name += str[j++];\n          continue;\n        }\n\n        break;\n      }\n\n      if (!name) throw new TypeError(`Missing parameter name at ${i}`);\n\n      tokens.push({ type: \"NAME\", index: i, value: name });\n      i = j;\n      continue;\n    }\n\n    if (char === \"(\") {\n      let count = 1;\n      let pattern = \"\";\n      let j = i + 1;\n\n      if (str[j] === \"?\") {\n        throw new TypeError(`Pattern cannot start with \"?\" at ${j}`);\n      }\n\n      while (j < str.length) {\n        if (str[j] === \"\\\\\") {\n          pattern += str[j++] + str[j++];\n          continue;\n        }\n\n        if (str[j] === \")\") {\n          count--;\n          if (count === 0) {\n            j++;\n            break;\n          }\n        } else if (str[j] === \"(\") {\n          count++;\n          if (str[j + 1] !== \"?\") {\n            throw new TypeError(`Capturing groups are not allowed at ${j}`);\n          }\n        }\n\n        pattern += str[j++];\n      }\n\n      if (count) throw new TypeError(`Unbalanced pattern at ${i}`);\n      if (!pattern) throw new TypeError(`Missing pattern at ${i}`);\n\n      tokens.push({ type: \"PATTERN\", index: i, value: pattern });\n      i = j;\n      continue;\n    }\n\n    tokens.push({ type: \"CHAR\", index: i, value: str[i++] });\n  }\n\n  tokens.push({ type: \"END\", index: i, value: \"\" });\n\n  return tokens;\n}\n\nexport interface ParseOptions {\n  /**\n   * Set the default delimiter for repeat parameters. (default: `'/'`)\n   */\n  delimiter?: string;\n  /**\n   * List of characters to automatically consider prefixes when parsing.\n   */\n  prefixes?: string;\n}\n\n/**\n * Parse a string for the raw tokens.\n */\nexport function parse(str: string, options: ParseOptions = {}): Token[] {\n  const tokens = lexer(str);\n  const { prefixes = \"./\" } = options;\n  const defaultPattern = `[^${escapeString(options.delimiter || \"/#?\")}]+?`;\n  const result: Token[] = [];\n  let key = 0;\n  let i = 0;\n  let path = \"\";\n\n  const tryConsume = (type: LexToken[\"type\"]): string | undefined => {\n    if (i < tokens.length && tokens[i].type === type) return tokens[i++].value;\n  };\n\n  const mustConsume = (type: LexToken[\"type\"]): string => {\n    const value = tryConsume(type);\n    if (value !== undefined) return value;\n    const { type: nextType, index } = tokens[i];\n    throw new TypeError(`Unexpected ${nextType} at ${index}, expected ${type}`);\n  };\n\n  const consumeText = (): string => {\n    let result = \"\";\n    let value: string | undefined;\n    while ((value = tryConsume(\"CHAR\") || tryConsume(\"ESCAPED_CHAR\"))) {\n      result += value;\n    }\n    return result;\n  };\n\n  while (i < tokens.length) {\n    const char = tryConsume(\"CHAR\");\n    const name = tryConsume(\"NAME\");\n    const pattern = tryConsume(\"PATTERN\");\n\n    if (name || pattern) {\n      let prefix = char || \"\";\n\n      if (prefixes.indexOf(prefix) === -1) {\n        path += prefix;\n        prefix = \"\";\n      }\n\n      if (path) {\n        result.push(path);\n        path = \"\";\n      }\n\n      result.push({\n        name: name || key++,\n        prefix,\n        suffix: \"\",\n        pattern: pattern || defaultPattern,\n        modifier: tryConsume(\"MODIFIER\") || \"\",\n      });\n      continue;\n    }\n\n    const value = char || tryConsume(\"ESCAPED_CHAR\");\n    if (value) {\n      path += value;\n      continue;\n    }\n\n    if (path) {\n      result.push(path);\n      path = \"\";\n    }\n\n    const open = tryConsume(\"OPEN\");\n    if (open) {\n      const prefix = consumeText();\n      const name = tryConsume(\"NAME\") || \"\";\n      const pattern = tryConsume(\"PATTERN\") || \"\";\n      const suffix = consumeText();\n\n      mustConsume(\"CLOSE\");\n\n      result.push({\n        name: name || (pattern ? key++ : \"\"),\n        pattern: name && !pattern ? defaultPattern : pattern,\n        prefix,\n        suffix,\n        modifier: tryConsume(\"MODIFIER\") || \"\",\n      });\n      continue;\n    }\n\n    mustConsume(\"END\");\n  }\n\n  return result;\n}\n\nexport interface TokensToFunctionOptions {\n  /**\n   * When `true` the regexp will be case sensitive. (default: `false`)\n   */\n  sensitive?: boolean;\n  /**\n   * Function for encoding input strings for output.\n   */\n  encode?: (value: string, token: Key) => string;\n  /**\n   * When `false` the function can produce an invalid (unmatched) path. (default: `true`)\n   */\n  validate?: boolean;\n}\n\n/**\n * Compile a string to a template function for the path.\n */\nexport function compile<P extends object = object>(\n  str: string,\n  options?: ParseOptions & TokensToFunctionOptions\n) {\n  return tokensToFunction<P>(parse(str, options), options);\n}\n\nexport type PathFunction<P extends object = object> = (data?: P) => string;\n\n/**\n * Expose a method for transforming tokens into the path function.\n */\nexport function tokensToFunction<P extends object = object>(\n  tokens: Token[],\n  options: TokensToFunctionOptions = {}\n): PathFunction<P> {\n  const reFlags = flags(options);\n  const { encode = (x: string) => x, validate = true } = options;\n\n  // Compile all the tokens into regexps.\n  const matches = tokens.map((token) => {\n    if (typeof token === \"object\") {\n      return new RegExp(`^(?:${token.pattern})$`, reFlags);\n    }\n  });\n\n  return (data: Record<string, any> | null | undefined) => {\n    let path = \"\";\n\n    for (let i = 0; i < tokens.length; i++) {\n      const token = tokens[i];\n\n      if (typeof token === \"string\") {\n        path += token;\n        continue;\n      }\n\n      const value = data ? data[token.name] : undefined;\n      const optional = token.modifier === \"?\" || token.modifier === \"*\";\n      const repeat = token.modifier === \"*\" || token.modifier === \"+\";\n\n      if (Array.isArray(value)) {\n        if (!repeat) {\n          throw new TypeError(\n            `Expected \"${token.name}\" to not repeat, but got an array`\n          );\n        }\n\n        if (value.length === 0) {\n          if (optional) continue;\n\n          throw new TypeError(`Expected \"${token.name}\" to not be empty`);\n        }\n\n        for (let j = 0; j < value.length; j++) {\n          const segment = encode(value[j], token);\n\n          if (validate && !(matches[i] as RegExp).test(segment)) {\n            throw new TypeError(\n              `Expected all \"${token.name}\" to match \"${token.pattern}\", but got \"${segment}\"`\n            );\n          }\n\n          path += token.prefix + segment + token.suffix;\n        }\n\n        continue;\n      }\n\n      if (typeof value === \"string\" || typeof value === \"number\") {\n        const segment = encode(String(value), token);\n\n        if (validate && !(matches[i] as RegExp).test(segment)) {\n          throw new TypeError(\n            `Expected \"${token.name}\" to match \"${token.pattern}\", but got \"${segment}\"`\n          );\n        }\n\n        path += token.prefix + segment + token.suffix;\n        continue;\n      }\n\n      if (optional) continue;\n\n      const typeOfMessage = repeat ? \"an array\" : \"a string\";\n      throw new TypeError(`Expected \"${token.name}\" to be ${typeOfMessage}`);\n    }\n\n    return path;\n  };\n}\n\nexport interface RegexpToFunctionOptions {\n  /**\n   * Function for decoding strings for params.\n   */\n  decode?: (value: string, token: Key) => string;\n}\n\n/**\n * A match result contains data about the path match.\n */\nexport interface MatchResult<P extends object = object> {\n  path: string;\n  index: number;\n  params: P;\n}\n\n/**\n * A match is either `false` (no match) or a match result.\n */\nexport type Match<P extends object = object> = false | MatchResult<P>;\n\n/**\n * The match function takes a string and returns whether it matched the path.\n */\nexport type MatchFunction<P extends object = object> = (\n  path: string\n) => Match<P>;\n\n/**\n * Create path match function from `path-to-regexp` spec.\n */\nexport function match<P extends object = object>(\n  str: Path,\n  options?: ParseOptions & TokensToRegexpOptions & RegexpToFunctionOptions\n) {\n  const keys: Key[] = [];\n  const re = pathToRegexp(str, keys, options);\n  return regexpToFunction<P>(re, keys, options);\n}\n\n/**\n * Create a path match function from `path-to-regexp` output.\n */\nexport function regexpToFunction<P extends object = object>(\n  re: RegExp,\n  keys: Key[],\n  options: RegexpToFunctionOptions = {}\n): MatchFunction<P> {\n  const { decode = (x: string) => x } = options;\n\n  return function (pathname: string) {\n    const m = re.exec(pathname);\n    if (!m) return false;\n\n    const { 0: path, index } = m;\n    const params = Object.create(null);\n\n    for (let i = 1; i < m.length; i++) {\n      if (m[i] === undefined) continue;\n\n      const key = keys[i - 1];\n\n      if (key.modifier === \"*\" || key.modifier === \"+\") {\n        params[key.name] = m[i].split(key.prefix + key.suffix).map((value) => {\n          return decode(value, key);\n        });\n      } else {\n        params[key.name] = decode(m[i], key);\n      }\n    }\n\n    return { path, index, params };\n  };\n}\n\n/**\n * Escape a regular expression string.\n */\nfunction escapeString(str: string) {\n  return str.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, \"\\\\$1\");\n}\n\n/**\n * Get the flags for a regexp from the options.\n */\nfunction flags(options?: { sensitive?: boolean }) {\n  return options && options.sensitive ? \"\" : \"i\";\n}\n\n/**\n * Metadata about a key.\n */\nexport interface Key {\n  name: string | number;\n  prefix: string;\n  suffix: string;\n  pattern: string;\n  modifier: string;\n}\n\n/**\n * A token is a string (nothing special) or key metadata (capture group).\n */\nexport type Token = string | Key;\n\n/**\n * Pull out keys from a regexp.\n */\nfunction regexpToRegexp(path: RegExp, keys?: Key[]): RegExp {\n  if (!keys) return path;\n\n  const groupsRegex = /\\((?:\\?<(.*?)>)?(?!\\?)/g;\n\n  let index = 0;\n  let execResult = groupsRegex.exec(path.source);\n  while (execResult) {\n    keys.push({\n      // Use parenthesized substring match if available, index otherwise\n      name: execResult[1] || index++,\n      prefix: \"\",\n      suffix: \"\",\n      modifier: \"\",\n      pattern: \"\",\n    });\n    execResult = groupsRegex.exec(path.source);\n  }\n\n  return path;\n}\n\n/**\n * Transform an array into a regexp.\n */\nfunction arrayToRegexp(\n  paths: Array<string | RegExp>,\n  keys?: Key[],\n  options?: TokensToRegexpOptions & ParseOptions\n): RegExp {\n  const parts = paths.map((path) => pathToRegexp(path, keys, options).source);\n  return new RegExp(`(?:${parts.join(\"|\")})`, flags(options));\n}\n\n/**\n * Create a path regexp from string input.\n */\nfunction stringToRegexp(\n  path: string,\n  keys?: Key[],\n  options?: TokensToRegexpOptions & ParseOptions\n) {\n  return tokensToRegexp(parse(path, options), keys, options);\n}\n\nexport interface TokensToRegexpOptions {\n  /**\n   * When `true` the regexp will be case sensitive. (default: `false`)\n   */\n  sensitive?: boolean;\n  /**\n   * When `true` the regexp won't allow an optional trailing delimiter to match. (default: `false`)\n   */\n  strict?: boolean;\n  /**\n   * When `true` the regexp will match to the end of the string. (default: `true`)\n   */\n  end?: boolean;\n  /**\n   * When `true` the regexp will match from the beginning of the string. (default: `true`)\n   */\n  start?: boolean;\n  /**\n   * Sets the final character for non-ending optimistic matches. (default: `/`)\n   */\n  delimiter?: string;\n  /**\n   * List of characters that can also be \"end\" characters.\n   */\n  endsWith?: string;\n  /**\n   * Encode path tokens for use in the `RegExp`.\n   */\n  encode?: (value: string) => string;\n}\n\n/**\n * Expose a function for taking tokens and returning a RegExp.\n */\nexport function tokensToRegexp(\n  tokens: Token[],\n  keys?: Key[],\n  options: TokensToRegexpOptions = {}\n) {\n  const {\n    strict = false,\n    start = true,\n    end = true,\n    encode = (x: string) => x,\n    delimiter = \"/#?\",\n    endsWith = \"\",\n  } = options;\n  const endsWithRe = `[${escapeString(endsWith)}]|$`;\n  const delimiterRe = `[${escapeString(delimiter)}]`;\n  let route = start ? \"^\" : \"\";\n\n  // Iterate over the tokens and create our regexp string.\n  for (const token of tokens) {\n    if (typeof token === \"string\") {\n      route += escapeString(encode(token));\n    } else {\n      const prefix = escapeString(encode(token.prefix));\n      const suffix = escapeString(encode(token.suffix));\n\n      if (token.pattern) {\n        if (keys) keys.push(token);\n\n        if (prefix || suffix) {\n          if (token.modifier === \"+\" || token.modifier === \"*\") {\n            const mod = token.modifier === \"*\" ? \"?\" : \"\";\n            route += `(?:${prefix}((?:${token.pattern})(?:${suffix}${prefix}(?:${token.pattern}))*)${suffix})${mod}`;\n          } else {\n            route += `(?:${prefix}(${token.pattern})${suffix})${token.modifier}`;\n          }\n        } else {\n          if (token.modifier === \"+\" || token.modifier === \"*\") {\n            route += `((?:${token.pattern})${token.modifier})`;\n          } else {\n            route += `(${token.pattern})${token.modifier}`;\n          }\n        }\n      } else {\n        route += `(?:${prefix}${suffix})${token.modifier}`;\n      }\n    }\n  }\n\n  if (end) {\n    if (!strict) route += `${delimiterRe}?`;\n\n    route += !options.endsWith ? \"$\" : `(?=${endsWithRe})`;\n  } else {\n    const endToken = tokens[tokens.length - 1];\n    const isEndDelimited =\n      typeof endToken === \"string\"\n        ? delimiterRe.indexOf(endToken[endToken.length - 1]) > -1\n        : endToken === undefined;\n\n    if (!strict) {\n      route += `(?:${delimiterRe}(?=${endsWithRe}))?`;\n    }\n\n    if (!isEndDelimited) {\n      route += `(?=${delimiterRe}|${endsWithRe})`;\n    }\n  }\n\n  return new RegExp(route, flags(options));\n}\n\n/**\n * Supported `path-to-regexp` input types.\n */\nexport type Path = string | RegExp | Array<string | RegExp>;\n\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n */\nexport function pathToRegexp(\n  path: Path,\n  keys?: Key[],\n  options?: TokensToRegexpOptions & ParseOptions\n) {\n  if (path instanceof RegExp) return regexpToRegexp(path, keys);\n  if (Array.isArray(path)) return arrayToRegexp(path, keys, options);\n  return stringToRegexp(path, keys, options);\n}\n", "import { attach, createEffect, createEvent, createStore, split, Store } from \"effector\";\nimport {\n  RouteParams,\n  RouteParamsAndQuery,\n  RouteQuery,\n  RouteInstance,\n  NavigateParams,\n  Kind,\n  EmptyObject,\n} from \"../types\";\n\ntype CreateRouteParams = {\n  filter?: Store<boolean>;\n};\n\nexport function createRoute<Params extends RouteParams = {}>(\n  params: CreateRouteParams = {},\n): RouteInstance<Params> {\n  const navigateFx = createEffect<NavigateParams<Params>, NavigateParams<Params>>(\n    ({ params, query, replace = false }) => ({\n      params: params || {},\n      query: query || {},\n      replace,\n    }),\n  );\n\n  const openFx = attach({\n    effect: navigateFx,\n    mapParams: (params: Params extends EmptyObject ? void : Params) => ({\n      params: (params || {}) as Params,\n      query: {} as RouteQuery,\n    }),\n  });\n\n  const $isOpened = createStore<boolean>(false);\n  const $params = createStore<Params>({} as Params);\n  const $query = createStore<RouteQuery>({});\n\n  const opened = createEvent<RouteParamsAndQuery<Params>>();\n  const updated = createEvent<RouteParamsAndQuery<Params>>();\n  const closed = createEvent<void>();\n\n  $isOpened.on(opened, () => true).on(closed, () => false);\n\n  $params.on(opened, (_, { params }) => params).on(updated, (_, { params }) => params);\n\n  $query.on(opened, (_, { query }) => query).on(updated, (_, { query }) => query);\n\n  split({\n    source: navigateFx.doneData,\n    match: $isOpened.map((isOpened) => (isOpened ? \"updated\" : \"opened\")),\n    cases: {\n      opened,\n      updated,\n    },\n  });\n\n  // if (params.filter) {\n  //   const filter = params.filter;\n  //   split({\n  //     // @ts-expect-error\n  //     source: sample({ clock: filter }),\n  //     // @ts-expect-error\n  //     match: (filter) => (filter ? 'true' : 'false'),\n  //     cases: {\n  //       true: opened,\n  //       false: closed,\n  //     },\n  //   });\n  // }\n\n  const instance: RouteInstance<Params> = {\n    $isOpened,\n    $params,\n    $query,\n    opened,\n    updated,\n    closed,\n    navigate: navigateFx,\n    open: openFx,\n    kind: Kind.ROUTE,\n    // @ts-expect-error Internal stuff\n    settings: {\n      derived: Boolean(params.filter),\n    },\n  };\n\n  return instance;\n}\n", "export function paramsEqual(a: Record<string, any>, b: Record<string, any>) {\n  if (Object.keys(a).length !== Object.keys(b).length) {\n    return false;\n  }\n  for (const k in a) {\n    // NOTE: Parsed URI always returns string parameters\n    // so we force string comparison here\n    // in order to avoid extra updates\n    // whenever user passes numeric params\n    if (`${a[k]}` !== `${b[k]}`) {\n      return false;\n    }\n  }\n  return true;\n}\n", "import { createEvent, createStore, type EventCallable, type StoreWritable } from \"effector\";\n\nimport type { RouteQuery } from \"../types\";\nimport { paramsEqual } from \"../lib/equals\";\n\ninterface RouterControls {\n  $query: StoreWritable<RouteQuery>;\n  back: EventCallable<void>;\n  forward: EventCallable<void>;\n}\n\nexport function createRouterControls(): RouterControls {\n  return {\n    $query: createStore({}, { updateFilter: (update, current) => !paramsEqual(current, update) }),\n    back: createEvent(),\n    forward: createEvent(),\n  };\n}\n", "import { match, compile } from \"path-to-regexp\";\n\nimport type { RouteParams, PathCreator, RouteQuery, ParamsSerializer } from \"../types\";\n\n// NOTE: If path is URL - provide it as is\n// Otherwise - extract pathname and hash\nconst getComparablePath = (path: string) => {\n  if (path.match(/^[a-z0-9]+\\:\\/\\//i)) {\n    return path;\n  }\n  const url = new URL(`http://_${path}`);\n  return [url.pathname, url.hash].join(\"\");\n};\n\n// NOTE: path-to-regexp treats \":\" in \"https://\" as param start\n// So we escape it\nfunction normalizePathCreator(pathCreator: string) {\n  return pathCreator.replace(\"://\", \"\\\\://\");\n}\n\ntype BuildPathParams<Params extends RouteParams> = {\n  pathCreator: PathCreator<Params>;\n  params: Params;\n  query: RouteQuery;\n  serialize?: ParamsSerializer;\n};\nexport function buildPath<Params extends RouteParams>({\n  pathCreator,\n  params,\n  query,\n  serialize,\n}: BuildPathParams<Params>) {\n  const pathname = compile(pathCreator)(params);\n  const serializedParams = serialize?.write(query) ?? new URLSearchParams(query);\n  const qs = Object.keys(query).length ? `?${serializedParams}` : \"\";\n  const url = `${pathname}${qs}`;\n  return url;\n}\n\ntype MatchPathParams<Params extends RouteParams> = {\n  pathCreator: PathCreator<Params>;\n  actualPath: string;\n};\nexport function matchPath<Params extends RouteParams>({\n  pathCreator,\n  actualPath,\n}: MatchPathParams<Params>) {\n  const matches = match(normalizePathCreator(pathCreator))(getComparablePath(actualPath));\n  if (matches) {\n    return { matches: true, params: matches.params } as const;\n  }\n  return { matches: false } as const;\n}\n", "import { Kind, RouteInstance, RouteInstanceInternal } from \"../types\";\n\n/** Detects whether passed value is a `RouteInstance<any>` or not */\nexport function isRoute(route: RouteInstance<any> | unknown): route is RouteInstance<any> {\n  return (\n    typeof route === \"object\" && route !== null && \"kind\" in route && route.kind === Kind.ROUTE\n  );\n}\n\nexport function isRouteInternal(\n  route: RouteInstanceInternal<any> | unknown,\n): route is RouteInstanceInternal<any> {\n  return isRoute(route);\n}\n", "import { History } from \"history\";\nimport { createEffect } from \"effector\";\n\nimport { HistoryBackForwardParams, HistoryPushParams } from \"../types\";\n\nfunction assertHistory(history: History) {\n  if (!history) {\n    throw new Error(\"[Atomic-Router] No history provided\");\n  }\n}\n\nexport const historyPushFx = createEffect((params: HistoryPushParams) => {\n  assertHistory(params.history);\n  params.history[params.method](params.path, {});\n  return params;\n});\n\nexport const historyBackFx = createEffect((history: HistoryBackForwardParams) => {\n  assertHistory(history);\n  history.back();\n  return history;\n});\n\nexport const historyForwardFx = createEffect((history: HistoryBackForwardParams) => {\n  assertHistory(history);\n  history.forward();\n  return history;\n});\n", "import { Store } from \"effector\";\n\nexport function not<T>(source: Store<T>): Store<boolean> {\n  return source.map((value) => !value);\n}\n", "import { History } from \"history\";\nimport { attach, combine, createEvent, createStore, sample, scopeBind } from \"effector\";\nimport { createRouterControls } from \"./create-router-controls\";\nimport {\n  HistoryPushParams,\n  ParamsSerializer,\n  RouteInstance,\n  RouteObject,\n  RouteParams,\n  RouteQuery,\n  UnmappedRouteObject,\n} from \"../types\";\nimport { remapRouteObjects } from \"../lib/remap-route-objects\";\nimport { paramsEqual } from \"../lib/equals\";\nimport { buildPath, matchPath } from \"../lib/build-path\";\nimport { isRouteInternal } from \"./is-route\";\nimport { historyBackFx, historyForwardFx, historyPushFx } from \"../lib/history-effects\";\nimport { not } from \"../lib/logic\";\n\nexport function createHistoryRouter({\n  base,\n  routes,\n  notFoundRoute,\n  hydrate,\n  serialize,\n  controls = createRouterControls(),\n}: {\n  base?: string;\n  routes: UnmappedRouteObject<any>[];\n  notFoundRoute?: RouteInstance<any>;\n  serialize?: ParamsSerializer;\n  hydrate?: boolean;\n  controls?: ReturnType<typeof createRouterControls>;\n}) {\n  const $hydrateMode = createStore(hydrate ?? false, {\n    /**\n     * It is explicitly set in the config and not as a Store,\n     * so value from config should be used at all times - we don't want to serialize this value\n     */\n    serialize: \"ignore\",\n  });\n  const remappedRoutes = remapRouteObjects(routes, base);\n\n  const setHistory = createEvent<History>();\n  const navigateFromRouteTriggered = createEvent<{\n    route: RouteObject<any>;\n    params: RouteParams;\n    query: RouteQuery;\n    replace: boolean;\n  }>();\n  const historyUpdated = createEvent();\n  const recalculateTriggered = createEvent<{\n    path: string;\n    query: RouteQuery;\n    hash: string;\n  }>();\n  const recalculated = createEvent<{\n    path: string;\n    query: RouteQuery;\n    matching: RecalculationResult<any>[];\n    mismatching: RecalculationResult<any>[];\n  }>();\n  const routesMatched = createEvent<RecalculationResult<any>[]>();\n  const routesMismatched = createEvent<RecalculationResult<any>[]>();\n  const routeNotFound = createEvent();\n  const initialized = createEvent<{\n    activeRoutes: RouteInstance<any>[];\n    path: string;\n    query: RouteQuery;\n  }>();\n\n  const $path = createStore(\"\");\n  const $query = createStore<RouteQuery>(\n    {},\n    {\n      name: \"historyRouter.$query\",\n      updateFilter: (newQuery, oldQuery) => !paramsEqual(newQuery, oldQuery),\n    },\n  );\n  const $activeRoutes = createStore<RouteInstance<any>[]>([], {\n    serialize: \"ignore\",\n  });\n  // @ts-expect-error\n  const $history = createStore<History>(null, {\n    serialize: \"ignore\",\n  });\n  const $isFirstCheckPassed = createStore(false);\n  const $isRouteNavigateInProgress = createStore(false);\n\n  const pushFx = attach({\n    source: $history,\n    effect(history, params: Omit<HistoryPushParams, \"history\">) {\n      return historyPushFx({\n        history,\n        ...params,\n      });\n    },\n  });\n\n  const subscribeHistoryFx = attach({\n    source: $history,\n    effect(history) {\n      let scopedHistoryUpdated = historyUpdated;\n      try {\n        // @ts-expect-error\n        scopedHistoryUpdated = scopeBind(historyUpdated);\n      } catch (err) {}\n      history.listen(() => {\n        scopedHistoryUpdated();\n      });\n      return true;\n    },\n  });\n\n  const historyUpdatedParsed = sample({\n    clock: hydrate ? [historyUpdated] : [historyUpdated, subscribeHistoryFx.done],\n    source: $history,\n    filter: Boolean,\n    fn: (history) => ({\n      path: history.location.pathname,\n      query:\n        serialize?.read(history.location.search) ??\n        Object.fromEntries(new URLSearchParams(history.location.search)),\n    }),\n  });\n\n  // If `hydrate` flag is set,\n  // don't trigger recheck on history init\n  const historyUpdateTriggered = sample({\n    clock: historyUpdatedParsed,\n    source: {\n      path: $path,\n      query: $query,\n    },\n    filter: ({ path: savedPath, query: savedQuery }, history) =>\n      history.path !== savedPath || !paramsEqual(history.query, savedQuery),\n    fn: (_, history) => history,\n  });\n\n  /// History subscription\n  $history.on(setHistory, (_, history) => history);\n\n  sample({\n    clock: $history,\n    target: subscribeHistoryFx,\n  });\n\n  sample({\n    clock: historyUpdateTriggered,\n    source: $history,\n    filter: Boolean,\n    fn(history) {\n      const path = history?.location.pathname;\n      const hash = history?.location.hash;\n      const query: RouteQuery =\n        serialize?.read(history?.location.search) ??\n        Object.fromEntries(new URLSearchParams(history?.location.search));\n      return { path, query, hash };\n    },\n    target: recalculateTriggered,\n  });\n\n  /// Routes updates handling\n  for (const routeObj of remappedRoutes) {\n    const currentRouteMatched = routesMatched.filterMap(containsCurrentRoute(routeObj));\n    const currentRouteMismatched = routesMismatched.filterMap(containsCurrentRoute(routeObj));\n    const routeStateChangeRequested = {\n      /**\n       * Special case:\n       * - Scope is initied from server data, route.$isOpened -> true\n       * - but `hydrate` flag is set to false\n       *\n       * So route.opened() should be called after router.setHistory anyway to respect that\n       */\n      initialized: sample({\n        clock: subscribeHistoryFx.done,\n        filter: combine(\n          routeObj.route.$isOpened,\n          $hydrateMode,\n          (isOpened, hydrateMode) => isOpened && !hydrateMode,\n        ),\n      }),\n      opened: sample({\n        clock: currentRouteMatched,\n        filter: not(routeObj.route.$isOpened),\n      }),\n      updated: sample({\n        clock: currentRouteMatched,\n        filter: routeObj.route.$isOpened,\n      }),\n      closed: sample({\n        clock: currentRouteMismatched,\n        filter: routeObj.route.$isOpened,\n      }),\n    };\n\n    /**\n     * Trigger .opened() for special case with scope being initialized from server data\n     */\n    sample({\n      clock: routeStateChangeRequested.initialized,\n      source: {\n        params: routeObj.route.$params,\n        query: routeObj.route.$query,\n      },\n      target: routeObj.route.opened,\n    });\n\n    // Trigger .updated() for the routes marked as \"matched\" but already opened\n    sample({\n      clock: routeStateChangeRequested.updated,\n      source: [routeObj.route.$params, routeObj.route.$query],\n      // Skip .updated() calls if params & query are the same\n      filter: ([params, query], next) =>\n        !paramsEqual(params, next.params) || !paramsEqual(query, next.query),\n      fn: (_, paramsAndQuery) => paramsAndQuery,\n      target: routeObj.route.updated,\n    });\n\n    // Trigger .opened() for the routes marked as \"matched\" but not opened yet\n    sample({\n      clock: routeStateChangeRequested.opened,\n      // TODO: Scratch this?\n      filter: not($isRouteNavigateInProgress),\n      target: routeObj.route.opened,\n    });\n\n    // Trigger .closed() for the routes marked as \"mismatched\" but opened\n    sample({\n      clock: routeStateChangeRequested.closed,\n      target: routeObj.route.closed,\n    });\n  }\n\n  /// Handling route.navigateFx navigation\n  for (const routeObj of remappedRoutes) {\n    // Run \"Handling route.navigateFx navigation\" step\n    sample({\n      clock: routeObj.route.navigate.doneData,\n      fn: ({ params, query, replace }) => ({\n        route: routeObj,\n        params,\n        query,\n        replace: replace ?? false,\n      }),\n      target: navigateFromRouteTriggered,\n    });\n  }\n\n  $isRouteNavigateInProgress.on(navigateFromRouteTriggered, () => true);\n\n  sample({\n    clock: navigateFromRouteTriggered,\n    fn({ route, params, query, replace }) {\n      const path = buildPath({\n        pathCreator: route.path,\n        params,\n        query,\n        serialize,\n      });\n      const method: \"replace\" | \"push\" = replace ? \"replace\" : \"push\";\n      return {\n        path,\n        params,\n        query,\n        method,\n      };\n    },\n    target: pushFx,\n  });\n\n  $isRouteNavigateInProgress.reset([routesMatched, routesMismatched]);\n\n  /// Recalculation\n  // Triggered on every history change + once when history instance is set\n  sample({\n    clock: recalculateTriggered,\n    fn({ path, query, hash }) {\n      const matchingRoutes = [] as RecalculationResult<any>[];\n      const mismatchingRoutes = [] as RecalculationResult<any>[];\n\n      for (const route of remappedRoutes) {\n        // NOTE: Use hash string as well if route.path contains #\n        const actualPath = route.path.includes(\"#\") ? `${path}${hash}` : `${path}`;\n        const { matches, params } = matchPath({\n          pathCreator: route.path,\n          actualPath,\n        });\n\n        const suitableRoutes = matches ? matchingRoutes : mismatchingRoutes;\n        suitableRoutes.push({\n          routeObj: route,\n          params,\n          query,\n        });\n      }\n\n      // Checking for routes we need to close\n      // Remove all that are marked to be opened\n      mismatchingRoutes.forEach((mismatchedRoute, mismatchedIndex) => {\n        const mismatchedRouteExistsInMatchedList = matchingRoutes.some(\n          (matchedRoute) => matchedRoute.routeObj.route === mismatchedRoute.routeObj.route,\n        );\n        if (mismatchedRouteExistsInMatchedList) {\n          mismatchingRoutes.splice(mismatchedIndex, 1);\n        }\n      });\n\n      return {\n        matching: matchingRoutes,\n        mismatching: mismatchingRoutes.filter(Boolean),\n        path,\n        query,\n      };\n    },\n    target: recalculated,\n  });\n\n  $path.on(historyUpdateTriggered, (_, { path }) => path);\n\n  $query.on(historyUpdateTriggered, (_, { query }) => query);\n\n  const matchingRecalculated = recalculated.map(({ matching }) => matching);\n\n  sample({\n    clock: matchingRecalculated,\n    filter: (routes) => routes.length > 0,\n    target: routesMatched,\n  });\n\n  sample({\n    clock: recalculated.map(({ mismatching }) => mismatching),\n    filter: (routes) => routes.length > 0,\n    target: routesMismatched,\n  });\n\n  $activeRoutes.on(recalculated, (_, { matching }) =>\n    matching.map((recheckResult) => recheckResult.routeObj.route),\n  );\n\n  /// Handling 404\n  sample({\n    clock: matchingRecalculated,\n    filter: (routes) => routes.length === 0,\n    target: routeNotFound,\n  });\n\n  if (isRouteInternal(notFoundRoute)) {\n    sample({\n      clock: routeNotFound,\n      source: $query,\n      filter: notFoundRoute.$isOpened,\n      fn: (query) => ({ query, params: {} }),\n      target: notFoundRoute.updated,\n    });\n\n    sample({\n      clock: routeNotFound,\n      source: { query: $query, isOpened: notFoundRoute.$isOpened },\n      filter: ({ isOpened }) => !isOpened,\n      fn: ({ query }) => ({ query, params: {} }),\n      target: notFoundRoute.opened,\n    });\n\n    sample({\n      clock: matchingRecalculated,\n      source: notFoundRoute.$isOpened,\n      filter: (isOpened, matching) => isOpened && matching.length > 0,\n      target: notFoundRoute.closed,\n    });\n  }\n\n  /// Back/forward navigation\n  sample({\n    clock: controls.back,\n    source: $history,\n    target: historyBackFx,\n  });\n\n  sample({\n    clock: controls.forward,\n    source: $history,\n    target: historyForwardFx,\n  });\n\n  /// Query syncing\n  sample({\n    clock: $query,\n    source: { controlsQuery: controls.$query, localQuery: $query },\n    filter: ({ controlsQuery, localQuery }) => !paramsEqual(controlsQuery, localQuery),\n    fn: ({ localQuery }) => localQuery,\n    target: controls.$query,\n  });\n\n  sample({\n    clock: controls.$query,\n    source: {\n      path: $path,\n      localQuery: $query,\n      isNavigateInProgress: $isRouteNavigateInProgress,\n      realHistory: $history,\n    },\n    filter: ({ localQuery, isNavigateInProgress, realHistory }, query) => {\n      const realQuery =\n        serialize?.read(realHistory?.location.search ?? \"\") ??\n        Object.fromEntries(new URLSearchParams(realHistory?.location.search ?? \"\"));\n      return (\n        isNavigateInProgress || !paramsEqual(query, realQuery) || !paramsEqual(localQuery, query)\n      );\n    },\n    fn({ path }, query) {\n      const qs = serialize?.write(query) ?? new URLSearchParams(query);\n      return {\n        path: `${path}${qs ? `?${qs}` : \"\"}`,\n        params: {},\n        query: query,\n        method: \"push\" as const,\n      };\n    },\n    target: pushFx,\n  });\n\n  /// Initialization\n  sample({\n    clock: recalculated,\n    source: {\n      activeRoutes: $activeRoutes,\n      path: $path,\n      query: $query,\n    },\n    filter: $isFirstCheckPassed.map((isFirstCheckPassed) => !isFirstCheckPassed),\n    target: initialized,\n  });\n\n  $isFirstCheckPassed.on(initialized, () => true).reset($history);\n\n  return {\n    $path,\n    $activeRoutes,\n    $history,\n    setHistory,\n    $query: $query,\n    back: controls.back,\n    forward: controls.forward,\n    push: pushFx,\n    routes: remappedRoutes,\n    initialized,\n    routeNotFound,\n  };\n}\n\ntype RecalculationResult<Params extends RouteParams> = {\n  routeObj: RouteObject<Params>;\n  params: Params;\n  query: RouteQuery;\n};\n\nconst containsCurrentRoute =\n  (routeObj: RouteObject<any>) => (recheckResults: RecalculationResult<any>[]) => {\n    const recheck = recheckResults.find(\n      (recheckResult) => recheckResult.routeObj.route === routeObj.route,\n    );\n    if (!recheck) {\n      return;\n    }\n    return {\n      params: recheck.params,\n      query: recheck.query,\n    };\n  };\n", "import { UnmappedRouteObject, RouteObject, RouteObjectInternal } from \"../types\";\n\nexport function remapRouteObjects(objects: UnmappedRouteObject<any>[], basePath: string = \"\") {\n  let next: RouteObject<any>[] = [];\n\n  for (const routeObj of objects) {\n    if (Array.isArray(routeObj.route)) {\n      next.push(...routeObj.route.map((route) => ({ ...routeObj, route })));\n    } else {\n      // @ts-expect-error\n      next.push(routeObj);\n    }\n  }\n\n  next = next.map((routeObj) => ({\n    ...routeObj,\n    path: `${basePath}${routeObj.path}`,\n  }));\n\n  const derivedRoutes: RouteObject<any>[] = [];\n  const nonDerivedRoutes: RouteObjectInternal<any>[] = [];\n\n  for (const routeObj of next) {\n    // @ts-expect-error Internals\n    if (routeObj.route.settings.derived) {\n      derivedRoutes.push(routeObj);\n    } else {\n      nonDerivedRoutes.push(routeObj as RouteObjectInternal<any>);\n    }\n  }\n\n  if (derivedRoutes.length) {\n    for (const derivedRoute of derivedRoutes) {\n      console.error(\n        `[Atomic-Router]: createHistoryRouter: ${derivedRoute.path} uses derived route. This won't work`,\n      );\n    }\n  }\n\n  return nonDerivedRoutes;\n}\n", "import { Clock, createEvent, createStore, Event, is, sample, Store } from \"effector\";\nimport { EmptyObject, RouteInstance, RouteParams, RouteQuery } from \"../types\";\n\ntype RedirectParams<T, Params extends RouteParams> = Params extends EmptyObject\n  ? {\n      clock?: Clock<T>;\n      route: RouteInstance<Params>;\n      query?: ((clock: T) => RouteQuery) | Store<RouteQuery> | RouteQuery;\n      replace?: ((clock: T) => boolean) | Store<boolean> | boolean;\n    }\n  :\n      | {\n          clock?: Clock<T>;\n          route: RouteInstance<Params>;\n          params: ((clock: T) => Params) | Store<Params> | Params;\n          query?: ((clock: T) => RouteQuery) | Store<RouteQuery> | RouteQuery;\n          replace?: ((clock: T) => boolean) | Store<boolean> | boolean;\n        }\n      | {\n          clock?: Clock<{\n            params: Params;\n            query?: RouteQuery;\n            replace?: boolean;\n          }>;\n          route: RouteInstance<Params>;\n          params?: ((clock: T) => Params) | Store<Params> | Params;\n          query?: ((clock: T) => RouteQuery) | Store<RouteQuery> | RouteQuery;\n          replace?: ((clock: T) => boolean) | Store<boolean> | boolean;\n        };\n\n/** Opens passed `route` upon `clock` trigger */\nexport function redirect<T, Params extends RouteParams>(options: RedirectParams<T, Params>) {\n  const clock: Event<T> = options.clock\n    ? sample({ clock: options.clock as Event<T> })\n    : createEvent<T>();\n\n  const params = toStore(options.params || {});\n  const query = toStore(options.query || {});\n  const replace = toStore(options.replace || false);\n\n  sample({\n    clock: clock,\n    source: { params, query, replace },\n    fn: ({ params, query, replace }, clock) => ({\n      params: typeof params === \"function\" ? params(clock) : params,\n      query: typeof query === \"function\" ? query(clock) : query,\n      replace: typeof replace === \"function\" ? replace(clock) : replace,\n    }),\n    target: options.route.navigate,\n  });\n\n  return clock;\n}\n\nfunction toStore<T>(payload: T | Store<T>): Store<T> {\n  return is.store(payload) ? payload : createStore(payload as T);\n}\n", "import {\n  is,\n  merge,\n  sample,\n  combine,\n  createStore,\n  Unit,\n  Clock,\n  Effect,\n  StoreValue,\n  createEvent,\n  NoInfer,\n  EffectParams,\n  attach,\n  UnitTargetable,\n} from \"effector\";\n\nimport { createRoute } from \"./create-route\";\nimport {\n  RouteInstance,\n  RouteInstanceInternal,\n  RouteParams,\n  RouteParamsAndQuery,\n  RouteQuery,\n} from \"../types\";\n\nimport { isRouteInternal } from \"./is-route\";\n\ntype ChainRouteParamsInternalAttach<\n  Params extends RouteParams,\n  FX extends Effect<any, any, any>,\n> = {\n  route: RouteInstance<Params>;\n  chainedRoute?: RouteInstance<Params>;\n  beforeOpen: {\n    effect: FX;\n    mapParams: ({\n      params,\n      query,\n    }: {\n      params: Params;\n      query: RouteQuery;\n    }) => NoInfer<EffectParams<FX>>;\n  };\n  openOn?: Clock<any>;\n  cancelOn?: Clock<any>;\n};\n\ntype ChainRouteParamsWithEffect<Params extends RouteParams> = {\n  route: RouteInstance<Params>;\n  chainedRoute?: RouteInstance<Params>;\n  beforeOpen: Effect<RouteParamsAndQuery<Params>, any, any>;\n};\n\ntype ChainRouteParamsAdvanced<Params extends RouteParams> = {\n  route: RouteInstance<Params>;\n  chainedRoute?: RouteInstance<Params>;\n  beforeOpen: Clock<RouteParamsAndQuery<Params>>;\n  openOn: Clock<any>;\n  cancelOn?: Clock<any>;\n};\n\ntype ChainRouteParams<Params extends RouteParams, FX extends Effect<any, any, any>> =\n  | RouteInstance<Params>\n  | ChainRouteParamsWithEffect<Params>\n  | ChainRouteParamsAdvanced<Params>\n  | ChainRouteParamsInternalAttach<Params, FX>;\n\nfunction chainRoute<Params extends RouteParams>(\n  instance: RouteInstance<Params>,\n): RouteInstance<Params>;\n\nfunction chainRoute<Params extends RouteParams>(\n  config: ChainRouteParamsWithEffect<Params>,\n): RouteInstance<Params>;\n\nfunction chainRoute<Params extends RouteParams>(\n  config: ChainRouteParamsAdvanced<Params>,\n): RouteInstance<Params>;\n\nfunction chainRoute<Params extends RouteParams, FX extends Effect<any, any, any>>(\n  config: ChainRouteParamsInternalAttach<Params, FX>,\n): RouteInstance<Params>;\n\n/**\n * Creates chained route\n * @link https://github.com/Kelin2025/atomic-router/issues/10\n * @param {RouteInstance<any>} params.route - Route to listen\n * @param {RouteInstance<any>} [params.chainedRoute]  - Route to be created\n * @param {Clock<any>} params.beforeOpen - Will be triggered when `params.route` open\n * @param {Clock<any>} params.openOn - Will open `chainedRoute` if `params.route` is still opened\n * @param {Clock<any>} params.cancelOn - Cancels chain\n * @returns {RouteInstance<any>} `chainedRoute`\n */\nfunction chainRoute<Params extends RouteParams, FX extends Effect<any, any, any>>(\n  params: ChainRouteParams<Params, FX>,\n) {\n  const { route, chainedRoute, beforeOpen, openOn, cancelOn } = normalizeChainRouteParams(params);\n  const $params = createStore({} as StoreValue<(typeof route)[\"$params\"]>);\n  const $query = createStore({} as StoreValue<(typeof route)[\"$query\"]>);\n  const $hasSameParams = combine(\n    combine([route.$params, route.$query]),\n    combine([$params, $query]),\n    (current, stored) => {\n      return current[0] === stored[0] && current[1] === stored[1];\n    },\n  );\n  const routeTriggered = sample({ clock: [route.opened, route.updated] });\n\n  // 1. Call `beforeOpen` whenever route is opened\n  sample({\n    clock: routeTriggered,\n    target: beforeOpen as UnitTargetable<RouteParamsAndQuery<any>>,\n  });\n\n  $params.on(routeTriggered, (_prev, { params }) => params);\n  $query.on(routeTriggered, (_prev, { query }) => query);\n\n  // 2. Listen to `openOn` if route is still opened on the same position\n  sample({\n    clock: openOn as Unit<any>,\n    source: { params: $params, query: $query },\n    filter: $hasSameParams,\n    target: chainedRoute.navigate,\n  });\n\n  // 4. Cancel loading if page closed or `cancelOn` is called\n  // @ts-expect-error\n  const aborted = merge([route.closed, cancelOn]);\n\n  $params.reset(aborted);\n  $query.reset(aborted);\n\n  sample({\n    clock: aborted,\n    target: chainedRoute.closed,\n  });\n\n  return chainedRoute;\n}\n\n// This is written separately to correctly export all type overloads\nexport { chainRoute };\n\ntype ChainRouteParamsNormalized<Params extends RouteParams> = {\n  route: RouteInstanceInternal<Params>;\n  chainedRoute: RouteInstanceInternal<Params>;\n  beforeOpen: Clock<RouteParamsAndQuery<Params>>;\n  openOn: Clock<any>;\n  cancelOn: Clock<any>;\n};\n\nfunction normalizeChainRouteParams<Params extends RouteParams, FX extends Effect<any, any, any>>(\n  params: ChainRouteParams<Params, FX>,\n): ChainRouteParamsNormalized<Params> {\n  const resultParams: ChainRouteParamsNormalized<Params> = {} as ChainRouteParamsNormalized<Params>;\n\n  if (isRouteInternal(params)) {\n    Object.assign(resultParams, {\n      route: params,\n      chainedRoute: createRoute<Params>(),\n      beforeOpen: createEvent(),\n      openOn: merge([params.opened, params.closed]),\n      cancelOn: merge([]),\n    });\n    return resultParams;\n  }\n  const effectParams = params as ChainRouteParamsWithEffect<Params>;\n  Object.assign(resultParams, {\n    route: effectParams.route,\n    chainedRoute: effectParams.chainedRoute || createRoute<Params>(),\n    beforeOpen: is.unit(effectParams.beforeOpen)\n      ? effectParams.beforeOpen\n      : attach(effectParams.beforeOpen),\n  });\n  if (is.effect(resultParams.beforeOpen as Unit<any>)) {\n    Object.assign(resultParams, {\n      openOn:\n        // @ts-expect-error\n        effectParams.openOn || resultParams.beforeOpen.doneData,\n      cancelOn:\n        // @ts-expect-error\n        effectParams.cancelOn || resultParams.beforeOpen.failData,\n    });\n    return resultParams;\n  }\n  const advancedParams = params as ChainRouteParamsAdvanced<Params>;\n  Object.assign(resultParams, {\n    openOn: sample({ clock: advancedParams.openOn as Unit<any> }),\n    cancelOn: sample({\n      clock: (advancedParams.cancelOn as Unit<any>) || createEvent(),\n    }),\n  });\n  return resultParams;\n}\n", "import { Clock, combine, createStore, sample, Store, Unit } from \"effector\";\n\nimport { RouteInstance, RouteQuery } from \"../types\";\nimport { createRouterControls } from \"./create-router-controls\";\n\ntype QueryCleanupStrategy = {\n  irrelevant: boolean;\n  empty: boolean;\n  preserve: string[];\n};\n\ntype QuerySyncParams<T extends Record<string, Store<any>>> = {\n  source: T;\n  clock?: Clock<any>;\n  controls: ReturnType<typeof createRouterControls>;\n  route?: RouteInstance<any>;\n  cleanup?: boolean | Partial<QueryCleanupStrategy>;\n};\n\nexport function querySync<T extends Record<string, Store<any>>>(params: QuerySyncParams<T>) {\n  const $isOpened = params.route?.$isOpened ?? createStore(true);\n  const $source = combine(params.source);\n  const clock = (params.clock ?? $source) as Unit<any>;\n  const cleanupStrategy = !(\"cleanup\" in params)\n    ? cleanupStrategies.default\n    : typeof params.cleanup === \"boolean\"\n      ? cleanupStrategies[params.cleanup ? \"all\" : \"none\"]\n      : { ...cleanupStrategies.default, ...params.cleanup! };\n\n  const queryUpdatedFromHistory = sample({\n    clock: params.controls.$query,\n    filter: $isOpened,\n  });\n\n  sample({\n    clock,\n    source: combine([$source, params.controls.$query]),\n    filter: $isOpened,\n    fn: ([source, currentQuery]) => {\n      let nextQuery: RouteQuery = {};\n      if (cleanupStrategy.irrelevant) {\n        for (const key of cleanupStrategy.preserve) {\n          if (key in currentQuery) {\n            nextQuery[key] = currentQuery[key];\n          }\n        }\n      } else {\n        nextQuery = { ...currentQuery };\n      }\n      for (const key in source) {\n        nextQuery[key] = source[key];\n      }\n      if (cleanupStrategy.empty) {\n        for (const key in source) {\n          if (!cleanupStrategy.preserve.includes(key) && !nextQuery[key]) {\n            delete nextQuery[key];\n          }\n        }\n      }\n      return nextQuery as RouteQuery;\n    },\n    target: params.controls.$query,\n  });\n\n  for (const k in params.source) {\n    const $queryParam = params.source[k as keyof typeof params.source];\n    // @ts-expect-error\n    $queryParam.on(queryUpdatedFromHistory, (_, query) => {\n      return query[k] ?? $queryParam.defaultState;\n    });\n  }\n}\n\nconst cleanupStrategies = {\n  all: {\n    irrelevant: true,\n    empty: true,\n    preserve: [],\n  },\n  default: {\n    irrelevant: false,\n    empty: true,\n    preserve: [],\n  },\n  none: {\n    irrelevant: false,\n    empty: false,\n    preserve: [],\n  },\n};\n", "import { History } from \"history\";\nimport { Effect, Store, Event, EventCallable } from \"effector\";\n\nexport type RouteParams = Record<string, any>;\n\nexport type RouteQuery = Record<string, any>;\n\nexport type RouteParamsAndQuery<Params extends RouteParams> = {\n  params: Params;\n  query: RouteQuery;\n};\n\nexport interface NavigateParams<Params extends RouteParams> extends RouteParamsAndQuery<Params> {\n  replace?: boolean;\n}\n\nexport type RouteInstance<Params extends RouteParams> = {\n  $isOpened: Store<boolean>;\n  $params: Store<Params>;\n  $query: Store<RouteQuery>;\n  opened: Event<RouteParamsAndQuery<Params>>;\n  updated: Event<RouteParamsAndQuery<Params>>;\n  closed: Event<void>;\n  navigate: Effect<NavigateParams<Params>, NavigateParams<Params>>;\n  open: Effect<Params extends EmptyObject ? void : Params, RouteParamsAndQuery<Params>>;\n  kind: typeof Kind.ROUTE;\n};\n\nexport interface RouteInstanceInternal<Params extends RouteParams> extends RouteInstance<Params> {\n  opened: EventCallable<RouteParamsAndQuery<Params>>;\n  updated: EventCallable<RouteParamsAndQuery<Params>>;\n  closed: EventCallable<void>;\n}\n\nexport type RouteObject<Params extends RouteParams> = {\n  route: RouteInstance<Params>;\n  path: string;\n};\n\nexport interface RouteObjectInternal<Params extends RouteParams> extends RouteObject<Params> {\n  route: RouteInstanceInternal<Params>;\n}\n\nexport type UnmappedRouteObject<Params extends RouteParams> = {\n  route: RouteInstance<Params> | RouteInstance<Params>[];\n  path: string;\n};\n\nexport type HistoryPushParams = {\n  history: History;\n  path: string;\n  params: RouteParams;\n  query: RouteQuery;\n  method: \"replace\" | \"push\";\n};\n\nexport type HistoryBackForwardParams = History;\n\nexport type ParamsSerializer = {\n  write: (params: RouteParams) => string;\n  read: (query: string) => RouteParams;\n};\n\n// @ts-expect-error 'Params' is declared but its value is never read. ts(6133)\nexport type PathCreator<Params extends RouteParams> = string;\n\nexport const Kind = {\n  ROUTE: Symbol(),\n};\n\nexport type EmptyObject = { [key in string]: never };\n"],
  "mappings": "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",
  "names": ["i", "j", "value", "_a", "result", "x", "m", "createRoute", "params", "navigateFx", "createEffect", "_ref", "_ref$replace", "replace", "query", "name", "sid", "openFx", "attach", "and", "effect", "mapParams", "or", "$isOpened", "createStore", "$params", "$query", "opened", "createEvent", "updated", "closed", "on", "_", "_ref2", "_ref3", "_ref4", "_ref5", "split", "source", "doneData", "match", "map", "isOpened", "cases", "navigate", "open", "kind", "Kind", "ROUTE", "settings", "derived", "Boolean", "filter", "e", "r", "a", "o", "t", "n", "paramsEqual", "b", "Object", "keys", "length", "k", "createRouterControls", "updateFilter", "update", "current", "back", "forward", "buildPath", "_serialize$write", "serialize", "pathname", "compile", "pathCreator", "serializedParams", "write", "URLSearchParams", "matchPath", "actualPath", "matches", "getComparablePath", "isRoute", "route", "isRouteInternal", "assertHistory", "history", "Error", "not", "value", "createHistoryRouter", "base", "routes", "notFoundRoute", "hydrate", "_ref$controls", "controls", "_withFactory", "\"-eby7\"", "fn", "\"controls\"", "method", "\"createRouterControls\"", "$hydrateMode", "remappedRoutes", "objects", "basePath", "_step", "next", "_loop", "_next", "routeObj", "Array", "isArray", "push", "apply", "_objectSpread", "_iterator", "_createForOfIteratorHelperLoose", "done", "path", "_step2", "derivedRoutes", "nonDerivedRoutes", "_iterator2", "_step3", "_iterator3", "console", "error", "setHistory", "navigateFromRouteTriggered", "historyUpdated", "recalculateTriggered", "recalculated", "routesMatched", "routesMismatched", "routeNotFound", "initialized", "$path", "newQuery", "oldQuery", "$activeRoutes", "$history", "$isFirstCheckPassed", "$isRouteNavigateInProgress", "pushFx", "historyPushFx", "subscribeHistoryFx", "scopedHistoryUpdated", "scopeBind", "err", "listen", "historyUpdatedParsed", "sample", "clock", "_serialize$read", "location", "read", "search", "fromEntries", "historyUpdateTriggered", "target", "_serialize$read2", "hash", "currentRouteMatched", "filterMap", "containsCurrentRoute", "currentRouteMismatched", "routeStateChangeRequested", "combine", "hydrateMode", "_ref16", "paramsAndQuery", "_ref17", "reset", "matchingRoutes", "mismatchingRoutes", "includes", "_matchPath", "forEach", "mismatchedRoute", "mismatchedIndex", "some", "matchedRoute", "splice", "matching", "mismatching", "_ref6", "matchingRecalculated", "_ref7", "_ref8", "_ref9", "recheckResult", "\"-dp1wu2\"", "\"none\"", "\"isRouteInternal\"", "_ref10", "_ref11", "historyBackFx", "historyForwardFx", "controlsQuery", "localQuery", "_ref12", "_ref13", "isNavigateInProgress", "realHistory", "_ref14", "_serialize$read3", "_realHistory$location", "_realHistory$location2", "realQuery", "_ref15", "qs", "activeRoutes", "isFirstCheckPassed", "redirect", "options", "toStore", "payload", "is", "store", "chainRoute", "_normalizeChainRouteP", "resultParams", "\"-oimir7\"", "assign", "chainedRoute", "\"nxhp9m\"", "\"chainedRoute\"", "\"createRoute\"", "beforeOpen", "openOn", "merge", "cancelOn", "effectParams", "\"-wf80u2\"", "unit", "failData", "advancedParams", "$hasSameParams", "stored", "routeTriggered", "_prev", "aborted", "querySync", "_params$route$$isOpen", "_params$route", "_params$clock", "$source", "cleanupStrategy", "cleanup", "cleanupStrategies", "queryUpdatedFromHistory", "currentQuery", "nextQuery", "irrelevant", "preserve", "key", "empty", "$queryParam", "_query$k", "defaultState", "Symbol", "url", "URL", "join", "recheckResults", "recheck", "find", "all", "default", "none"]
}
