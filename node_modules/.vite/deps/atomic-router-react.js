import {
  c
} from "./chunk-42QUQ6HZ.js";
import {
  require_jsx_runtime
} from "./chunk-CTRIHH5C.js";
import {
  require_react
} from "./chunk-2EXEP7CN.js";
import {
  d
} from "./chunk-ZFRNUVTJ.js";
import {
  ke
} from "./chunk-6YLY4OPZ.js";
import {
  __toESM
} from "./chunk-WXXH56N5.js";

// node_modules/atomic-router-react/dist/atomic-router.mjs
var import_react = __toESM(require_react(), 1);
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it)
    return (it = it.call(o)).next.bind(it);
  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it)
      o = it;
    var i = 0;
    return function() {
      if (i >= o.length)
        return {
          done: true
        };
      return {
        done: false,
        value: o[i++]
      };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function r(e) {
  var t, f, n = "";
  if ("string" == typeof e || "number" == typeof e)
    n += e;
  else if ("object" == typeof e)
    if (Array.isArray(e))
      for (t = 0; t < e.length; t++)
        e[t] && (f = r(e[t])) && (n && (n += " "), n += f);
    else
      for (t in e)
        e[t] && (n && (n += " "), n += t);
  return n;
}
function clsx() {
  for (var e, t, f = 0, n = ""; f < arguments.length; )
    (e = arguments[f++]) && (t = r(e)) && (n && (n += " "), n += t);
  return n;
}
var RouterContext = (0, import_react.createContext)(null);
function RouterProvider(_ref) {
  var router = _ref.router, children = _ref.children;
  return (0, import_jsx_runtime.jsx)(RouterContext.Provider, {
    value: router,
    children
  });
}
function useRouter() {
  return (0, import_react.useContext)(RouterContext);
}
var _excluded = ["to", "params", "query", "activeClassName", "inactiveClassName"];
var _excluded2 = ["to", "params", "query", "className", "activeClassName", "inactiveClassName", "onClick", "children", "target"];
var LinkView = function LinkView2(props, ref) {
  props.to;
  props.params;
  props.query;
  props.activeClassName;
  props.inactiveClassName;
  var linkProps = _objectWithoutPropertiesLoose(props, _excluded);
  if (typeof props.to === "string") {
    return (0, import_jsx_runtime.jsx)(NormalLink, _objectSpread2(_objectSpread2({
      ref,
      href: props.to
    }, linkProps), {}, {
      className: clsx(props.className)
    }));
  }
  return (0, import_jsx_runtime.jsx)(RouteLink, _objectSpread2({
    ref
  }, props));
};
var NormalLink = (0, import_react.forwardRef)(function(props, ref) {
  return (0, import_jsx_runtime.jsx)("a", _objectSpread2({
    ref,
    className: props.className
  }, props));
});
var RouteLinkView = function RouteLinkView2(props, ref) {
  var to = props.to, params = props.params, query = props.query, className = props.className, activeClassName = props.activeClassName, inactiveClassName = props.inactiveClassName, _onClick = props.onClick, children = props.children, target = props.target, linkProps = _objectWithoutPropertiesLoose(props, _excluded2);
  var router = useRouter();
  var routeObj = router.routes.find(function(routeObj2) {
    return routeObj2.route === to;
  });
  if (!routeObj) {
    throw new Error("[RouteLink] Route not found");
  }
  var _useUnit = c([routeObj.route.$isOpened, to.navigate]), isOpened = _useUnit[0], navigate = _useUnit[1];
  var href = ke({
    sid: "oed02r",
    fn: function fn() {
      return d({
        pathCreator: routeObj.path,
        params: params || {},
        query: query || {}
      });
    },
    name: "href",
    method: "buildPath"
  });
  return (0, import_jsx_runtime.jsx)("a", _objectSpread2(_objectSpread2({
    ref,
    href
  }, linkProps), {}, {
    className: clsx(className, isOpened ? activeClassName : inactiveClassName),
    target,
    onClick: function onClick(evt) {
      if (_onClick) {
        _onClick(evt);
      }
      if (evt.defaultPrevented) {
        return;
      }
      if (target && target !== "_self") {
        return;
      }
      if (evt.metaKey || evt.altKey || evt.ctrlKey || evt.shiftKey) {
        return;
      }
      evt.preventDefault();
      navigate({
        params: params || {},
        query: query || {}
      });
    },
    children
  }));
};
var RouteLink = (0, import_react.forwardRef)(RouteLinkView);
var Link = (0, import_react.forwardRef)(LinkView);
function useIsOpened(route) {
  return Array.isArray(route) ? c(route.map(function(route2) {
    return route2.$isOpened;
  })).some(Boolean) : c(route.$isOpened);
}
function Route(_ref) {
  var route = _ref.route, Component = _ref.view;
  var isOpened = useIsOpened(route);
  if (isOpened) {
    return (0, import_jsx_runtime.jsx)(Component, {});
  }
  return null;
}
function createRouteView(config) {
  return function(props) {
    var mergedConfig = _objectSpread2(_objectSpread2({}, config), props);
    var isOpened = useIsOpened(mergedConfig.route);
    if (isOpened) {
      var View = mergedConfig.view;
      return (0, import_jsx_runtime.jsx)(View, _objectSpread2({}, props));
    }
    if (mergedConfig.otherwise) {
      var Otherwise = mergedConfig.otherwise;
      return (0, import_jsx_runtime.jsx)(Otherwise, _objectSpread2({}, props));
    }
    return null;
  };
}
function createRoutesView(config) {
  return function(props) {
    var mergedConfig = _objectSpread2(_objectSpread2({}, config), props);
    var routes = mergedConfig.routes.map(function(routeRecord) {
      var isOpened = useIsOpened(routeRecord.route);
      return _objectSpread2(_objectSpread2({}, routeRecord), {}, {
        isOpened
      });
    });
    for (var _iterator = _createForOfIteratorHelperLoose(routes), _step; !(_step = _iterator()).done; ) {
      var route = _step.value;
      if (route.isOpened) {
        var View = route.view;
        if (route.layout) {
          var Layout = route.layout;
          return (0, import_jsx_runtime.jsx)(Layout, {
            children: (0, import_jsx_runtime.jsx)(View, {})
          });
        }
        return (0, import_jsx_runtime.jsx)(View, {});
      }
    }
    if (mergedConfig.otherwise) {
      var Otherwise = mergedConfig.otherwise;
      return (0, import_jsx_runtime.jsx)(Otherwise, {});
    }
    return null;
  };
}
function useLink(route, params, query) {
  if (query === void 0) {
    query = {};
  }
  var router = useRouter();
  var routeObj = router.routes.find(function(routeObj2) {
    return routeObj2.route === route;
  });
  if (!routeObj) {
    throw new Error("[useLink] Route not found. Maybe it is not passed into createHistoryRouter");
  }
  return ke({
    sid: "-qn0sus",
    fn: function fn() {
      return d({
        pathCreator: routeObj.path,
        params,
        query
      });
    },
    name: "none",
    method: "buildPath"
  });
}
export {
  Link,
  Route,
  RouterContext,
  RouterProvider,
  createRouteView,
  createRoutesView,
  useLink,
  useRouter
};
//# sourceMappingURL=atomic-router-react.js.map
