import {
  $,
  A,
  Te,
  a,
  ae,
  b,
  g,
  h,
  j,
  n,
  o,
  p,
  v,
  vt,
  x
} from "./chunk-6YLY4OPZ.js";
import "./chunk-WXXH56N5.js";

// node_modules/patronum/and/index.js
function and() {
  for (var _len = arguments.length, stores = new Array(_len), _key = 0; _key < _len; _key++) {
    stores[_key] = arguments[_key];
  }
  return g({
    and: [stores, (values) => {
      for (var value of values) {
        if (!value) {
          return false;
        }
      }
      return true;
    }, {
      skipVoid: false
    }],
    or: {
      sid: "-rbm5ks"
    }
  });
}

// node_modules/patronum/combine-events/index.js
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function combineEvents(args) {
  var argsShape = isEventsShape(args) ? {
    events: args
  } : args;
  var {
    events,
    reset: reset2,
    target = p({
      name: "target",
      sid: "p73fff"
    })
  } = argsShape;
  if (!(ae.unit(target) && ae.targetable(target)))
    throwError("target should be a targetable unit");
  if (reset2 && !ae.unit(reset2))
    throwError("reset should be a unit");
  n(target, () => {
    var keys = Object.keys(events);
    var defaultShape = Array.isArray(events) ? [...keys].fill("") : {};
    var $counter = h(keys.length, {
      and: {
        serialize: "ignore"
      },
      name: "$counter",
      sid: "-ahoahx"
    });
    var $results = h(defaultShape, {
      and: {
        serialize: "ignore"
      },
      name: "$results",
      sid: "oy8iyn"
    });
    x({
      and: [{
        source: target,
        target: $counter.reinit
      }],
      or: {
        sid: "blex0c"
      }
    });
    $results.reset(target);
    if (reset2) {
      x({
        and: [{
          source: reset2,
          target: $counter.reinit
        }],
        or: {
          sid: "bnm3fi"
        }
      });
      $results.reset(reset2);
    }
    var _loop = function _loop2(key2) {
      var $isDone = h(false, {
        and: {
          serialize: "ignore"
        },
        name: "$isDone",
        sid: "-rf2fac"
      }).on(events[key2], () => true).reset(target);
      if (reset2) {
        $isDone.reset(reset2);
      }
      $counter.on($isDone, (value) => value - 1);
      $results.on(events[key2], (shape, payload) => {
        var newShape = Array.isArray(shape) ? [...shape] : _objectSpread({}, shape);
        newShape[key2] = payload;
        return newShape;
      });
    };
    for (var key of keys) {
      _loop(key);
    }
    var eventsTrriggered = x({
      and: [{
        source: $results,
        clock: [...Object.values(events)]
      }],
      or: {
        name: "eventsTrriggered",
        sid: "-lro8bq"
      }
    });
    x({
      and: [{
        source: eventsTrriggered,
        filter: $counter.map((value) => value === 0, {
          skipVoid: false
        }),
        target
      }],
      or: {
        sid: "-dlkr2s"
      }
    });
  });
  return target;
}
function isEventsShape(args) {
  return Object.keys(args).some((key) => !["events", "reset", "target"].includes(key) && ae.unit(args[key]));
}
function throwError(message) {
  throw new Error(message);
}

// node_modules/patronum/condition/index.js
function condition(_ref) {
  var {
    if: test,
    then: thenBranch,
    else: elseBranch,
    source = p({
      name: "source",
      sid: "tdyoa4"
    }, {
      name: "source",
      sid: "tdyoa4"
    })
  } = _ref;
  var checker = ae.unit(test) || isFunction(test) ? test : (value) => value === test;
  if (thenBranch && elseBranch) {
    j({
      and: [{
        source,
        match: {
          then: checker,
          else: inverse(checker)
        },
        cases: {
          then: thenBranch,
          else: elseBranch
        }
      }],
      or: {
        sid: "aaw2hr"
      }
    });
  } else if (thenBranch) {
    x({
      and: [{
        source,
        filter: checker,
        target: thenBranch
      }],
      or: {
        sid: "-dwrmbb"
      }
    });
  } else if (elseBranch) {
    x({
      and: [{
        source,
        filter: inverse(checker),
        target: elseBranch
      }],
      or: {
        sid: "-dsx25s"
      }
    });
  }
  return source;
}
function isFunction(value) {
  return typeof value === "function";
}
function inverse(fnOrUnit) {
  if (ae.unit(fnOrUnit)) {
    return fnOrUnit.map((value) => !value, {
      skipVoid: false
    });
  }
  return (value) => !fnOrUnit(value);
}

// node_modules/patronum/debounce/index.js
function debounce() {
  var _ref;
  var argsShape = arguments.length === 2 ? {
    source: arguments.length <= 0 ? void 0 : arguments[0],
    timeout: arguments.length <= 1 ? void 0 : arguments[1]
  } : arguments.length <= 0 ? void 0 : arguments[0];
  var {
    source,
    timeout,
    target,
    name
  } = argsShape;
  if (!ae.unit(source))
    throw new TypeError("source must be unit from effector");
  if (ae.domain(source, {
    sid: "jsc7s2"
  }))
    throw new TypeError("source cannot be domain");
  var $timeout = toStoreNumber(timeout);
  var saveCancel = p({
    name: "saveCancel",
    sid: "-kec0n3"
  });
  var $canceller = h([], {
    and: {
      serialize: "ignore"
    },
    name: "$canceller",
    sid: "-tfm9fg"
  }).on(saveCancel, (_, payload) => payload);
  var tick = (_ref = target) !== null && _ref !== void 0 ? _ref : p({
    name: "tick",
    sid: "-50e2rn"
  });
  var timerFx = v({
    and: {
      name: name || "debounce(".concat((source === null || source === void 0 ? void 0 : source.shortName) || source.kind, ") effect"),
      source: $canceller,
      effect(_ref2, timeout2) {
        var [timeoutId, rejectPromise] = _ref2;
        if (timeoutId)
          clearTimeout(timeoutId);
        if (rejectPromise)
          rejectPromise();
        return new Promise((resolve, reject) => {
          saveCancel([setTimeout(resolve, timeout2), reject]);
        });
      }
    },
    or: {
      name: "timerFx",
      sid: "-jwso4j"
    }
  });
  $canceller.reset(timerFx.done);
  var $payload = h([], {
    and: {
      serialize: "ignore",
      skipVoid: false
    },
    name: "$payload",
    sid: "-x9cllg"
  }).on(source, (_, payload) => [payload]);
  var $canTick = h(true, {
    and: {
      serialize: "ignore"
    },
    name: "$canTick",
    sid: "8r2952"
  });
  var triggerTick = p({
    name: "triggerTick",
    sid: "-781myl"
  });
  $canTick.on(triggerTick, () => false).on([
    tick,
    // debounce timeout should be restarted on timeout change
    $timeout,
    // debounce timeout can be restarted in later ticks
    timerFx
  ], () => true);
  var requestTick = $([
    source,
    // debounce timeout is restarted on timeout change
    x({
      and: [{
        clock: $timeout,
        filter: timerFx.pending
      }],
      or: {
        name: "requestTick",
        sid: "-khrpxp"
      }
    })
  ], {
    name: "requestTick",
    sid: "2k0852"
  });
  x({
    and: [{
      clock: requestTick,
      filter: $canTick,
      target: triggerTick
    }],
    or: {
      sid: "-31h8q8"
    }
  });
  x({
    and: [{
      source: $timeout,
      clock: triggerTick,
      target: timerFx
    }],
    or: {
      sid: "-2y6h62"
    }
  });
  x({
    and: [{
      source: $payload,
      clock: timerFx.done,
      fn: (_ref3) => {
        var [payload] = _ref3;
        return payload;
      },
      target: tick
    }],
    or: {
      sid: "-2jc15b"
    }
  });
  return tick;
}
function toStoreNumber(value) {
  if (ae.store(value, {
    sid: "-21qm2b"
  }))
    return value;
  if (typeof value === "number") {
    if (value < 0 || !Number.isFinite(value))
      throw new Error('timeout must be positive number or zero. Received: "'.concat(value, '"'));
    return h(value, {
      and: {
        name: "$timeout"
      },
      sid: "kbepy4"
    });
  }
  throw new TypeError('timeout parameter in interval method should be number or Store. "'.concat(typeof value, '" was passed'));
}

// node_modules/patronum/debug/index.js
function ownKeys2(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys2(Object(source), true).forEach(function(key) {
      _defineProperty2(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys2(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty2(obj, key, value) {
  key = _toPropertyKey2(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey2(arg) {
  var key = _toPrimitive2(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive2(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var defaultConfig = {
  trace: false,
  // default logger to console.info
  handler: (context) => {
    if (isEffectChild(context.node) && context.node.meta.named === "finally") {
      return;
    }
    var {
      scope,
      scopeName,
      name,
      kind,
      value,
      loc,
      trace,
      node,
      logType
    } = context;
    var scopeLog = scope ? " (scope: ".concat(scopeName, ")") : "";
    var logName = name !== null && name !== void 0 ? name : loc ? "".concat(loc.file, ":").concat(loc.line, ":").concat(loc.column) : "";
    var logPrintType = logType === "initial" ? " [getState]" : "";
    console.info("[".concat(kind, "]").concat(scopeLog, " ").concat(logName).concat(logPrintType), value);
    if (
      // logging trace only if there is something to log
      trace && trace.length > 0 && // do not log trace for effect children, as it is always the same effect internals
      !isEffectChild(node)
    ) {
      console.groupCollapsed("[".concat(kind, "]").concat(scopeLog, " ").concat(logName, " trace"));
      trace.forEach((update) => {
        var {
          name: traceName,
          kind: kind2,
          value: value2,
          loc: loc2
        } = update;
        var logTraceName = traceName !== null && traceName !== void 0 ? traceName : loc2 ? "".concat(loc2.file, ":").concat(loc2.line, ":").concat(loc2.column) : "";
        console.info("<- [".concat(kind2, "] ").concat(logTraceName), value2);
      });
      console.groupEnd();
    }
  }
};
function debug() {
  var {
    config,
    units
  } = resolveParams(...arguments);
  units.forEach((unit) => {
    if (ae.store(unit, {
      sid: "-foynff"
    }) || ae.event(unit, {
      sid: "apy28p"
    }) || ae.effect(unit, {
      sid: "apy3od"
    })) {
      watchUnit(unit, config);
    } else if (ae.domain(unit, {
      sid: "-rsqe9t"
    })) {
      watchDomain(unit, config);
    } else {
    }
  });
}
function watchDomain(domain, config) {
  domain.onCreateStore((store) => watchUnit(store, config));
  domain.onCreateEvent((event) => watchUnit(event, config));
  domain.onCreateEffect((effect) => watchUnit(effect, config));
  domain.onCreateDomain((domain2) => watchDomain(domain2, config));
}
function watchUnit(unit, config) {
  if (ae.store(unit, {
    sid: "w7ds2s"
  })) {
    watchStoreInit(unit, config);
    watch(unit, config);
  } else if (ae.event(unit, {
    sid: "fretyd"
  })) {
    watch(unit, config);
  } else if (ae.effect(unit, {
    sid: "gpi2qr"
  })) {
    watch(unit, config);
    watch(unit.finally, config);
    watch(unit.done, config);
    watch(unit.fail, config);
  }
}
function watch(unit, config) {
  var watcher = a({
    parent: [unit],
    // debug watchers should behave like normal watchers
    meta: {
      op: "watch"
    },
    family: {
      owners: unit
    },
    regional: true,
    // node only gets all required data
    node: [Te.run({
      fn(value, _internal, stack) {
        var _stack$scope;
        var scope = (_stack$scope = stack === null || stack === void 0 ? void 0 : stack.scope) !== null && _stack$scope !== void 0 ? _stack$scope : null;
        var context = {
          logType: "update",
          scope,
          scopeName: getScopeName(scope),
          node: getNode(unit),
          kind: getType(unit),
          value,
          name: getName(unit),
          loc: getLoc(unit),
          // Use stack meta of actual unit, not of debug node
          stackMeta: getStackMeta(stack.parent),
          trace: config.trace ? collectTrace(stack) : []
        };
        if (!config.handler) {
          throw Error("patronum/debug must have the handler");
        }
        config.handler(context);
      }
    })]
  });
  return () => vt(watcher);
}
function collectTrace(stack) {
  var trace = [];
  var parent = stack === null || stack === void 0 ? void 0 : stack.parent;
  while (parent) {
    var {
      node,
      value
    } = parent;
    var entry = {
      node,
      value,
      name: getName(node),
      loc: getLoc(node),
      kind: getType(node),
      stackMeta: getStackMeta(parent)
    };
    trace.push(entry);
    parent = parent.parent;
  }
  return trace;
}
function watchStoreInit(store, config) {
  if (!config.handler) {
    throw Error("patronum/debug must have the handler");
  }
  var node = getNode(store);
  var context = {
    logType: "initial",
    scope: null,
    scopeName: null,
    node,
    kind: getType(store),
    value: store.getState(),
    name: getName(store),
    loc: getLoc(store),
    // nothing to trace for store.getState() - it is one-step call
    trace: [],
    // no stackMeta for initial state
    stackMeta: {}
  };
  config.handler(context);
  scopes.forEach((scope) => watchStoreInitInScope(store, config, scope));
  watchScopeRegister((newScope) => watchStoreInitInScope(store, config, newScope));
}
function watchStoreInitInScope(store, config, scope) {
  if (!config.handler) {
    throw Error("patronum/debug must have the handler");
  }
  var node = getNode(store);
  var context = {
    logType: "initial",
    scope,
    scopeName: getScopeName(scope),
    node,
    kind: getType(store),
    value: scope.getState(store),
    name: getName(store),
    loc: getLoc(store),
    // nothing to trace for scope.getState(store) - it is one-step call
    trace: [],
    // no stackMeta for initial state
    stackMeta: {}
  };
  config.handler(context);
}
function resolveParams() {
  var config = defaultConfig;
  for (var _len = arguments.length, entry = new Array(_len), _key = 0; _key < _len; _key++) {
    entry[_key] = arguments[_key];
  }
  var [maybeConfig, ...restUnits] = entry;
  var units = [];
  if (isConfig(maybeConfig)) {
    config = _objectSpread2(_objectSpread2({}, defaultConfig), maybeConfig);
  } else if (!ae.unit(maybeConfig)) {
    for (var [name, unit] of Object.entries(maybeConfig)) {
      customNames.set(getGraph(unit).id, name);
      units.push(unit);
    }
  } else {
    units.push(maybeConfig);
  }
  for (var maybeUnit of restUnits) {
    if (ae.unit(maybeUnit)) {
      units.push(maybeUnit);
    } else {
      for (var [_name, _unit] of Object.entries(maybeUnit)) {
        customNames.set(getGraph(_unit).id, _name);
        units.push(_unit);
      }
    }
  }
  return {
    config,
    units
  };
}
function isConfig(maybeConfig) {
  if (!ae.unit(maybeConfig)) {
    return !Object.values(maybeConfig).every(ae.unit);
  }
  return false;
}
var watchers = /* @__PURE__ */ new Set();
var watchScopeRegister = (cb) => {
  watchers.add(cb);
  return () => {
    watchers.delete(cb);
  };
};
function registerScope(scope, config) {
  scopes.save(scope, {
    name: config.name
  });
  watchers.forEach((cb) => cb(scope));
  return () => {
    scopes.delete(scope);
  };
}
function unregisterAllScopes() {
  scopes.clear();
}
var unknownScopes = 0;
function getDefaultScopeName() {
  unknownScopes += 1;
  return "unknown_".concat(unknownScopes);
}
var cache = /* @__PURE__ */ new Map();
var scopes = {
  save(scope, meta) {
    if (!scopes.get(scope)) {
      cache.set(scope, meta);
    }
  },
  get(scope) {
    var _cache$get;
    if (!scope)
      return null;
    return (_cache$get = cache.get(scope)) !== null && _cache$get !== void 0 ? _cache$get : null;
  },
  delete(scope) {
    cache.delete(scope);
  },
  forEach(callback) {
    cache.forEach((meta, scope) => callback(scope, meta));
  },
  clear() {
    cache.clear();
  }
};
debug.registerScope = registerScope;
debug.unregisterAllScopes = unregisterAllScopes;
function getScopeName(scope) {
  if (!scope)
    return null;
  var meta = scopes.get(scope);
  if (!meta) {
    var fallbackId = scope._debugId || (scope._debugId = getDefaultScopeName());
    return fallbackId;
  }
  return meta.name;
}
function isEffectChild(node) {
  var actualNode = getNode(node);
  var {
    sid,
    named
  } = actualNode.meta;
  return Boolean(!sid && (named === "finally" || named === "done" || named === "doneData" || named === "fail" || named === "failData" || named === "inFlight" || named === "pending"));
}
function isStoreOn(node) {
  var actualNode = getNode(node);
  var {
    op
  } = actualNode.meta;
  if (op === "on")
    return true;
  return false;
}
function getType(unit) {
  if (ae.store(unit, {
    sid: "4o7s04"
  })) {
    return "store";
  }
  if (ae.effect(unit, {
    sid: "4pv5s7"
  }) || isEffectChild(unit)) {
    return "effect";
  }
  if (ae.event(unit, {
    sid: "4rijka"
  })) {
    return "event";
  }
  if (ae.domain(unit, {
    sid: "54plsy"
  })) {
    return "domain";
  }
  if (ae.unit(unit)) {
    return "unit";
  }
  var node = getNode(unit);
  if (node.meta.op) {
    return node.meta.op;
  }
  return "unknown";
}
var getGraph = (graph) => graph.graphite || graph;
var customNames = /* @__PURE__ */ new Map();
function getName(unit) {
  var _getNode, _getNode$meta;
  var custom = customNames.get(getGraph(unit).id);
  if (custom) {
    return custom;
  }
  if (isEffectChild(unit)) {
    var node = getNode(unit);
    var parentEffect = node.family.owners.find((n2) => n2.meta.op === "effect");
    if (parentEffect) {
      var closestParentDomainName = getOwningDomainName(parentEffect);
      var formattedDomainName = closestParentDomainName ? "".concat(closestParentDomainName, "/") : "";
      return "".concat(formattedDomainName).concat(getName(parentEffect), ".").concat(node.meta.named);
    }
    return node.meta.named;
  }
  if (isStoreOn(unit)) {
    var _node = getNode(unit);
    var targetStoreName = getName(_node.next[0]);
    var triggerEventName = getName(_node.family.owners[0]);
    return "".concat(targetStoreName, ".on(").concat(triggerEventName, ")");
  }
  if (ae.unit(unit)) {
    var _compositeName;
    if (unit !== null && unit !== void 0 && (_compositeName = unit.compositeName) !== null && _compositeName !== void 0 && _compositeName.fullName) {
      return unit.compositeName.fullName;
    }
    var _closestParentDomainName = getOwningDomainName(unit);
    var _formattedDomainName = _closestParentDomainName ? "".concat(_closestParentDomainName, "/") : "";
    if (unit !== null && unit !== void 0 && unit.shortName) {
      return "".concat(_formattedDomainName).concat(unit.shortName);
    }
    if (unit !== null && unit !== void 0 && unit.name) {
      return "".concat(_formattedDomainName).concat(unit.name);
    }
  }
  if ((_getNode = getNode(unit)) !== null && _getNode !== void 0 && (_getNode$meta = _getNode.meta) !== null && _getNode$meta !== void 0 && _getNode$meta.name) {
    return getNode(unit).meta.name;
  }
  return null;
}
function getOwningDomainName(unit) {
  var closestParentDomain = getNode(unit).family.owners.find((n2) => n2.meta.op === "domain");
  if (!closestParentDomain)
    return null;
  return getName(closestParentDomain);
}
function readLoc(_ref) {
  var {
    meta
  } = _ref;
  var loc = "config" in meta ? meta.config.loc : meta.loc;
  return loc;
}
function getLoc(unit) {
  var loc = readLoc(getNode(unit));
  if (!loc)
    return void 0;
  return loc;
}
function getNode(node) {
  var actualNode = "graphite" in node ? node.graphite : node;
  return actualNode;
}
function getStackMeta(stack) {
  if (!stack)
    return {};
  var meta = stack.meta || {};
  return meta;
}

// node_modules/patronum/delay/index.js
function delay() {
  var argsShape = arguments.length === 2 ? {
    source: arguments.length <= 0 ? void 0 : arguments[0],
    timeout: arguments.length <= 1 ? void 0 : arguments[1]
  } : arguments.length <= 0 ? void 0 : arguments[0];
  var {
    source,
    timeout,
    target = p({
      name: "target",
      sid: "jucb8d"
    })
  } = argsShape;
  var targets = Array.isArray(target) ? target : [target];
  if (!ae.unit(source))
    throw new TypeError("source must be a unit from effector");
  if (!targets.every((unit) => ae.unit(unit)))
    throw new TypeError("target must be a unit from effector");
  var ms = validateTimeout(timeout);
  var timerFx = b((_ref) => {
    var {
      payload,
      milliseconds
    } = _ref;
    return new Promise((resolve) => {
      setTimeout(resolve, milliseconds, payload);
    });
  }, {
    name: "timerFx",
    sid: "-wp3hwr"
  });
  x({
    and: [{
      // ms can be Store<number> | number
      // converts object of stores or object of values to store
      source: g({
        and: [{
          milliseconds: ms
        }],
        or: {
          name: "source",
          sid: "-gaikyz"
        }
      }),
      clock: source,
      fn: (_ref2, payload) => {
        var {
          milliseconds
        } = _ref2;
        return {
          payload,
          milliseconds: typeof milliseconds === "function" ? milliseconds(payload) : milliseconds
        };
      },
      target: timerFx
    }],
    or: {
      sid: "-uuqxfw"
    }
  });
  x({
    and: [{
      clock: timerFx.doneData,
      target: targets
    }],
    or: {
      sid: "-uc1x9m"
    }
  });
  return target;
}
function validateTimeout(timeout) {
  if (ae.store(timeout, {
    sid: "-tvk3f2"
  }) || typeof timeout === "function" || typeof timeout === "number") {
    return timeout;
  }
  throw new TypeError(`'timeout' argument must be a function, Store, or a number. Passed "`.concat(typeof timeout, '"'));
}

// node_modules/patronum/either/index.js
function either(filterOptions, then, other) {
  if (ae.store(filterOptions, {
    sid: "ozzvoc"
  })) {
    return g({
      and: [filterOptions, then, other, (filter, then2, other2) => filter ? then2 : other2, {
        skipVoid: false
      }],
      or: {
        sid: "-5vau2h"
      }
    });
  }
  var objectForm = filterOptions;
  return either(objectForm.filter, objectForm.then, objectForm.other);
}

// node_modules/patronum/empty/index.js
function empty(source) {
  return source.map((value) => value == null, {
    skipVoid: false
  });
}

// node_modules/patronum/equals/index.js
function equals(a2, b2) {
  return g({
    and: [a2, b2, (a3, b3) => a3 === b3, {
      skipVoid: false
    }],
    or: {
      sid: "-pqjlti"
    }
  });
}

// node_modules/patronum/every/index.js
function every(configOrStores, predicateOrNone) {
  var stores = [];
  var predicate = () => false;
  if (Array.isArray(configOrStores)) {
    stores = configOrStores;
    predicate = predicateOrNone;
  } else if (Array.isArray(configOrStores.stores)) {
    stores = configOrStores.stores;
    predicate = configOrStores.predicate;
  }
  var checker;
  if (isFunction2(predicate)) {
    checker = predicate;
  } else if (ae.store(predicate, {
    sid: "sid3ut"
  })) {
    checker = predicate.map((value) => (required) => value === required, {
      skipVoid: false
    });
  } else {
    checker = (value) => value === predicate;
  }
  var $values = g({
    and: [stores],
    or: {
      name: "$values",
      sid: "rwb5jx"
    }
  });
  var $checker = checker;
  return g({
    and: [$checker, $values, (checker2, values) => values.every(checker2), {
      skipVoid: false
    }],
    or: {
      sid: "hgnz2z"
    }
  });
}
function isFunction2(value) {
  return typeof value === "function";
}

// node_modules/patronum/format/index.js
function format(strings) {
  for (var _len = arguments.length, stores = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    stores[_key - 1] = arguments[_key];
  }
  return g({
    and: [stores, (stores2) => strings.reduce((acc, value, index) => acc.concat(isLastElement(strings, index) ? value : "".concat(value).concat(toString(stores2[index]))), ""), {
      skipVoid: false
    }],
    or: {
      sid: "-yrbthp"
    }
  });
}
function toString(value) {
  if (Array.isArray(value)) {
    return value.map((value2) => String(value2)).join(", ");
  }
  return String(value);
}
function isLastElement(array, index) {
  return index === array.length - 1;
}

// node_modules/patronum/in-flight/index.js
function inFlight(args) {
  var argsShape = Array.isArray(args) ? {
    effects: args
  } : args;
  var {
    effects,
    domain
  } = argsShape;
  if (domain) {
    var $inFlight = domain.createStore(0, {
      name: "$inFlight",
      sid: "-wboyn1"
    });
    domain.onCreateEffect((fx) => {
      $inFlight.on(fx, (count) => count + 1).on(fx.finally, (count) => count - 1);
    });
    return $inFlight;
  }
  return g({
    and: [effects.map((fx) => fx.inFlight), (inFlights) => inFlights.reduce((all, current) => all + current, 0), {
      skipVoid: false
    }],
    or: {
      sid: "udy3nn"
    }
  });
}

// node_modules/patronum/interval/index.js
function interval(_ref) {
  var {
    timeout,
    start,
    stop,
    leading = false,
    trailing = false
  } = _ref;
  var setup = p({
    name: "setup",
    sid: "-ajee8b"
  });
  if (start) {
    x({
      and: [{
        clock: start,
        target: setup
      }],
      or: {
        sid: "-wq30tc"
      }
    });
  }
  var teardown = p({
    name: "teardown",
    sid: "-on6wf8"
  });
  if (stop) {
    x({
      and: [{
        clock: stop,
        target: teardown
      }],
      or: {
        sid: "-wloo2g"
      }
    });
  }
  var tick = p({
    name: "tick",
    sid: "37avek"
  });
  var $isRunning = h(false, {
    name: "$isRunning",
    sid: "amqfro"
  });
  var $timeout = toStoreNumber2(timeout);
  var $notRunning = $isRunning.map((running) => !running, {
    skipVoid: false
  });
  var saveTimeout = p({
    name: "saveTimeout",
    sid: "-goth3o"
  });
  var $timeoutId = h(null, {
    name: "$timeoutId",
    sid: "xi134t"
  }).on(saveTimeout, (_, _ref2) => {
    var {
      timeoutId
    } = _ref2;
    return timeoutId;
  });
  var $rejecter = h(() => {
  }, {
    name: "$rejecter",
    sid: "-2am6sk"
  }).on(saveTimeout, (_, _ref3) => {
    var {
      reject
    } = _ref3;
    return reject;
  });
  var timeoutFx = v({
    and: {
      source: {
        timeout: $timeout,
        running: $isRunning
      },
      effect: (_ref4) => {
        var {
          timeout: timeout2,
          running
        } = _ref4;
        if (!running) {
          return Promise.reject();
        }
        return new Promise((resolve, reject) => {
          var timeoutId = setTimeout(resolve, timeout2);
          saveTimeout({
            timeoutId,
            reject
          });
        });
      }
    },
    or: {
      name: "timeoutFx",
      sid: "-hiem3q"
    }
  });
  var cleanupFx = v({
    and: {
      source: {
        timeoutId: $timeoutId,
        rejecter: $rejecter
      },
      effect: (_ref5) => {
        var {
          timeoutId,
          rejecter
        } = _ref5;
        rejecter();
        if (timeoutId)
          clearTimeout(timeoutId);
      }
    },
    or: {
      name: "cleanupFx",
      sid: "d148gq"
    }
  });
  x({
    and: [{
      clock: setup,
      source: $timeout,
      filter: $notRunning,
      target: timeoutFx
    }],
    or: {
      sid: "-u9k5bx"
    }
  });
  if (leading) {
    var onReady = x({
      and: [{
        clock: setup,
        filter: $notRunning
      }],
      or: {
        name: "onReady",
        sid: "5o8c6v"
      }
    });
    x({
      and: [{
        clock: onReady,
        target: tick
      }],
      or: {
        sid: "6njtce"
      }
    });
  }
  x({
    and: [{
      clock: setup,
      fn: () => true,
      target: $isRunning
    }],
    or: {
      sid: "6p772r"
    }
  });
  x({
    and: [{
      clock: timeoutFx.done,
      source: $timeout,
      filter: $isRunning,
      target: timeoutFx
    }],
    or: {
      sid: "741n3i"
    }
  });
  x({
    and: [{
      clock: timeoutFx.done,
      filter: $isRunning,
      target: tick.prepend(() => {
      })
    }],
    or: {
      sid: "7jfvpm"
    }
  });
  if (trailing) {
    x({
      and: [{
        clock: teardown,
        target: tick
      }],
      or: {
        sid: "7zxpk6"
      }
    });
  }
  $isRunning.on(teardown, () => false);
  x({
    and: [{
      clock: teardown,
      target: cleanupFx
    }],
    or: {
      sid: "84c29c"
    }
  });
  return {
    tick,
    isRunning: $isRunning,
    "@@trigger": () => ({
      setup,
      teardown,
      fired: tick
    })
  };
}
function toStoreNumber2(value) {
  if (ae.store(value, {
    sid: "90rxd3"
  }))
    return value;
  if (typeof value === "number") {
    return h(value, {
      and: {
        name: "$timeout"
      },
      sid: "-3ibdj9"
    });
  }
  throw new TypeError('timeout parameter in interval method should be number or Store. "'.concat(typeof value, '" was passed'));
}

// node_modules/patronum/not/index.js
function not(source) {
  return source.map((value) => !value, {
    skipVoid: false
  });
}

// node_modules/patronum/once/index.js
function once(unitOrConfig) {
  var source;
  var reset2;
  if (ae.unit(unitOrConfig)) {
    source = unitOrConfig;
  } else {
    ({
      source,
      reset: reset2
    } = unitOrConfig);
  }
  var $canTrigger = h(true, {
    name: "$canTrigger",
    sid: "ys2jl0"
  });
  var trigger = x({
    and: [{
      source,
      filter: $canTrigger
    }],
    or: {
      name: "trigger",
      sid: "e3xto3"
    }
  });
  $canTrigger.on(trigger, () => false);
  if (reset2) {
    $canTrigger.reset(reset2);
  }
  return trigger;
}

// node_modules/patronum/or/index.js
function or() {
  for (var _len = arguments.length, stores = new Array(_len), _key = 0; _key < _len; _key++) {
    stores[_key] = arguments[_key];
  }
  return g({
    and: [stores, (values) => {
      for (var value of values) {
        if (value) {
          return true;
        }
      }
      return false;
    }, {
      skipVoid: false
    }],
    or: {
      sid: "-44722k"
    }
  });
}

// node_modules/patronum/pending/index.js
var strategies = {
  some: (list) => list.some(Boolean),
  every: (list) => list.every(Boolean)
};
function pending(args) {
  var argsShape = Array.isArray(args) ? {
    effects: args
  } : args;
  var {
    effects: rawEffects,
    domain,
    of = "some"
  } = argsShape;
  if (!ae.domain(domain, {
    sid: "98ymuf"
  }) && !rawEffects)
    throw new TypeError("domain or effects should be passed");
  if (of !== "some" && of !== "every")
    throw new TypeError('strategy parameter "of" can be "every" or "some". Passed: "'.concat(of, '"'));
  var effects = rawEffects !== null && rawEffects !== void 0 ? rawEffects : [];
  var strategy = strategies[of];
  if (domain) {
    effects = [];
    domain.onCreateEffect((fx) => effects.push(fx));
  }
  return g({
    and: [effects.map((fx) => fx.pending), strategy, {
      skipVoid: false
    }],
    or: {
      sid: "a4upb3"
    }
  });
}

// node_modules/patronum/previous/index.js
function previous() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  var [store] = args;
  var initialValue = args.length < 2 ? null : args[1];
  if (!ae.store(store, {
    sid: "mzq5dc"
  })) {
    throw Error("previous first argument should be a store");
  }
  var $prevValue = h(initialValue, {
    and: {
      serialize: "ignore",
      skipVoid: false
    },
    name: "$prevValue",
    sid: "e05yob"
  });
  var storeNode = store.graphite;
  storeNode.seq.push(Te.compute({
    fn(upd, _, stack) {
      o({
        target: $prevValue,
        params: stack.a,
        defer: true
      });
      return upd;
    }
  }));
  return $prevValue;
}

// node_modules/patronum/readonly/index.js
function readonly(source) {
  if (!ae.targetable(source)) {
    return source;
  }
  if (ae.store(source, {
    sid: "-kqkmsc"
  })) {
    return source.map((value) => value, {
      skipVoid: false
    });
  }
  if (ae.event(source, {
    sid: "-kodgew"
  })) {
    return source.map((value) => value);
  }
  return source;
}

// node_modules/patronum/reset/index.js
function reset(_ref) {
  var {
    clock,
    target
  } = _ref;
  var targets = Array.isArray(target) ? target : [target];
  var clocks = Array.isArray(clock) ? clock : [clock !== null && clock !== void 0 ? clock : p({
    name: "clocks",
    sid: "bqmea5"
  })];
  targets.forEach((target2) => {
    target2.reset(clocks);
  });
  return clock === void 0 ? clocks[0] : void 0;
}

// node_modules/patronum/reshape/index.js
function reshape(_ref) {
  var {
    source,
    shape
  } = _ref;
  var result = {};
  var _loop = function _loop2(key2) {
    if (!Object.prototype.hasOwnProperty.call(shape, key2)) {
      return "continue";
    }
    var fn = shape[key2];
    result[key2] = source.map((state) => {
      var result2 = fn(state);
      return result2 === void 0 ? null : result2;
    }, {
      skipVoid: false
    });
  };
  for (var key in shape) {
    var _ret = _loop(key);
    if (_ret === "continue")
      continue;
  }
  return result;
}

// node_modules/patronum/snapshot/index.js
function snapshot(_ref) {
  var {
    source,
    clock,
    fn = (value) => value
  } = _ref;
  var defaultValue = fn(source.defaultState);
  var onSnapshot = clock ? x({
    and: [{
      source,
      clock,
      fn
    }],
    or: {
      name: "onSnapshot",
      sid: "-imuiws"
    }
  }) : x({
    and: [{
      source,
      fn
    }],
    or: {
      name: "onSnapshot",
      sid: "-imaqbf"
    }
  });
  var $snapshot = h(defaultValue, {
    name: "$snapshot",
    sid: "-63s6pn"
  });
  $snapshot.on(onSnapshot, (_, value) => value);
  return $snapshot;
}

// node_modules/patronum/some/index.js
function some(configOrStores, predicateOrNone) {
  var stores = [];
  var predicate = () => false;
  if (Array.isArray(configOrStores)) {
    stores = configOrStores;
    predicate = predicateOrNone;
  } else if (Array.isArray(configOrStores.stores)) {
    stores = configOrStores.stores;
    predicate = configOrStores.predicate;
  }
  var checker;
  if (isFunction3(predicate)) {
    checker = predicate;
  } else if (ae.store(predicate, {
    sid: "zbwu0l"
  })) {
    checker = predicate.map((value) => (required) => value === required, {
      skipVoid: false
    });
  } else {
    checker = (value) => value === predicate;
  }
  var $values = g({
    and: [stores],
    or: {
      name: "$values",
      sid: "-kx24vm"
    }
  });
  var $checker = checker;
  return g({
    and: [$checker, $values, (checker2, values) => values.some(checker2), {
      skipVoid: false
    }],
    or: {
      sid: "-ee8kph"
    }
  });
}
function isFunction3(value) {
  return typeof value === "function";
}

// node_modules/patronum/split-map/index.js
function splitMap(_ref) {
  var {
    source,
    cases
  } = _ref;
  var result = {};
  var current = ae.store(source, {
    name: "current",
    sid: "-htjkz7"
  }) ? source.updates : source;
  for (var key in cases) {
    if (key in cases) {
      (function() {
        var _fn = cases[key];
        result[key] = current.filterMap(_fn);
        current = current.filter({
          fn: (data) => !_fn(data)
        });
      })();
    }
  }
  result.__ = current;
  return result;
}

// node_modules/patronum/spread/index.js
var hasPropBase = {}.hasOwnProperty;
var hasOwnProp = (object, key) => hasPropBase.call(object, key);
function spread(args) {
  var argsShape = isTargets(args) ? {
    targets: args
  } : args;
  var {
    targets,
    source = p({
      name: "source",
      sid: "e9ipnn"
    })
  } = argsShape;
  var _loop = function _loop2(targetKey2) {
    if (hasOwnProp(targets, targetKey2)) {
      var currentTarget = targets[targetKey2];
      var hasTargetKey = x({
        and: [{
          source,
          batch: false,
          filter: (object) => typeof object === "object" && object !== null && targetKey2 in object
        }],
        or: {
          name: "hasTargetKey",
          sid: "eapc0z"
        }
      });
      x({
        and: [{
          batch: false,
          clock: hasTargetKey,
          fn: (object) => object[targetKey2],
          target: currentTarget
        }],
        or: {
          sid: "mkzcy4"
        }
      });
    }
  };
  for (var targetKey in targets) {
    _loop(targetKey);
  }
  return source;
}
function isTargets(args) {
  return Object.keys(args).some((key) => !["targets", "source"].includes(key) && ae.unit(args[key]));
}

// node_modules/patronum/status/index.js
function status(params) {
  var {
    effect,
    defaultValue = "initial"
  } = ae.effect(params, {
    sid: "cn6w5b"
  }) ? {
    effect: params
  } : params;
  var $status = h(defaultValue, {
    name: "$status",
    sid: "ph7d4u"
  });
  if (!ae.effect(effect, {
    sid: "-kp39vu"
  })) {
    throw TypeError('status: "effect" property is not an effect');
  }
  $status.on(effect, () => "pending").on(effect.done, () => "done").on(effect.fail, () => "fail");
  return $status;
}

// node_modules/patronum/throttle/index.js
function throttle() {
  var argsShape = arguments.length === 2 ? {
    source: arguments.length <= 0 ? void 0 : arguments[0],
    timeout: arguments.length <= 1 ? void 0 : arguments[1]
  } : arguments.length <= 0 ? void 0 : arguments[0];
  var {
    source,
    timeout,
    target = p({
      name: "target",
      sid: "-gyhb56"
    })
  } = argsShape;
  if (!ae.unit(source))
    throw new TypeError("source must be unit from effector");
  var $timeout = toStoreNumber3(timeout);
  var timerFx = b({
    name: "throttle(".concat(source.shortName || source.kind, ") effect"),
    handler: (timeout2) => new Promise((resolve) => setTimeout(resolve, timeout2))
  }, {
    name: "timerFx",
    sid: "-lp5bot"
  });
  var $payload = h(null, {
    and: {
      serialize: "ignore",
      skipVoid: false
    },
    name: "$payload",
    sid: "w71tnu"
  }).on(source, (_, payload) => payload);
  var triggerTick = p({
    name: "triggerTick",
    sid: "-dquigt"
  });
  var $canTick = h(true, {
    and: {
      serialize: "ignore"
    },
    name: "$canTick",
    sid: "e2dxhp"
  }).on(triggerTick, () => false).on(target, () => true);
  x({
    and: [{
      clock: source,
      filter: $canTick,
      target: triggerTick
    }],
    or: {
      sid: "-hifwv4"
    }
  });
  x({
    and: [{
      source: $timeout,
      clock: triggerTick,
      target: timerFx
    }],
    or: {
      sid: "-h3lgud"
    }
  });
  x({
    and: [{
      source: $payload,
      clock: timerFx.done,
      target
    }],
    or: {
      sid: "-h0apa7"
    }
  });
  return target;
}
function toStoreNumber3(value) {
  if (ae.store(value, {
    sid: "-gj92sk"
  }))
    return value;
  if (typeof value === "number") {
    if (value < 0 || !Number.isFinite(value))
      throw new Error('timeout must be positive number or zero. Received: "'.concat(value, '"'));
    return h(value, {
      and: {
        name: "$timeout"
      },
      sid: "-2ktcsz"
    });
  }
  throw new TypeError('timeout parameter should be number or Store. "'.concat(typeof value, '" was passed'));
}

// node_modules/patronum/time/index.js
var defaultNow = () => Date.now();
function time(args) {
  var argsShape = ae.unit(args) ? {
    clock: args
  } : args;
  var {
    clock,
    getNow,
    initial
  } = argsShape;
  var timeReader = getNow !== null && getNow !== void 0 ? getNow : defaultNow;
  var readNowFx = b(timeReader, {
    name: "readNowFx",
    sid: "ito90c"
  });
  var $time = A(readNowFx, initial !== null && initial !== void 0 ? initial : timeReader(), {
    name: "$time",
    sid: "-k3vl4d"
  });
  x({
    and: [{
      clock,
      target: readNowFx
    }],
    or: {
      sid: "rul0o2"
    }
  });
  return $time;
}
export {
  and,
  combineEvents,
  condition,
  debounce,
  debug,
  delay,
  either,
  empty,
  equals,
  every,
  format,
  inFlight,
  interval,
  not,
  once,
  or,
  pending,
  previous,
  readonly,
  reset,
  reshape,
  snapshot,
  some,
  splitMap,
  spread,
  status,
  throttle,
  time
};
//# sourceMappingURL=patronum.js.map
