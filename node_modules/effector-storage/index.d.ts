import { Unit, Subscription, Store, Event, Effect } from 'effector';
export { AsyncStorageConfig, asyncStorage } from './async-storage';
export { BroadcastConfig, broadcast } from './broadcast';
export { LocalStorageConfig, local } from './local';
export { LogConfig, log } from './log';
export { MemoryConfig, memory } from './memory';
export { NilConfig, nil } from './nil';
export { QueryConfig, query } from './query';
export { SessionStorageConfig, session } from './session';
export { StorageConfig, storage } from './storage';
export { async, either, farcached } from './tools';

interface StorageAdapter {
    <State>(key: string, update: (raw?: any) => void): {
        get(raw?: any, ctx?: any): State | Promise<State | undefined> | undefined;
        set(value: State, ctx?: any): void;
    };
    keyArea?: any;
    noop?: boolean;
}
interface StorageAdapterFactory<AdapterConfig> {
    (config?: AdapterConfig): StorageAdapter;
    factory: true;
}
type Contract<Data> = ((raw: unknown) => raw is Data) | {
    isData: (raw: unknown) => raw is Data;
    getErrorMessages: (raw: unknown) => string[];
};
type Done<State> = {
    key: string;
    keyPrefix: string;
    operation: 'set' | 'get';
    value: State;
};
type Fail<Err> = {
    key: string;
    keyPrefix: string;
    operation: 'set' | 'get';
    error: Err;
    value?: any;
};
type Finally<State, Err> = (Done<State> & {
    status: 'done';
}) | (Fail<Err> & {
    status: 'fail';
});
interface ConfigPersist {
    pickup?: Unit<any>;
    context?: Unit<any>;
    keyPrefix?: string;
    contract?: Contract<any>;
}
interface ConfigAdapter {
    adapter: StorageAdapter;
}
interface ConfigAdapterFactory<AdapterConfig> {
    adapter: StorageAdapterFactory<AdapterConfig>;
}
interface ConfigCommon<State, Err = Error> {
    clock?: Unit<any>;
    done?: Unit<Done<State>>;
    fail?: Unit<Fail<Err>>;
    finally?: Unit<Finally<State, Err>>;
    pickup?: Unit<any>;
    context?: Unit<any>;
    key?: string;
    keyPrefix?: string;
    contract?: Contract<State | undefined>;
}
interface ConfigJustStore<State> {
    store: Store<State>;
}
interface ConfigJustSourceTarget<State> {
    source: Store<State> | Event<State> | Effect<State, any, any>;
    target: Store<State> | Event<State> | Effect<State, any, any>;
}
interface ConfigStore<State, Err = Error> extends ConfigCommon<State, Err>, ConfigJustStore<State> {
}
interface ConfigSourceTarget<State, Err = Error> extends ConfigCommon<State, Err>, ConfigJustSourceTarget<State> {
}
interface Persist {
    <State, Err = Error>(config: ConfigAdapter & ConfigSourceTarget<State, Err>): Subscription;
    <State, Err = Error>(config: ConfigAdapter & ConfigStore<State, Err>): Subscription;
    <AdapterConfig, State, Err = Error>(config: ConfigAdapterFactory<AdapterConfig> & ConfigSourceTarget<State, Err> & AdapterConfig): Subscription;
    <AdapterConfig, State, Err = Error>(config: ConfigAdapterFactory<AdapterConfig> & ConfigStore<State, Err> & AdapterConfig): Subscription;
}

/**
 * Creates custom `persist`
 */
declare function createPersist(defaults?: ConfigPersist): Persist;
/**
 * Default `persist`
 */
declare const persist: Persist;

export { type ConfigPersist, type ConfigSourceTarget, type ConfigStore, type Contract, type Done, type Fail, type Finally, type Persist, type StorageAdapter, type StorageAdapterFactory, createPersist, persist };
