{"version":3,"file":"index.js","sources":["../../src/core/area.ts","../../src/core/index.ts"],"sourcesContent":["import type { Store } from 'effector'\nimport { createStore } from 'effector'\n\n/**\n * Keys areas / namespaces cache\n */\nconst areas = new Map<any, Map<string, Store<any>>>()\n\n/**\n * Get store, responsible for the key in key area / namespace\n */\nexport function getAreaStorage<State>(keyArea: any, key: string): Store<State> {\n  let area = areas.get(keyArea)\n  if (area === undefined) {\n    area = new Map()\n    areas.set(keyArea, area)\n  }\n\n  let store = area.get(key)\n  if (store !== undefined) {\n    return store\n  }\n\n  store = createStore(null, { serialize: 'ignore' })\n  area.set(key, store)\n\n  return store\n}\n","import type { Effect, Subscription } from 'effector'\nimport type {\n  ConfigAdapter,\n  ConfigAdapterFactory,\n  ConfigPersist,\n  ConfigSourceTarget,\n  ConfigStore,\n  Contract,\n  Done,\n  Fail,\n  Finally,\n} from '../types'\nimport {\n  attach,\n  clearNode,\n  createEvent,\n  createEffect,\n  createNode,\n  createStore,\n  is,\n  sample,\n  scopeBind,\n  withRegion,\n} from 'effector'\nimport { getAreaStorage } from './area'\n\n// helper function to swap two function arguments\n// end extract current context from ref-box\nconst contextual =\n  <T, C, R>(fn: (value: T, ctx?: C) => R) =>\n  ([ref]: [C?], value: T) =>\n    fn(value, ref)\n\n// helper function to validate data with contract\nconst contracted =\n  <T>(contract?: Contract<T>) =>\n  (raw: unknown) =>\n    !contract || // no contract -> data is valid\n    raw === undefined || // `undefined` is always valid\n    ('isData' in contract ? contract.isData(raw) : contract(raw))\n      ? (raw as T)\n      : (() => {\n          throw 'getErrorMessages' in contract\n            ? contract.getErrorMessages(raw)\n            : undefined\n        })()\n\n/**\n * Default sink for unhandled errors\n */\nconst sink = createEvent<Fail<any>>()\nsink.watch((payload) => console.error(payload.error))\n\n/**\n * Main `persist` function\n */\nexport function persist<State, Err = Error>(\n  config: Partial<\n    (ConfigAdapter | ConfigAdapterFactory<any>) &\n      ConfigPersist &\n      ConfigStore<State, Err> &\n      ConfigSourceTarget<State, Err>\n  >\n): Subscription {\n  const {\n    adapter: adapterOrFactory,\n    store,\n    source = store,\n    target = store,\n    clock = source,\n    done,\n    fail = sink,\n    finally: anyway,\n    pickup,\n    context,\n    key: keyName,\n    keyPrefix = '',\n    contract,\n  } = config\n\n  if (!adapterOrFactory) {\n    throw Error('Adapter is not defined')\n  }\n  if (!source) {\n    throw Error('Store or source is not defined')\n  }\n  if (!target) {\n    throw Error('Target is not defined')\n  }\n  if (!keyName && source.shortName === (source as any).id) {\n    throw Error('Key or name is not defined')\n  }\n  if (source === target && !is.store(source)) {\n    throw Error('Source must be different from target')\n  }\n\n  // get default value from store, if given\n  // this is used in adapter factory\n  if ((config as any).def === undefined && is.store(source)) {\n    ;(config as any).def = source.defaultState\n  }\n\n  const adapter =\n    'factory' in adapterOrFactory ? adapterOrFactory(config) : adapterOrFactory\n\n  const key = keyName || source.shortName\n  const storage = getAreaStorage<State>(\n    adapter.keyArea || adapter,\n    keyPrefix + key\n  )\n  const region = createNode()\n  const desist = () => clearNode(region)\n\n  const op =\n    (operation: 'get' | 'set' | 'validate') =>\n    ({ status = 'fail', params, result, error }: any): any =>\n      status === 'done'\n        ? {\n            status,\n            key,\n            keyPrefix,\n            operation,\n            value: operation === 'get' ? result : params,\n          }\n        : {\n            status,\n            key,\n            keyPrefix,\n            operation,\n            value: typeof params === 'function' ? undefined : params, // hide internal \"box\" implementation\n            error,\n          }\n\n  // create all auxiliary units and nodes within the region,\n  // to be able to remove them all at once on unsubscription\n  withRegion(region, () => {\n    const ctx = createStore<[any?]>([], { serialize: 'ignore' })\n\n    const value = adapter<State>(keyPrefix + key, (x) => {\n      update(x)\n    })\n\n    const getFx = attach({\n      source: ctx,\n      effect: contextual(value.get),\n    }) as any as Effect<void, State, Err>\n\n    const setFx = attach({\n      source: ctx,\n      effect: contextual(value.set),\n    }) as any as Effect<State, void, Err>\n\n    const validateFx = createEffect<unknown, State>(contracted(contract))\n\n    const complete = createEvent<Finally<State, Err>>()\n\n    const trigger = createEvent<State>()\n\n    let update: (raw?: any) => any = getFx\n    ctx.updates.watch(() => {\n      update = scopeBind(getFx as any, { safe: true })\n    })\n\n    sample({\n      clock, // `clock` is always defined, as long as `source` is defined\n      source,\n      target: trigger,\n    } as any)\n\n    sample({\n      clock: trigger,\n      source: storage,\n      filter: (current, proposed) => proposed !== current,\n      fn: (_, proposed) => proposed,\n      target: setFx,\n    })\n\n    sample({\n      clock: [getFx.doneData, setFx],\n      filter: <T>(x?: T | undefined): x is T => x !== undefined,\n      target: storage as any,\n    })\n\n    sample({\n      clock: [getFx.doneData, storage],\n      target: validateFx as any,\n    })\n\n    sample({\n      clock: validateFx.doneData,\n      filter: <T>(x?: T | undefined): x is T => x !== undefined,\n      target: target as any,\n    })\n\n    sample({\n      clock: [\n        getFx.finally.map(op('get')),\n        setFx.finally.map(op('set')),\n        validateFx.fail.map(op('validate')),\n      ],\n      target: complete,\n    })\n\n    // effector 23 introduced \"targetable\" types - UnitTargetable, StoreWritable, EventCallable\n    // so, targeting non-targetable unit is not allowed anymore.\n    // soothe typescript by casting to any for a while, until we drop support for effector 22 branch\n    if (anyway) {\n      sample({\n        clock: complete,\n        target: anyway as any,\n      })\n    }\n\n    if (done) {\n      sample({\n        clock: complete,\n        filter: ({ status }) => status === 'done',\n        fn: ({ key, keyPrefix, operation, value }): Done<State> => ({\n          key,\n          keyPrefix,\n          operation,\n          value,\n        }),\n        target: done as any,\n      })\n    }\n\n    sample({\n      clock: complete,\n      filter: ({ status }) => status === 'fail',\n      fn: ({ key, keyPrefix, operation, error, value }: any): Fail<Err> => ({\n        key,\n        keyPrefix,\n        operation,\n        error,\n        value,\n      }),\n      target: fail as any,\n    })\n\n    if (context) {\n      ctx.on(context, ([ref], payload) => [\n        payload === undefined ? ref : payload,\n      ])\n    }\n\n    if (pickup) {\n      // pick up value from storage ONLY on `pickup` update\n      sample({ clock: pickup, fn: () => undefined, target: getFx })\n      ctx.on(pickup, ([ref], payload) => [\n        payload === undefined ? ref : payload,\n      ])\n    } else {\n      // kick getter to pick up initial value from storage\n      getFx()\n    }\n  })\n\n  return (desist.unsubscribe = desist)\n}\n"],"names":["areas","Map","contextual","fn","ref","value","sink","createEvent","persist","config","adapter","adapterOrFactory","store","source","target","clock","done","fail","finally","anyway","pickup","context","key","keyName","keyPrefix","contract","Error","shortName","id","is","undefined","def","defaultState","storage","keyArea","area","get","set","createStore","serialize","getAreaStorage","region","createNode","desist","clearNode","op","operation","status","params","result","error","withRegion","ctx","x","update","getFx","attach","effect","setFx","validateFx","createEffect","raw","isData","getErrorMessages","contracted","complete","trigger","updates","watch","scopeBind","safe","sample","filter","current","proposed","_","doneData","map","on","payload","unsubscribe","console"],"mappings":"wKAMA,IAAMA,EAAQ,IAAIC,ICsBZC,EACMC,GACV,EAAEC,GAAYC,IACZF,EAAGE,EAAOD,GAmBRE,EAAOC,IAMN,SAASC,EACdC,GAOA,IACEC,QAASC,EAAgBC,MACzBA,EAAKC,OACLA,EAASD,EAAKE,OACdA,EAASF,EAAKG,MACdA,EAAQF,EAAMG,KACdA,EAAIC,KACJA,EAAOX,EACPY,QAASC,EAAMC,OACfA,EAAMC,QACNA,EACAC,IAAKC,EAAOC,UACZA,EAAY,GAAEC,SACdA,GACEhB,EAEJ,IAAKE,EACH,MAAMe,MAAM,0BAEd,IAAKb,EACH,MAAMa,MAAM,kCAEd,IAAKZ,EACH,MAAMY,MAAM,yBAEd,IAAKH,GAAWV,EAAOc,YAAed,EAAee,GACnD,MAAMF,MAAM,8BAEd,GAAIb,IAAWC,IAAWe,EAAGjB,MAAMC,GACjC,MAAMa,MAAM,6CAKcI,IAAvBrB,EAAesB,KAAqBF,EAAGjB,MAAMC,KAC9CJ,EAAesB,IAAMlB,EAAOmB,cAGhC,IAAMtB,EACJ,YAAaC,EAAmBA,EAAiBF,GAAUE,EAEvDW,EAAMC,GAAWV,EAAOc,UACxBM,ED/FD,SAA+BC,EAAcZ,GAClD,IAAIa,EAAOnC,EAAMoC,IAAIF,QACRJ,IAATK,IACFA,EAAO,IAAIlC,IACXD,EAAMqC,IAAIH,EAASC,IAGrB,IAAIvB,EAAQuB,EAAKC,IAAId,GACrB,YAAcQ,IAAVlB,IAIJA,EAAQ0B,EAAY,KAAM,CAAEC,UAAW,WACvCJ,EAAKE,IAAIf,EAAKV,IAJLA,CAOX,CC+EkB4B,CACd9B,EAAQwB,SAAWxB,EACnBc,EAAYF,GAERmB,EAASC,IACTC,EAASA,IAAMC,EAAUH,GAEzBI,EACHC,GACD,EAAGC,SAAS,OAAQC,SAAQC,SAAQC,WACvB,SAAXH,EACI,CACEA,SACAzB,MACAE,YACAsB,YACAzC,MAAqB,QAAdyC,EAAsBG,EAASD,GAExC,CACED,SACAzB,MACAE,YACAsB,YACAzC,MAAyB,mBAAX2C,OAAwBlB,EAAYkB,EAClDE,SAgIV,OA3HAC,EAAWV,GAAQ,KACjB,IAAMW,EAAMd,EAAoB,GAAI,CAAEC,UAAW,WAE3ClC,EAAQK,EAAec,EAAYF,GAAM+B,IAC7CC,EAAOD,EAAE,IAGLE,EAAQC,EAAO,CACnB3C,OAAQuC,EACRK,OAAQvD,EAAWG,EAAM+B,OAGrBsB,EAAQF,EAAO,CACnB3C,OAAQuC,EACRK,OAAQvD,EAAWG,EAAMgC,OAGrBsB,EAAaC,EArHjBnC,IACHoC,IACEpC,QACOK,IAAR+B,IACC,WAAYpC,EAAWA,EAASqC,OAAOD,GAAOpC,EAASoC,IACnDA,EACD,MACE,KAAM,qBAAsBpC,EACxBA,EAASsC,iBAAiBF,QAC1B/B,CACL,EAJD,GA+G4CkC,CAAWvC,IAErDwC,EAAW1D,IAEX2D,EAAU3D,IAEZ+C,EAA6BC,EACjCH,EAAIe,QAAQC,OAAM,KAChBd,EAASe,EAAUd,EAAc,CAAEe,MAAM,GAAO,IAGlDC,EAAO,CACLxD,QACAF,SACAC,OAAQoD,IAGVK,EAAO,CACLxD,MAAOmD,EACPrD,OAAQoB,EACRuC,OAAQA,CAACC,EAASC,IAAaA,IAAaD,EAC5CtE,GAAIA,CAACwE,EAAGD,IAAaA,EACrB5D,OAAQ4C,IAGVa,EAAO,CACLxD,MAAO,CAACwC,EAAMqB,SAAUlB,GACxBc,OAAYnB,QAAoCvB,IAANuB,EAC1CvC,OAAQmB,IAGVsC,EAAO,CACLxD,MAAO,CAACwC,EAAMqB,SAAU3C,GACxBnB,OAAQ6C,IAGVY,EAAO,CACLxD,MAAO4C,EAAWiB,SAClBJ,OAAYnB,QAAoCvB,IAANuB,EAC1CvC,OAAQA,IAGVyD,EAAO,CACLxD,MAAO,CACLwC,EAAMrC,QAAQ2D,IAAIhC,EAAG,QACrBa,EAAMxC,QAAQ2D,IAAIhC,EAAG,QACrBc,EAAW1C,KAAK4D,IAAIhC,EAAG,cAEzB/B,OAAQmD,IAMN9C,GACFoD,EAAO,CACLxD,MAAOkD,EACPnD,OAAQK,IAIRH,GACFuD,EAAO,CACLxD,MAAOkD,EACPO,OAAQA,EAAGzB,YAAwB,SAAXA,EACxB5C,GAAIA,EAAGmB,MAAKE,YAAWsB,YAAWzC,YAA0B,CAC1DiB,MACAE,YACAsB,YACAzC,UAEFS,OAAQE,IAIZuD,EAAO,CACLxD,MAAOkD,EACPO,OAAQA,EAAGzB,YAAwB,SAAXA,EACxB5C,GAAIA,EAAGmB,MAAKE,YAAWsB,YAAWI,QAAO7C,YAA6B,CACpEiB,MACAE,YACAsB,YACAI,QACA7C,UAEFS,OAAQG,IAGNI,GACF+B,EAAI0B,GAAGzD,GAAS,EAAEjB,GAAM2E,IAAY,MACtBjD,IAAZiD,EAAwB3E,EAAM2E,KAI9B3D,GAEFmD,EAAO,CAAExD,MAAOK,EAAQjB,GAAIA,KAAe,EAAEW,OAAQyC,IACrDH,EAAI0B,GAAG1D,GAAQ,EAAEhB,GAAM2E,IAAY,MACrBjD,IAAZiD,EAAwB3E,EAAM2E,MAIhCxB,GACF,IAGMZ,EAAOqC,YAAcrC,CAC/B,CAhNArC,EAAK8D,OAAOW,GAAYE,QAAQ/B,MAAM6B,EAAQ7B"}