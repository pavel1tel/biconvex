import{createStore as e,createEvent as r,is as t,createNode as o,withRegion as a,attach as i,createEffect as f,scopeBind as n,sample as s,clearNode as c}from"effector";var l=new Map,d=e=>([r],t)=>e(t,r),u=r();function k(k){var{adapter:g,store:v,source:y=v,target:p=v,clock:m=y,done:h,fail:w=u,finally:x,pickup:E,context:P,key:D,keyPrefix:M="",contract:b}=k;if(!g)throw Error("Adapter is not defined");if(!y)throw Error("Store or source is not defined");if(!p)throw Error("Target is not defined");if(!D&&y.shortName===y.id)throw Error("Key or name is not defined");if(y===p&&!t.store(y))throw Error("Source must be different from target");void 0===k.def&&t.store(y)&&(k.def=y.defaultState);var S="factory"in g?g(k):g,z=D||y.shortName,A=function(r,t){var o=l.get(r);void 0===o&&(o=new Map,l.set(r,o));var a=o.get(t);return void 0!==a||(a=e(null,{serialize:"ignore"}),o.set(t,a)),a}(S.keyArea||S,M+z),N=o(),K=()=>c(N),T=e=>({status:r="fail",params:t,result:o,error:a})=>"done"===r?{status:r,key:z,keyPrefix:M,operation:e,value:"get"===e?o:t}:{status:r,key:z,keyPrefix:M,operation:e,value:"function"==typeof t?void 0:t,error:a};return a(N,(()=>{var t=e([],{serialize:"ignore"}),o=S(M+z,(e=>{g(e)})),a=i({source:t,effect:d(o.get)}),c=i({source:t,effect:d(o.set)}),l=f((e=>r=>!e||void 0===r||("isData"in e?e.isData(r):e(r))?r:(()=>{throw"getErrorMessages"in e?e.getErrorMessages(r):void 0})())(b)),u=r(),k=r(),g=a;t.updates.watch((()=>{g=n(a,{safe:!0})})),s({clock:m,source:y,target:k}),s({clock:k,source:A,filter:(e,r)=>r!==e,fn:(e,r)=>r,target:c}),s({clock:[a.doneData,c],filter:e=>void 0!==e,target:A}),s({clock:[a.doneData,A],target:l}),s({clock:l.doneData,filter:e=>void 0!==e,target:p}),s({clock:[a.finally.map(T("get")),c.finally.map(T("set")),l.fail.map(T("validate"))],target:u}),x&&s({clock:u,target:x}),h&&s({clock:u,filter:({status:e})=>"done"===e,fn:({key:e,keyPrefix:r,operation:t,value:o})=>({key:e,keyPrefix:r,operation:t,value:o}),target:h}),s({clock:u,filter:({status:e})=>"fail"===e,fn:({key:e,keyPrefix:r,operation:t,error:o,value:a})=>({key:e,keyPrefix:r,operation:t,error:o,value:a}),target:w}),P&&t.on(P,(([e],r)=>[void 0===r?e:r])),E?(s({clock:E,fn:()=>{},target:a}),t.on(E,(([e],r)=>[void 0===r?e:r]))):a()})),K.unsubscribe=K}u.watch((e=>console.error(e.error)));export{k as persist};
//# sourceMappingURL=index.js.map
