/**
 * Flowtype definitions for index
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.21.0
 * @flow
 */

import { Unit, Store, Event, Effect, Subscription } from "effector";
declare interface StorageAdapter {
  <State>(
    key: string,
    update: (raw?: any) => void
  ): {
    get(raw?: any, ctx?: any): State | Promise<State | void> | void,
    set(value: State, ctx?: any): void,
    ...
  };
  keyArea?: any;
  noop?: boolean;
}
declare interface StorageAdapterFactory<AdapterConfig> {
  (config?: AdapterConfig): StorageAdapter;
  factory: true;
}
declare type Contract<Data> =
  | ((raw: mixed) => boolean)
  | {
      isData: (raw: mixed) => boolean,
      getErrorMessages: (raw: mixed) => string[],
      ...
    };
declare type Done<State> = {
  key: string,
  keyPrefix: string,
  operation: "set" | "get",
  value: State,
  ...
};
declare type Fail<Err> = {
  key: string,
  keyPrefix: string,
  operation: "set" | "get",
  error: Err,
  value?: any,
  ...
};
declare type Finally<State, Err> =
  | {
      ...Done<State>,
      ...{
        status: "done",
        ...
      },
    }
  | {
      ...Fail<Err>,
      ...{
        status: "fail",
        ...
      },
    };
declare interface ConfigPersist {
  pickup?: Unit<any>;
  context?: Unit<any>;
  keyPrefix?: string;
  contract?: Contract<any>;
}
declare interface ConfigAdapter {
  adapter: StorageAdapter;
}
declare interface ConfigAdapterFactory<AdapterConfig> {
  adapter: StorageAdapterFactory<AdapterConfig>;
}
declare interface ConfigCommon<State, Err = Error> {
  clock?: Unit<any>;
  done?: Unit<Done<State>>;
  fail?: Unit<Fail<Err>>;
  finally?: Unit<Finally<State, Err>>;
  pickup?: Unit<any>;
  context?: Unit<any>;
  key?: string;
  keyPrefix?: string;
  contract?: Contract<State | void>;
}
declare interface ConfigJustStore<State> {
  store: Store<State>;
}
declare interface ConfigJustSourceTarget<State> {
  source: Store<State> | Event<State> | Effect<State, any, any>;
  target: Store<State> | Event<State> | Effect<State, any, any>;
}
declare type ConfigStore<State, Err = Error> = { ... } & ConfigCommon<
  State,
  Err
> &
  ConfigJustStore<State>;
declare type ConfigSourceTarget<State, Err = Error> = { ... } & ConfigCommon<
  State,
  Err
> &
  ConfigJustSourceTarget<State>;
declare function persist<State, Err>(
  config: $Rest<
    {
      ...ConfigAdapter | ConfigAdapterFactory<any>,
      ...ConfigPersist,
      ...ConfigStore<State, Err>,
      ...ConfigSourceTarget<State, Err>,
    },
    { ... }
  >
): Subscription;
declare export { persist };
