{"version":3,"file":"index.cjs","sources":["../../src/core/area.ts","../../src/core/index.ts"],"sourcesContent":["import type { Store } from 'effector'\nimport { createStore } from 'effector'\n\n/**\n * Keys areas / namespaces cache\n */\nconst areas = new Map<any, Map<string, Store<any>>>()\n\n/**\n * Get store, responsible for the key in key area / namespace\n */\nexport function getAreaStorage<State>(keyArea: any, key: string): Store<State> {\n  let area = areas.get(keyArea)\n  if (area === undefined) {\n    area = new Map()\n    areas.set(keyArea, area)\n  }\n\n  let store = area.get(key)\n  if (store !== undefined) {\n    return store\n  }\n\n  store = createStore(null, { serialize: 'ignore' })\n  area.set(key, store)\n\n  return store\n}\n","import type { Effect, Subscription } from 'effector'\nimport type {\n  ConfigAdapter,\n  ConfigAdapterFactory,\n  ConfigPersist,\n  ConfigSourceTarget,\n  ConfigStore,\n  Contract,\n  Done,\n  Fail,\n  Finally,\n} from '../types'\nimport {\n  attach,\n  clearNode,\n  createEvent,\n  createEffect,\n  createNode,\n  createStore,\n  is,\n  sample,\n  scopeBind,\n  withRegion,\n} from 'effector'\nimport { getAreaStorage } from './area'\n\n// helper function to swap two function arguments\n// end extract current context from ref-box\nconst contextual =\n  <T, C, R>(fn: (value: T, ctx?: C) => R) =>\n  ([ref]: [C?], value: T) =>\n    fn(value, ref)\n\n// helper function to validate data with contract\nconst contracted =\n  <T>(contract?: Contract<T>) =>\n  (raw: unknown) =>\n    !contract || // no contract -> data is valid\n    raw === undefined || // `undefined` is always valid\n    ('isData' in contract ? contract.isData(raw) : contract(raw))\n      ? (raw as T)\n      : (() => {\n          throw 'getErrorMessages' in contract\n            ? contract.getErrorMessages(raw)\n            : undefined\n        })()\n\n/**\n * Default sink for unhandled errors\n */\nconst sink = createEvent<Fail<any>>()\nsink.watch((payload) => console.error(payload.error))\n\n/**\n * Main `persist` function\n */\nexport function persist<State, Err = Error>(\n  config: Partial<\n    (ConfigAdapter | ConfigAdapterFactory<any>) &\n      ConfigPersist &\n      ConfigStore<State, Err> &\n      ConfigSourceTarget<State, Err>\n  >\n): Subscription {\n  const {\n    adapter: adapterOrFactory,\n    store,\n    source = store,\n    target = store,\n    clock = source,\n    done,\n    fail = sink,\n    finally: anyway,\n    pickup,\n    context,\n    key: keyName,\n    keyPrefix = '',\n    contract,\n  } = config\n\n  if (!adapterOrFactory) {\n    throw Error('Adapter is not defined')\n  }\n  if (!source) {\n    throw Error('Store or source is not defined')\n  }\n  if (!target) {\n    throw Error('Target is not defined')\n  }\n  if (!keyName && source.shortName === (source as any).id) {\n    throw Error('Key or name is not defined')\n  }\n  if (source === target && !is.store(source)) {\n    throw Error('Source must be different from target')\n  }\n\n  // get default value from store, if given\n  // this is used in adapter factory\n  if ((config as any).def === undefined && is.store(source)) {\n    ;(config as any).def = source.defaultState\n  }\n\n  const adapter =\n    'factory' in adapterOrFactory ? adapterOrFactory(config) : adapterOrFactory\n\n  const key = keyName || source.shortName\n  const storage = getAreaStorage<State>(\n    adapter.keyArea || adapter,\n    keyPrefix + key\n  )\n  const region = createNode()\n  const desist = () => clearNode(region)\n\n  const op =\n    (operation: 'get' | 'set' | 'validate') =>\n    ({ status = 'fail', params, result, error }: any): any =>\n      status === 'done'\n        ? {\n            status,\n            key,\n            keyPrefix,\n            operation,\n            value: operation === 'get' ? result : params,\n          }\n        : {\n            status,\n            key,\n            keyPrefix,\n            operation,\n            value: typeof params === 'function' ? undefined : params, // hide internal \"box\" implementation\n            error,\n          }\n\n  // create all auxiliary units and nodes within the region,\n  // to be able to remove them all at once on unsubscription\n  withRegion(region, () => {\n    const ctx = createStore<[any?]>([], { serialize: 'ignore' })\n\n    const value = adapter<State>(keyPrefix + key, (x) => {\n      update(x)\n    })\n\n    const getFx = attach({\n      source: ctx,\n      effect: contextual(value.get),\n    }) as any as Effect<void, State, Err>\n\n    const setFx = attach({\n      source: ctx,\n      effect: contextual(value.set),\n    }) as any as Effect<State, void, Err>\n\n    const validateFx = createEffect<unknown, State>(contracted(contract))\n\n    const complete = createEvent<Finally<State, Err>>()\n\n    const trigger = createEvent<State>()\n\n    let update: (raw?: any) => any = getFx\n    ctx.updates.watch(() => {\n      update = scopeBind(getFx as any, { safe: true })\n    })\n\n    sample({\n      clock, // `clock` is always defined, as long as `source` is defined\n      source,\n      target: trigger,\n    } as any)\n\n    sample({\n      clock: trigger,\n      source: storage,\n      filter: (current, proposed) => proposed !== current,\n      fn: (_, proposed) => proposed,\n      target: setFx,\n    })\n\n    sample({\n      clock: [getFx.doneData, setFx],\n      filter: <T>(x?: T | undefined): x is T => x !== undefined,\n      target: storage as any,\n    })\n\n    sample({\n      clock: [getFx.doneData, storage],\n      target: validateFx as any,\n    })\n\n    sample({\n      clock: validateFx.doneData,\n      filter: <T>(x?: T | undefined): x is T => x !== undefined,\n      target: target as any,\n    })\n\n    sample({\n      clock: [\n        getFx.finally.map(op('get')),\n        setFx.finally.map(op('set')),\n        validateFx.fail.map(op('validate')),\n      ],\n      target: complete,\n    })\n\n    // effector 23 introduced \"targetable\" types - UnitTargetable, StoreWritable, EventCallable\n    // so, targeting non-targetable unit is not allowed anymore.\n    // soothe typescript by casting to any for a while, until we drop support for effector 22 branch\n    if (anyway) {\n      sample({\n        clock: complete,\n        target: anyway as any,\n      })\n    }\n\n    if (done) {\n      sample({\n        clock: complete,\n        filter: ({ status }) => status === 'done',\n        fn: ({ key, keyPrefix, operation, value }): Done<State> => ({\n          key,\n          keyPrefix,\n          operation,\n          value,\n        }),\n        target: done as any,\n      })\n    }\n\n    sample({\n      clock: complete,\n      filter: ({ status }) => status === 'fail',\n      fn: ({ key, keyPrefix, operation, error, value }: any): Fail<Err> => ({\n        key,\n        keyPrefix,\n        operation,\n        error,\n        value,\n      }),\n      target: fail as any,\n    })\n\n    if (context) {\n      ctx.on(context, ([ref], payload) => [\n        payload === undefined ? ref : payload,\n      ])\n    }\n\n    if (pickup) {\n      // pick up value from storage ONLY on `pickup` update\n      sample({ clock: pickup, fn: () => undefined, target: getFx })\n      ctx.on(pickup, ([ref], payload) => [\n        payload === undefined ? ref : payload,\n      ])\n    } else {\n      // kick getter to pick up initial value from storage\n      getFx()\n    }\n  })\n\n  return (desist.unsubscribe = desist)\n}\n"],"names":["areas","Map","contextual","fn","ref","value","sink","createEvent","watch","payload","console","error","config","adapter","adapterOrFactory","store","source","target","clock","done","fail","finally","anyway","pickup","context","key","keyName","keyPrefix","contract","Error","shortName","id","is","undefined","def","defaultState","storage","keyArea","area","get","set","createStore","serialize","getAreaStorage","region","createNode","desist","clearNode","op","operation","status","params","result","withRegion","ctx","x","update","getFx","attach","effect","setFx","validateFx","createEffect","raw","isData","getErrorMessages","contracted","complete","trigger","updates","scopeBind","safe","sample","filter","current","proposed","_","doneData","map","on","unsubscribe"],"mappings":"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"}