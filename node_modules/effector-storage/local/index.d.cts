import { Unit, Store, Event, Effect, Subscription } from 'effector';

interface StorageAdapter {
    <State>(key: string, update: (raw?: any) => void): {
        get(raw?: any, ctx?: any): State | Promise<State | undefined> | undefined;
        set(value: State, ctx?: any): void;
    };
    keyArea?: any;
    noop?: boolean;
}
interface StorageAdapterFactory<AdapterConfig> {
    (config?: AdapterConfig): StorageAdapter;
    factory: true;
}
type Contract<Data> = ((raw: unknown) => raw is Data) | {
    isData: (raw: unknown) => raw is Data;
    getErrorMessages: (raw: unknown) => string[];
};
type Done<State> = {
    key: string;
    keyPrefix: string;
    operation: 'set' | 'get';
    value: State;
};
type Fail<Err> = {
    key: string;
    keyPrefix: string;
    operation: 'set' | 'get';
    error: Err;
    value?: any;
};
type Finally<State, Err> = (Done<State> & {
    status: 'done';
}) | (Fail<Err> & {
    status: 'fail';
});
interface ConfigPersist$1 {
    pickup?: Unit<any>;
    context?: Unit<any>;
    keyPrefix?: string;
    contract?: Contract<any>;
}
interface ConfigCommon<State, Err = Error> {
    clock?: Unit<any>;
    done?: Unit<Done<State>>;
    fail?: Unit<Fail<Err>>;
    finally?: Unit<Finally<State, Err>>;
    pickup?: Unit<any>;
    context?: Unit<any>;
    key?: string;
    keyPrefix?: string;
    contract?: Contract<State | undefined>;
}
interface ConfigJustStore<State> {
    store: Store<State>;
}
interface ConfigJustSourceTarget<State> {
    source: Store<State> | Event<State> | Effect<State, any, any>;
    target: Store<State> | Event<State> | Effect<State, any, any>;
}
interface ConfigStore$1<State, Err = Error> extends ConfigCommon<State, Err>, ConfigJustStore<State> {
}
interface ConfigSourceTarget$1<State, Err = Error> extends ConfigCommon<State, Err>, ConfigJustSourceTarget<State> {
}

interface ConfigPersist extends ConfigPersist$1 {
    sync?: boolean | 'force';
    timeout?: number;
}
interface LocalStorageConfig {
    sync?: boolean | 'force';
    serialize?: (value: any) => string;
    deserialize?: (value: string) => any;
    timeout?: number;
    def?: any;
}
interface ConfigStore<State, Err = Error> extends LocalStorageConfig, ConfigStore$1<State, Err> {
}
interface ConfigSourceTarget<State, Err = Error> extends LocalStorageConfig, ConfigSourceTarget$1<State, Err> {
}
interface Persist {
    <State, Err = Error>(config: ConfigSourceTarget<State, Err>): Subscription;
    <State, Err = Error>(config: ConfigStore<State, Err>): Subscription;
}
declare function local(config?: LocalStorageConfig): StorageAdapter;
declare namespace local {
    var factory: true;
}
/**
 * Creates custom partially applied `persist`
 * with predefined `localStorage` adapter
 */
declare function createPersist(defaults?: ConfigPersist): Persist;
/**
 * Default partially applied `persist`
 */
declare const persist: Persist;

export { type ConfigPersist, type ConfigSourceTarget, type ConfigStore, type Contract, type Done, type Fail, type Finally, type LocalStorageConfig, type Persist, type StorageAdapter, type StorageAdapterFactory, createPersist, local, persist };
