import { Unit, Store, Event, Effect, Subscription } from 'effector';

interface StorageAdapter {
    <State>(key: string, update: (raw?: any) => void): {
        get(raw?: any, ctx?: any): State | Promise<State | undefined> | undefined;
        set(value: State, ctx?: any): void;
    };
    keyArea?: any;
    noop?: boolean;
}
interface StorageAdapterFactory<AdapterConfig> {
    (config?: AdapterConfig): StorageAdapter;
    factory: true;
}
type Contract<Data> = ((raw: unknown) => raw is Data) | {
    isData: (raw: unknown) => raw is Data;
    getErrorMessages: (raw: unknown) => string[];
};
type Done<State> = {
    key: string;
    keyPrefix: string;
    operation: 'set' | 'get';
    value: State;
};
type Fail<Err> = {
    key: string;
    keyPrefix: string;
    operation: 'set' | 'get';
    error: Err;
    value?: any;
};
type Finally<State, Err> = (Done<State> & {
    status: 'done';
}) | (Fail<Err> & {
    status: 'fail';
});
interface ConfigPersist$1 {
    pickup?: Unit<any>;
    context?: Unit<any>;
    keyPrefix?: string;
    contract?: Contract<any>;
}
interface ConfigCommon<State, Err = Error> {
    clock?: Unit<any>;
    done?: Unit<Done<State>>;
    fail?: Unit<Fail<Err>>;
    finally?: Unit<Finally<State, Err>>;
    pickup?: Unit<any>;
    context?: Unit<any>;
    key?: string;
    keyPrefix?: string;
    contract?: Contract<State | undefined>;
}
interface ConfigJustStore<State> {
    store: Store<State>;
}
interface ConfigJustSourceTarget<State> {
    source: Store<State> | Event<State> | Effect<State, any, any>;
    target: Store<State> | Event<State> | Effect<State, any, any>;
}
interface ConfigStore$1<State, Err = Error> extends ConfigCommon<State, Err>, ConfigJustStore<State> {
}
interface ConfigSourceTarget$1<State, Err = Error> extends ConfigCommon<State, Err>, ConfigJustSourceTarget<State> {
}

type ChangeMethod = (params: URLSearchParams | string, erase?: boolean) => void;
type StateBehavior = 'keep' | 'erase';
interface QueryConfig {
    method?: ChangeMethod;
    state?: StateBehavior;
    serialize?: (value: any) => string;
    deserialize?: (value: string) => any;
    timeout?: number;
    def?: any;
}
declare const pushState: ChangeMethod;
declare const replaceState: ChangeMethod;
declare const locationAssign: ChangeMethod;
declare const locationReplace: ChangeMethod;

interface ConfigPersist extends ConfigPersist$1 {
    method?: ChangeMethod;
    state?: StateBehavior;
    timeout?: number;
}
interface ConfigStore<State, Err = Error> extends QueryConfig, ConfigStore$1<State, Err> {
}
interface ConfigSourceTarget<State, Err = Error> extends QueryConfig, ConfigSourceTarget$1<State, Err> {
}
interface Persist {
    <State, Err = Error>(config: ConfigSourceTarget<State, Err>): Subscription;
    <State, Err = Error>(config: ConfigStore<State, Err>): Subscription;
}
declare function query(config?: QueryConfig): StorageAdapter;
declare namespace query {
    var factory: true;
}
/**
 * Creates custom partially applied `persist`
 * with predefined `query` adapter
 */
declare function createPersist(defaults?: ConfigPersist): Persist;
/**
 * Default partially applied `persist`
 */
declare const persist: Persist;

export { type ChangeMethod, type ConfigPersist, type ConfigSourceTarget, type ConfigStore, type Contract, type Done, type Fail, type Finally, type Persist, type QueryConfig, type StateBehavior, type StorageAdapter, type StorageAdapterFactory, createPersist, locationAssign, locationReplace, persist, pushState, query, replaceState };
