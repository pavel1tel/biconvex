/**
 * Flowtype definitions for index
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.21.0
 * @flow
 */

import { Unit, Store, Event, Effect, Subscription } from "effector";
declare interface StorageAdapter {
  <State>(
    key: string,
    update: (raw?: any) => void
  ): {
    get(raw?: any, ctx?: any): State | Promise<State | void> | void,
    set(value: State, ctx?: any): void,
    ...
  };
  keyArea?: any;
  noop?: boolean;
}
declare interface StorageAdapterFactory<AdapterConfig> {
  (config?: AdapterConfig): StorageAdapter;
  factory: true;
}
declare type Contract<Data> =
  | ((raw: mixed) => boolean)
  | {
      isData: (raw: mixed) => boolean,
      getErrorMessages: (raw: mixed) => string[],
      ...
    };
declare type Done<State> = {
  key: string,
  keyPrefix: string,
  operation: "set" | "get",
  value: State,
  ...
};
declare type Fail<Err> = {
  key: string,
  keyPrefix: string,
  operation: "set" | "get",
  error: Err,
  value?: any,
  ...
};
declare type Finally<State, Err> =
  | {
      ...Done<State>,
      ...{
        status: "done",
        ...
      },
    }
  | {
      ...Fail<Err>,
      ...{
        status: "fail",
        ...
      },
    };
declare interface ConfigPersist$1 {
  pickup?: Unit<any>;
  context?: Unit<any>;
  keyPrefix?: string;
  contract?: Contract<any>;
}
declare interface ConfigCommon<State, Err = Error> {
  clock?: Unit<any>;
  done?: Unit<Done<State>>;
  fail?: Unit<Fail<Err>>;
  finally?: Unit<Finally<State, Err>>;
  pickup?: Unit<any>;
  context?: Unit<any>;
  key?: string;
  keyPrefix?: string;
  contract?: Contract<State | void>;
}
declare interface ConfigJustStore<State> {
  store: Store<State>;
}
declare interface ConfigJustSourceTarget<State> {
  source: Store<State> | Event<State> | Effect<State, any, any>;
  target: Store<State> | Event<State> | Effect<State, any, any>;
}
declare type ConfigStore$1<State, Err = Error> = { ... } & ConfigCommon<
  State,
  Err
> &
  ConfigJustStore<State>;
declare type ConfigSourceTarget$1<State, Err = Error> = { ... } & ConfigCommon<
  State,
  Err
> &
  ConfigJustSourceTarget<State>;
declare type ChangeMethod = (
  params: URLSearchParams | string,
  erase?: boolean
) => void;
declare type StateBehavior = "keep" | "erase";
declare interface QueryConfig {
  method?: ChangeMethod;
  state?: StateBehavior;
  serialize?: (value: any) => string;
  deserialize?: (value: string) => any;
  timeout?: number;
  def?: any;
}
declare var pushState: ChangeMethod;
declare var replaceState: ChangeMethod;
declare var locationAssign: ChangeMethod;
declare var locationReplace: ChangeMethod;
declare type ConfigPersist = {
  method?: ChangeMethod,
  state?: StateBehavior,
  timeout?: number,
  ...
} & ConfigPersist$1;
declare type ConfigStore<State, Err = Error> = { ... } & QueryConfig &
  ConfigStore$1<State, Err>;
declare type ConfigSourceTarget<State, Err = Error> = { ... } & QueryConfig &
  ConfigSourceTarget$1<State, Err>;
declare interface Persist {
  <State, Err>(config: ConfigSourceTarget<State, Err>): Subscription;
  <State, Err>(config: ConfigStore<State, Err>): Subscription;
}
declare var query: typeof npm$namespace$query;

declare var npm$namespace$query: {|
  (config?: QueryConfig): StorageAdapter,
  factory: typeof query$factory,
|};
declare var query$factory: true;
declare function createPersist(defaults?: ConfigPersist): Persist;
declare var persist: Persist;
export type {
  ChangeMethod,
  ConfigPersist,
  ConfigSourceTarget,
  ConfigStore,
  Contract,
  Done,
  Fail,
  Finally,
  Persist,
  QueryConfig,
  StateBehavior,
  StorageAdapter,
  StorageAdapterFactory,
};
declare export {
  createPersist,
  locationAssign,
  locationReplace,
  persist,
  pushState,
  query,
  replaceState,
};
