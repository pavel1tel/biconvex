import { Store, Effect, EventCallable } from 'effector';

interface StorageAdapter {
    <State>(key: string, update: (raw?: any) => void): {
        get(raw?: any, ctx?: any): State | Promise<State | undefined> | undefined;
        set(value: State, ctx?: any): void;
    };
    keyArea?: any;
    noop?: boolean;
}
interface StorageAdapterFactory<AdapterConfig> {
    (config?: AdapterConfig): StorageAdapter;
    factory: true;
}

/**
 * Makes synchronous storage adapter asynchronous
 */
declare function async<A extends StorageAdapter | StorageAdapterFactory<any>>(adapter: A): A extends StorageAdapterFactory<infer T> ? StorageAdapterFactory<T> : StorageAdapter;

/**
 * Returns first adapter, if it is not noop, and second otherwise.
 *
 * In this example,
 *  - adapter for localStorage will be used in browser environment,
 *  - logging adapter will be used in node environment
 *
 * persist({
 *   store: $store,
 *   adapter: either(local(), log()),
 *   key: 'store'
 * })
 *
 * could be also used with factories
 *
 * persist({
 *   store: $store,
 *   adapter: either(local, log),
 *   key: 'store'
 * })
 *
 * or even mixed
 *
 * persist({
 *   store: $store,
 *   adapter: either(local, log()),
 *   key: 'store'
 * })
 */
declare function either<A1 extends StorageAdapter | StorageAdapterFactory<any>, A2 extends StorageAdapter | StorageAdapterFactory<any>>(one: A1, another: A2): A1 extends StorageAdapterFactory<infer T1> ? A2 extends StorageAdapterFactory<infer T2> ? StorageAdapterFactory<T1 & T2> : StorageAdapterFactory<T1> : A2 extends StorageAdapterFactory<infer T2> ? StorageAdapterFactory<T2> : StorageAdapter;

interface CacheAdapterInstance {
    get: Effect<{
        key: string;
    }, {
        value: unknown;
        cachedAt: number;
    } | null>;
    set: Effect<{
        key: string;
        value: unknown;
    }, void>;
    purge: EventCallable<void>;
    unset: Effect<{
        key: string;
    }, void>;
}
interface CacheAdapter extends CacheAdapterInstance {
    __: {
        $instance: Store<CacheAdapterInstance>;
    };
}

/**
 * Wraps @farfetched/core cache adapter to be used as `persist` adapter :)
 * @see https://farfetched.pages.dev/api/operators/cache.html
 *
 * persist({
 *   store: $store,
 *   adapter: farcached(localStorageCache({ maxAge: '15m' })),
 *   key: 'store'
 * })
 *
 * Out of the box Farfetched provides 4 cache adapters:
 * - `inMemoryCache`
 * - `sessionStorageCache`
 * - `localStorageCache`
 * - `voidCache` (this one is noop)
 *
 * From real usage point of view, using Farfetched cache adapters could be useful,
 * when you need logic for cache invalidation, because all of provided adapters
 * have `maxAge` option.
 *
 * Also, you could use Farfetched cache adapters to inject different
 * cache adapters with `fork` using `cache.__.$instance` internal store.
 * @see https://farfetched.pages.dev/recipes/server_cache.html#inject-adapter
 */
declare function farcached(adapter: CacheAdapter, keyArea?: any): StorageAdapter;

export { async, either, farcached };
