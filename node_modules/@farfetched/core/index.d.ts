import * as effector from 'effector';
import { Json, createStore, Store, EventPayload, EventCallable, Event, Effect, StoreWritable, Subscription } from 'effector';
export { Json } from 'effector';

interface Contract<Raw, Data extends Raw> {
    /**
     * Checks if Raw is some Data
     */
    isData: (prepared: Raw) => prepared is Data;
    /**
     * - empty array is dedicated for valid response
     * - array of string with validation erorrs for invalidDataError
     */
    getErrorMessages: (prepared: Raw) => string[];
}

declare const unknownContract: Contract<unknown, unknown>;

declare type FarfetchedError<T extends string> = {
    errorType: T;
    explanation: string;
};
declare const INVALID_DATA = "INVALID_DATA";
interface InvalidDataError extends FarfetchedError<typeof INVALID_DATA> {
    validationErrors: string[];
    response: unknown;
}
declare const TIMEOUT = "TIMEOUT";
interface TimeoutError extends FarfetchedError<typeof TIMEOUT> {
    timeout: number;
}
declare const ABORT = "ABORT";
interface AbortError extends FarfetchedError<typeof ABORT> {
}
declare const PREPARATION = "PREPARATION";
interface PreparationError extends FarfetchedError<typeof PREPARATION> {
    response: string;
    reason: string | null;
}
declare const HTTP = "HTTP";
interface HttpError<Status extends number = number> extends FarfetchedError<typeof HTTP> {
    status: Status;
    statusText: string;
    response: string | Json | null;
}
declare const NETWORK = "NETWORK";
interface NetworkError extends FarfetchedError<typeof NETWORK> {
    reason: string | null;
    cause?: unknown;
}
declare const CONFIGURATION = "CONFIGURATION";
interface ConfigurationError extends FarfetchedError<typeof CONFIGURATION> {
    validationErrors: string[];
}

declare type Serialize<Data> = NonNullable<Parameters<typeof createStore<Data>>[1]>['serialize'];

declare type Callback<Data, Result> = (data: Data) => Result;
declare type CallbackWithSource<Data, Result, Source> = {
    source: Store<Source>;
    fn: (data: Data, source: Source) => Result;
};
declare type DynamicallySourcedField<Data, Result, Source> = Callback<Data, Result> | CallbackWithSource<Data, Result, Source>;
declare type SourcedField<Data, Result, Source> = Result | Store<Result> | Callback<Data, Result> | CallbackWithSource<Data, Result, Source>;
declare function normalizeSourced<Data, Result, Source>(config: {
    field: SourcedField<Data, Result, Source>;
}): Store<(params: Data) => Result>;
declare function normalizeSourced<Data, Result, Source>(config: {
    field: SourcedField<Data, Result, Source>;
}): Store<(params: Data) => Result>;
declare type StaticOrReactive<T> = T | Store<Exclude<T, undefined>>;
declare function combineSourced<R extends Record<string, SourcedField<any, any, any>>, S>(config: R, mapper?: (v: {
    [Key in keyof R]: R[Key] extends SourcedField<any, infer D, any> ? D : never;
}) => S): CallbackWithSource<unknown, S, unknown>;

declare type FetchingStatus = 'initial' | 'pending' | 'done' | 'fail';

declare type CallObject = {
    id: string;
    /**
     * Rejectes promise with provided error and ignores rest of the handler
     *
     * @param error - Error to reject promise with, defaults to `OperationAborted` error
     */
    abort: (customError?: unknown) => void;
    /**
     * Status of the call
     *
     * For sync calls it is always `finished`
     */
    status: 'pending' | 'finished';
    /**
     * Promise of async handler calls,
     * it is resolved or rejected when handler is finished
     *
     * For sync handlers it is not presented
     */
    promise?: Promise<unknown>;
};

interface DefaultMeta {
    name: string;
}
interface RemoteOperation<Params, Data, Error, Meta, ExtraLowLevelAPI = {}> {
    /**
     * Reactive current request status
     *
     * + `initial` — the data has never been fetched yet
     * + 'pending' — the data is being fetched right now
     * + 'done' — the data has been successfully fetched
     * + 'fail' — an error occurred while fetching data
     */
    $status: Store<FetchingStatus>;
    /** Is fetching started? */
    $idle: Store<boolean>;
    /** Is fetching in progress right now? */
    $pending: Store<boolean>;
    /** Is fetching failed? */
    $failed: Store<boolean>;
    /** Is fetching succeeded? */
    $succeeded: Store<boolean>;
    /** Is fetching finished? */
    $finished: Store<boolean>;
    /**
     * Is operation enabled?
     *
     * + false — any `start` call will be ignored, event done.skip will be fired immediately
     * + true — query will be executed after any `start` call
     */
    $enabled: Store<boolean>;
    /** Event to trigger query */
    start: EventCallable<Params>;
    /** Event that trigered after operation started */
    started: Event<{
        params: Params;
        meta: ExecutionMeta;
    }>;
    aborted: Event<{
        params: Params;
        meta: ExecutionMeta;
    }>;
    /** Set of events that represent end of query */
    finished: {
        /** Query was successfully ended, data will be passed as a payload */
        success: Event<{
            params: Params;
            result: Data;
            meta: ExecutionMeta;
        }>;
        /** Query was failed, error will be passed as a payload */
        failure: Event<{
            params: Params;
            error: Error;
            meta: ExecutionMeta;
        }>;
        /** Query execution was skipped due to `enabled` field in config */
        skip: Event<{
            params: Params;
            meta: ExecutionMeta;
        }>;
        /** Query was ended, it merges `success`, `error` and `skip` */
        finally: Event<{
            params: Params;
            meta: ExecutionMeta;
        } & ({
            status: 'done';
            result: Data;
        } | {
            status: 'fail';
            error: Error;
        } | {
            status: 'skip';
        })>;
    };
    /**
     * DO NOT USE THIS FIELD IN PRODUCTION
     *
     * It is internal operator details which is useful for testing.
     */
    __: {
        /**
         * Internal effect, which executes to retrieve data.
         *
         * It must not be used in production. Please use it only for test purposes.
         *
         * @example
         *
         * import { locationQuery } from './location';
         *
         * test('some test', async () => {
         *   const scope = fork({
         *     handlers: [[locationQuery.__.executeFx, vi.fn()]]
         *   });
         *
         *   //...test code
         * })
         */
        executeFx: Effect<any, any, any>;
        /**
         * Meta information about operation and its configuration.
         */
        meta: Meta & DefaultMeta;
        /**
         * Distinguish different kinds of operations
         */
        kind: unknown;
        $latestParams: Store<Params | undefined>;
        /**
         * Low-level API, it can be changed anytime without any notice!
         */
        lowLevelAPI: {
            dataSources: Array<DataSource<Params>>;
            dataSourceRetrieverFx: Effect<{
                params: Params;
                meta: ExecutionMeta;
            }, {
                result: unknown;
                stale: boolean;
            }, any>;
            sourced: SourcedField<Params, unknown, unknown>[];
            paramsAreMeaningless: boolean;
            revalidate: EventCallable<{
                params: Params;
                refresh: boolean;
            }>;
            pushData: EventCallable<Data>;
            pushError: EventCallable<Error>;
            startWithMeta: EventCallable<{
                params: Params;
                meta: ExecutionMeta;
            }>;
            callObjectCreated: Event<CallObject>;
            resetStatus: EventCallable<void>;
        } & ExtraLowLevelAPI;
        experimentalAPI?: {
            attach: <Source, NewParams>(config: {
                source: Store<Source>;
                mapParams: (params: NewParams, source: Source) => Params;
            }) => any;
        };
    };
}
declare type RemoteOperationResult<Q extends RemoteOperation<any, any, any, any>> = EventPayload<Q['finished']['success']>['result'];
declare type RemoteOperationError<Q extends RemoteOperation<any, any, any, any>> = EventPayload<Q['finished']['failure']>['error'];
declare type RemoteOperationParams<Q extends RemoteOperation<any, any, any, any>> = EventPayload<Q['start']>;
interface ExecutionMeta {
    stopErrorPropagation: boolean;
    stale: boolean;
}
declare type DataSource<Params> = {
    name: string;
    get: Effect<{
        params: Params;
    }, {
        result: unknown;
        stale: boolean;
    } | null, unknown>;
    set?: Effect<{
        params: Params;
        result: unknown;
    }, void, unknown>;
    unset?: Effect<{
        params: Params;
    }, void, unknown>;
};

interface QueryMeta<Data, InitialData> {
    /**
     * This field is used to determine how to serialize data in various cases:
     * - transfer state from server to client during SSR
     * - save state to persistent storage during caching
     */
    serialize: Serialize<Data | InitialData>;
    initialData: InitialData;
    sid: string | null;
}
declare type QueryExtraLowLevelAPI = {
    refreshSkipDueToFreshness: Event<void>;
};
interface Query<Params, Data, Error, InitialData = null> extends RemoteOperation<Params, Data, Error, QueryMeta<Data, InitialData>, QueryExtraLowLevelAPI> {
    /**
     * Start fetching data if it is absent or stale.
     */
    refresh: EventCallable<Params>;
    /**
     * The reactive value of the latest received data.
     *
     * If there was an error during fetching or there has not been a request yet, the store will be `null`.
     */
    $data: Store<Data | InitialData>;
    /**
     * The reactive value of the data retrieval error.
     *
     * If the data was successfully fetched or there is no request yet, the store will be `null`.
     */
    $error: Store<Error | null>;
    /**
     * Is data stale?
     */
    $stale: StoreWritable<boolean>;
    /** Event to reset the whole state of the query */
    reset: EventCallable<void>;
    '@@unitShape': () => {
        data: Store<Data | InitialData>;
        error: Store<Error | null>;
        stale: Store<boolean>;
        pending: Store<boolean>;
        start: EventCallable<Params>;
    };
}
declare type QueryInitialData<Q extends Query<any, any, any, any>> = Q['__']['meta']['initialData'];

declare type ValidationResult = boolean | string | string[];
declare type Validator<Data, Params, ValidationSource> = DynamicallySourcedField<{
    result: Data;
    params: Params;
}, ValidationResult, ValidationSource>;

interface SharedQueryFactoryConfig<Data, Initial = Data> {
    name?: string;
    enabled?: StaticOrReactive<boolean>;
    serialize?: Serialize<Data | Initial>;
}
/**
 * Creates Query without any executor, it cannot be used as-is.
 *
 * @example
 * const headlessQuery = createHeadlessQuery()
 * headlessQuery.__.executeFx.use(someHandler)
 */
declare function createHeadlessQuery<Params, Response, Error, ContractData extends Response, MappedData, MapDataSource, ValidationSource, Initial = null>(config: {
    initialData?: Initial;
    contract: Contract<Response, ContractData>;
    mapData: DynamicallySourcedField<{
        result: ContractData;
        params: Params;
    }, MappedData, MapDataSource>;
    validate?: Validator<ContractData, Params, ValidationSource>;
    sourced?: SourcedField<Params, unknown, unknown>[];
    paramsAreMeaningless?: boolean;
} & SharedQueryFactoryConfig<MappedData, Initial>): Query<Params, MappedData, Error | InvalidDataError, Initial>;

declare function createQuery<Params, Response>(config: {
    handler: (p: Params) => Promise<Response>;
} & SharedQueryFactoryConfig<Response>): Query<Params, Response, unknown>;
declare function createQuery<Params, Response>(config: {
    initialData: Response;
    handler: (p: Params) => Promise<Response>;
} & SharedQueryFactoryConfig<Response>): Query<Params, Response, unknown, Response>;
declare function createQuery<Params, Response, Error, MappedData, MapDataSource = void, ValidationSource = void>(config: {
    effect: Effect<Params, Response, Error>;
    mapData: DynamicallySourcedField<{
        result: Response;
        params: Params;
    }, MappedData, MapDataSource>;
    validate?: Validator<MappedData, Params, ValidationSource>;
} & SharedQueryFactoryConfig<MappedData>): Query<Params, MappedData, Error>;
declare function createQuery<Params, Response, Error>(config: {
    effect: Effect<Params, Response, Error>;
} & SharedQueryFactoryConfig<Response>): Query<Params, Response, Error>;
declare function createQuery<Params, Response, Error>(config: {
    initialData: Response;
    effect: Effect<Params, Response, Error>;
} & SharedQueryFactoryConfig<Response>): Query<Params, Response, Error, Response>;
declare function createQuery<Params, Response, Error, ContractData extends Response, ValidationSource = void>(config: {
    effect: Effect<Params, Response, Error>;
    contract: Contract<Response, ContractData>;
    validate?: Validator<ContractData, Params, ValidationSource>;
} & SharedQueryFactoryConfig<ContractData>): Query<Params, ContractData, Error | InvalidDataError>;
declare function createQuery<Params, Response, Error, ContractData extends Response, ValidationSource = void>(config: {
    initialData: ContractData;
    effect: Effect<Params, Response, Error>;
    contract: Contract<Response, ContractData>;
    validate?: Validator<ContractData, Params, ValidationSource>;
} & SharedQueryFactoryConfig<ContractData>): Query<Params, ContractData, Error | InvalidDataError, ContractData>;
declare function createQuery<Params, Response, Error, MappedData, MapDataSource = void, ValidationSource = void>(config: {
    initialData: MappedData;
    effect: Effect<Params, Response, Error>;
    mapData: DynamicallySourcedField<{
        result: Response;
        params: Params;
    }, MappedData, MapDataSource>;
    validate?: Validator<MappedData, Params, ValidationSource>;
} & SharedQueryFactoryConfig<MappedData>): Query<Params, MappedData, Error, MappedData>;
declare function createQuery<Params, Response, Error, ContractData extends Response, MappedData, MapDataSource = void, ValidationSource = void>(config: {
    effect: Effect<Params, Response, Error>;
    contract: Contract<Response, ContractData>;
    mapData: DynamicallySourcedField<{
        result: ContractData;
        params: Params;
    }, MappedData, MapDataSource>;
    validate?: Validator<ContractData, Params, ValidationSource>;
} & SharedQueryFactoryConfig<MappedData>): Query<Params, MappedData, Error | InvalidDataError>;
declare function createQuery<Params, Response, Error, ContractData extends Response, MappedData, MapDataSource = void, ValidationSource = void>(config: {
    initialData: MappedData;
    effect: Effect<Params, Response, Error>;
    contract: Contract<Response, ContractData>;
    mapData: DynamicallySourcedField<{
        result: ContractData;
        params: Params;
    }, MappedData, MapDataSource>;
    validate?: Validator<ContractData, Params, ValidationSource>;
} & SharedQueryFactoryConfig<MappedData>): Query<Params, MappedData, Error | InvalidDataError, MappedData>;

declare type NonExtendable = {
    [K in string]: never;
};
declare function connectQuery<Sources, Target extends Query<any, any, any, any>>(args: {
    source: Sources;
    target: Target | [...Target[]];
} & (Target extends Query<infer P, any, any, any> ? P extends void ? {
    fn?: undefined;
} : Sources extends Query<any, any, any> ? {
    fn: (sources: {
        result: RemoteOperationResult<Sources>;
        params: RemoteOperationParams<Sources>;
    }) => {
        params: RemoteOperationParams<Target>;
    };
} : Sources extends Record<string, Query<any, any, any>> ? {
    fn: (sources: {
        [index in keyof Sources]: {
            result: RemoteOperationResult<Sources[index]>;
            params: RemoteOperationParams<Sources[index]>;
        };
    }) => {
        params: RemoteOperationParams<Target>;
    };
} : NonExtendable : NonExtendable)): void;

declare class Mutex {
    private _resolve;
    private _promise;
    get isLocked(): boolean;
    acquire(): void;
    waitForUnlock(): Promise<void>;
    release(): void;
}

declare type FetchApiRecord = Record<string, string | string[] | number | boolean | null | undefined>;

declare type HttpMethod = 'HEAD' | 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE' | 'QUERY' | 'OPTIONS';
declare type ApiRequestError = ConfigurationError | TimeoutError | PreparationError | NetworkError | HttpError;
declare type JsonApiRequestError = ApiRequestError | InvalidDataError;

interface ParamsDeclaration<T> {
    watch(cb: (payloaad: T) => void): Subscription;
}
declare function declareParams<T>(): ParamsDeclaration<T>;

declare type ConcurrencyConfig$1 = {
    strategy?: 'TAKE_EVERY' | 'TAKE_FIRST' | 'TAKE_LATEST';
    abort?: Event<void>;
};
declare type RequestConfig$1<Params, BodySource, QuerySource, HeadersSource, UrlSource> = {
    url: SourcedField<Params, string, UrlSource>;
    credentials?: RequestCredentials;
    query?: SourcedField<Params, FetchApiRecord, QuerySource> | SourcedField<Params, string, QuerySource>;
    headers?: SourcedField<Params, FetchApiRecord, HeadersSource>;
} & ({
    method: 'GET' | 'HEAD';
} | {
    method: Exclude<HttpMethod, 'GET' | 'HEAD'>;
    body?: SourcedField<Params, Json, BodySource>;
});
interface BaseJsonQueryConfigNoParams<Data, BodySource, QuerySource, HeadersSource, UrlSource> extends SharedQueryFactoryConfig<Data> {
    request: RequestConfig$1<void, BodySource, QuerySource, HeadersSource, UrlSource>;
    concurrency?: ConcurrencyConfig$1;
}
interface BaseJsonQueryConfigWithParams<Params, Data, BodySource, QuerySource, HeadersSource, UrlSource> extends SharedQueryFactoryConfig<Data> {
    params: ParamsDeclaration<Params>;
    request: RequestConfig$1<Params, BodySource, QuerySource, HeadersSource, UrlSource>;
    concurrency?: ConcurrencyConfig$1;
}
declare function createJsonQuery<Params, Data, TransformedData, BodySource = void, QuerySource = void, HeadersSource = void, UrlSource = void, DataSource = void, ValidationSource = void>(config: BaseJsonQueryConfigWithParams<Params, TransformedData, BodySource, QuerySource, HeadersSource, UrlSource> & {
    response: {
        contract: Contract<unknown, Data>;
        mapData: DynamicallySourcedField<{
            result: Data;
            params: Params;
        }, TransformedData, DataSource>;
        validate?: Validator<TransformedData, Params, ValidationSource>;
    };
}): Query<Params, TransformedData, JsonApiRequestError>;
declare function createJsonQuery<Params, Data, TransformedData, BodySource = void, QuerySource = void, HeadersSource = void, UrlSource = void, DataSource = void, ValidationSource = void>(config: BaseJsonQueryConfigWithParams<Params, TransformedData, BodySource, QuerySource, HeadersSource, UrlSource> & {
    initialData?: TransformedData;
    response: {
        contract: Contract<unknown, Data>;
        mapData: DynamicallySourcedField<{
            result: Data;
            params: Params;
        }, TransformedData, DataSource>;
        validate?: Validator<TransformedData, Params, ValidationSource>;
    };
}): Query<Params, TransformedData, JsonApiRequestError, TransformedData>;
declare function createJsonQuery<Params, Data, BodySource = void, QuerySource = void, HeadersSource = void, UrlSource = void, ValidationSource = void>(config: BaseJsonQueryConfigWithParams<Params, Data, BodySource, QuerySource, HeadersSource, UrlSource> & {
    response: {
        contract: Contract<unknown, Data>;
        validate?: Validator<Data, Params, ValidationSource>;
    };
}): Query<Params, Data, JsonApiRequestError>;
declare function createJsonQuery<Params, Data, BodySource = void, QuerySource = void, HeadersSource = void, UrlSource = void, ValidationSource = void>(config: BaseJsonQueryConfigWithParams<Params, Data, BodySource, QuerySource, HeadersSource, UrlSource> & {
    initialData?: Data;
    response: {
        contract: Contract<unknown, Data>;
        validate?: Validator<Data, Params, ValidationSource>;
    };
}): Query<Params, Data, JsonApiRequestError, Data>;
declare function createJsonQuery<Data, TransformedData, BodySource = void, QuerySource = void, HeadersSource = void, UrlSource = void, DataSource = void, ValidationSource = void>(config: BaseJsonQueryConfigNoParams<TransformedData, BodySource, QuerySource, HeadersSource, UrlSource> & {
    response: {
        contract: Contract<unknown, Data>;
        mapData: DynamicallySourcedField<{
            result: Data;
            params: void;
        }, TransformedData, DataSource>;
        validate?: Validator<TransformedData, void, ValidationSource>;
    };
}): Query<void, TransformedData, JsonApiRequestError>;
declare function createJsonQuery<Data, TransformedData, BodySource = void, QuerySource = void, HeadersSource = void, UrlSource = void, DataSource = void, ValidationSource = void>(config: BaseJsonQueryConfigNoParams<TransformedData, BodySource, QuerySource, HeadersSource, UrlSource> & {
    initialData?: TransformedData;
    response: {
        contract: Contract<unknown, Data>;
        mapData: DynamicallySourcedField<{
            result: Data;
            params: void;
        }, TransformedData, DataSource>;
        validate?: Validator<TransformedData, void, ValidationSource>;
    };
}): Query<void, TransformedData, JsonApiRequestError, TransformedData>;
declare function createJsonQuery<Data, BodySource = void, QuerySource = void, HeadersSource = void, UrlSource = void, ValidationSource = void>(config: BaseJsonQueryConfigNoParams<Data, BodySource, QuerySource, HeadersSource, UrlSource> & {
    response: {
        contract: Contract<unknown, Data>;
        validate?: Validator<Data, void, ValidationSource>;
    };
}): Query<void, Data, JsonApiRequestError>;
declare function createJsonQuery<Data, BodySource = void, QuerySource = void, HeadersSource = void, UrlSource = void, ValidationSource = void>(config: BaseJsonQueryConfigNoParams<Data, BodySource, QuerySource, HeadersSource, UrlSource> & {
    initialData?: Data;
    response: {
        contract: Contract<unknown, Data>;
        validate?: Validator<Data, void, ValidationSource>;
    };
}): Query<void, Data, JsonApiRequestError, Data>;

interface Mutation<Params, Data, Error> extends RemoteOperation<Params, Data, Error, null> {
    '@@unitShape': () => {
        start: EventCallable<Params>;
        pending: Store<boolean>;
    };
}

interface SharedMutationFactoryConfig {
    name?: string;
    enabled?: StaticOrReactive<boolean>;
}
declare function createHeadlessMutation<Params, Data, ContractData extends Data, MappedData, Error, MapDataSource = void, ValidationSource = void>(config: SharedMutationFactoryConfig & {
    contract: Contract<Data, ContractData>;
    validate?: Validator<ContractData, Params, ValidationSource>;
    mapData: DynamicallySourcedField<{
        result: ContractData;
        params: Params;
    }, MappedData, MapDataSource>;
}): Mutation<Params, MappedData, Error | InvalidDataError>;

declare function createMutation<Params, Data>(config: {
    handler: (params: Params) => Promise<Data>;
} & SharedMutationFactoryConfig): Mutation<Params, Data, unknown>;
declare function createMutation<Params, Data, Error>(config: {
    effect: Effect<Params, Data, Error>;
} & SharedMutationFactoryConfig): Mutation<Params, Data, Error>;
declare function createMutation<Params, Data, ContractData extends Data, Error>(config: {
    effect: Effect<Params, Data, Error>;
    contract: Contract<Data, ContractData>;
} & SharedMutationFactoryConfig): Mutation<Params, ContractData, Error | InvalidDataError>;

declare type ConcurrencyConfig = {
    abort?: Event<void>;
};
declare type RequestConfig<Params, BodySource, QuerySource, HeadersSource, UrlSource> = {
    url: SourcedField<Params, string, UrlSource>;
    credentials?: RequestCredentials;
    query?: SourcedField<Params, FetchApiRecord, QuerySource> | SourcedField<Params, string, QuerySource>;
    headers?: SourcedField<Params, FetchApiRecord, HeadersSource>;
} & ({
    method: 'GET' | 'HEAD';
} | {
    method: Exclude<HttpMethod, 'GET' | 'HEAD'>;
    body?: SourcedField<Params, Json, BodySource>;
});
interface BaseJsonMutationConfigNoParams<Data, BodySource, QuerySource, HeadersSource, UrlSource> extends SharedMutationFactoryConfig {
    request: RequestConfig<void, BodySource, QuerySource, HeadersSource, UrlSource>;
    concurrency?: ConcurrencyConfig;
}
interface BaseJsonMutationConfigWithParams<Params, Data, BodySource, QuerySource, HeadersSource, UrlSource> extends SharedMutationFactoryConfig {
    params: ParamsDeclaration<Params>;
    request: RequestConfig<Params, BodySource, QuerySource, HeadersSource, UrlSource>;
    concurrency?: ConcurrencyConfig;
}
declare function createJsonMutation<Params, Data, TransformedData, BodySource = void, QuerySource = void, HeadersSource = void, UrlSource = void, DataSource = void, ValidationSource = void>(config: BaseJsonMutationConfigWithParams<Params, TransformedData, BodySource, QuerySource, HeadersSource, UrlSource> & {
    response: {
        contract: Contract<unknown, Data>;
        mapData: DynamicallySourcedField<{
            result: Data;
            params: Params;
        }, TransformedData, DataSource>;
        validate?: Validator<TransformedData, Params, ValidationSource>;
        status?: {
            expected: number | number[];
        };
    };
}): Mutation<Params, TransformedData, JsonApiRequestError>;
declare function createJsonMutation<Params, Data, BodySource = void, QuerySource = void, HeadersSource = void, UrlSource = void, ValidationSource = void>(config: BaseJsonMutationConfigWithParams<Params, Data, BodySource, QuerySource, HeadersSource, UrlSource> & {
    response: {
        contract: Contract<unknown, Data>;
        validate?: Validator<Data, Params, ValidationSource>;
        status?: {
            expected: number | number[];
        };
    };
}): Mutation<Params, Data, JsonApiRequestError>;
declare function createJsonMutation<Data, TransformedData, BodySource = void, QuerySource = void, HeadersSource = void, UrlSource = void, DataSource = void, ValidationSource = void>(config: BaseJsonMutationConfigNoParams<TransformedData, BodySource, QuerySource, HeadersSource, UrlSource> & {
    response: {
        contract: Contract<unknown, Data>;
        mapData: DynamicallySourcedField<{
            result: Data;
            params: void;
        }, TransformedData, DataSource>;
        validate?: Validator<TransformedData, void, ValidationSource>;
        status?: {
            expected: number | number[];
        };
    };
}): Mutation<void, TransformedData, JsonApiRequestError>;
declare function createJsonMutation<Data, BodySource = void, QuerySource = void, HeadersSource = void, UrlSource = void, ValidationSource = void>(config: BaseJsonMutationConfigNoParams<Data, BodySource, QuerySource, HeadersSource, UrlSource> & {
    response: {
        contract: Contract<unknown, Data>;
        validate?: Validator<Data, void, ValidationSource>;
        status?: {
            expected: number | number[];
        };
    };
}): Mutation<void, Data, JsonApiRequestError>;

declare type MillisecondUnit = 'ms' | 'milli' | 'millisecond' | 'milliseconds';
declare type Millisecond = `${number}${MillisecondUnit}`;
declare type SecUnit = 's' | 'sec' | 'secs' | 'second' | 'seconds';
declare type Sec = `${number}${SecUnit}`;
declare type MinUnit = 'm' | 'min' | 'mins' | 'minute' | 'minutes';
declare type Min = `${number}${MinUnit}`;
declare type HourUnit = 'h' | 'hr' | 'hrs' | 'hour' | 'hours';
declare type Hour = `${number}${HourUnit}`;
declare type Time = `${Hour} ${Min} ${Sec}` | `${Hour} ${Min}` | `${Min} ${Sec}` | `${Hour}` | `${Min}` | `${Sec}` | `${Hour} ${Min} ${Sec} ${Millisecond}` | `${Hour} ${Min} ${Millisecond}` | `${Min} ${Sec} ${Millisecond}` | `${Hour} ${Millisecond}` | `${Min} ${Millisecond}` | `${Sec} ${Millisecond}` | `${Millisecond}` | number;

interface RetryMeta {
    attempt: number;
}

declare type FailInfo<Q extends RemoteOperation<any, any, any, any>> = {
    params: RemoteOperationParams<Q>;
    error: RemoteOperationError<Q>;
    meta: ExecutionMeta;
};
declare type RetryConfig<Q extends RemoteOperation<any, any, any, any>, DelaySource = unknown, FilterSource = unknown, MapParamsSource = unknown> = {
    times: StaticOrReactive<number>;
    delay: SourcedField<RetryMeta, Time, DelaySource>;
    filter?: SourcedField<FailInfo<Q>, boolean, FilterSource>;
    mapParams?: DynamicallySourcedField<FailInfo<Q> & {
        meta: RetryMeta;
    }, RemoteOperationParams<Q>, MapParamsSource>;
    otherwise?: EventCallable<FailInfo<Q>>;
    supressIntermediateErrors?: boolean;
};
declare function retry<Q extends RemoteOperation<any, any, any, any>, DelaySource = unknown, FilterSource = unknown, MapParamsSource = unknown>(operation: Q, { times, delay: timeout, filter, mapParams, ...params }: RetryConfig<Q, DelaySource, FilterSource, MapParamsSource>): void;

interface DelayOptions {
    randomize: {
        spread: number;
    };
}
declare function linearDelay(base: number, opts?: DelayOptions): ({ attempt }: RetryMeta) => number;
declare function exponentialDelay(base: number, opts?: DelayOptions): ({ attempt }: RetryMeta) => number;

/**
 *
 * Applies timeout to the operation - if operation is not finished in specified time, it will be aborted
 *
 * @param operation - Any remote operation, like Query or Mutation
 * @param config - Timeout config
 * @param config.after - Time after which operation will be aborted, can be human-readable string (like "100ms") or number in milliseconds, or effector's `Store` with any of these types
 */
declare function timeout<Q extends RemoteOperation<any, any, any, any>>(operation: Q, config: {
    after: StaticOrReactive<Time>;
}): void;

declare type QueryState<Q extends Query<any, any, any, any>> = {
    result: RemoteOperationResult<Q>;
    params: RemoteOperationParams<Q>;
} | {
    error: RemoteOperationError<Q>;
    params: RemoteOperationParams<Q>;
} | (QueryInitialData<Q> extends null ? null : {
    result: QueryInitialData<Q>;
});
declare type Refetch<Q extends Query<any, any, any, any>> = boolean | {
    params: RemoteOperationParams<Q>;
};
declare type RuleResult<Q extends Query<any, any, any, any>> = {
    result: RemoteOperationResult<Q>;
    refetch?: Refetch<Q>;
} | {
    error: RemoteOperationError<Q>;
    refetch?: Refetch<Q>;
};
declare function update<Q extends Query<any, any, any, any>, M extends Mutation<any, any, any>, BySuccessSource = void, ByFailureSource = void>(query: Q, { on: mutation, by: rules, }: {
    on: M;
    by: {
        success: DynamicallySourcedField<{
            query: QueryState<Q>;
            mutation: {
                result: RemoteOperationResult<M>;
                params: RemoteOperationParams<M>;
            };
        }, RuleResult<Q>, BySuccessSource>;
        failure?: DynamicallySourcedField<{
            query: QueryState<Q>;
            mutation: {
                error: RemoteOperationError<M>;
                params: RemoteOperationParams<M>;
            };
        }, RuleResult<Q>, ByFailureSource>;
    };
}): void;

declare function attachOperation<NewParams, Q extends Query<any, any, any, any>, Source>(operation: Q, config: {
    source: Store<Source>;
    mapParams: (params: NewParams, source: Source) => RemoteOperationParams<Q>;
}): Query<NewParams, RemoteOperationResult<Q>, RemoteOperationError<Q>, QueryInitialData<Q>>;
declare function attachOperation<NewParams, Q extends Query<any, any, any, any>>(operation: Q, config: {
    mapParams: (params: NewParams) => RemoteOperationParams<Q>;
}): Query<NewParams, RemoteOperationResult<Q>, RemoteOperationError<Q>, QueryInitialData<Q>>;
declare function attachOperation<Q extends Query<any, any, any, any>>(operation: Q): Q;
declare function attachOperation<NewParams, M extends Mutation<any, any, any>, Source>(operation: M, config: {
    source: Store<Source>;
    mapParams: (params: NewParams, source: Source) => RemoteOperationParams<M>;
}): Mutation<NewParams, RemoteOperationResult<M>, RemoteOperationError<M>>;
declare function attachOperation<NewParams, M extends Mutation<any, any, any>>(operation: M, config: {
    mapParams: (params: NewParams) => RemoteOperationParams<M>;
}): Mutation<NewParams, RemoteOperationResult<M>, RemoteOperationError<M>>;
declare function attachOperation<M extends Mutation<any, any, any>>(operation: M): M;

interface CacheAdapterInstance {
    get: Effect<{
        key: string;
    }, {
        value: unknown;
        cachedAt: number;
    } | null>;
    set: Effect<{
        key: string;
        value: unknown;
    }, void>;
    purge: EventCallable<void>;
    unset: Effect<{
        key: string;
    }, void>;
}
interface CacheAdapterOptions {
    maxEntries?: number;
    maxAge?: Time;
    observability?: {
        hit?: EventCallable<{
            key: string;
        }>;
        miss?: EventCallable<{
            key: string;
        }>;
        expired?: EventCallable<{
            key: string;
        }>;
        evicted?: EventCallable<{
            key: string;
        }>;
    };
}
interface CacheAdapter extends CacheAdapterInstance {
    __: {
        $instance: StoreWritable<CacheAdapterInstance>;
    };
}

interface CacheParameters {
    adapter?: CacheAdapter;
    staleAfter?: Time;
    purge?: Event<void>;
}
declare function cache<Q extends Query<any, any, any, any>>(query: Q, rawParams?: CacheParameters): void;

declare function inMemoryCache(config?: CacheAdapterOptions): CacheAdapter;

declare type SerializeConfig = {
    serialize?: {
        read: (value: Json) => unknown;
        write: (value: unknown) => Json;
    };
};

declare function localStorageCache(config?: CacheAdapterOptions & SerializeConfig): CacheAdapter;

declare function sessionStorageCache(config?: CacheAdapterOptions & SerializeConfig): CacheAdapter;

declare function voidCache(): CacheAdapter;

declare function createCacheAdapter(adapter: CacheAdapterInstance): CacheAdapter;

declare type JsonObject = Record<string, Json>;

/**
 * Effect wrapper for Fetch API
 *
 * It's used to declare static type of Error and mock requests in tests
 */
declare const fetchFx: effector.Effect<Request, Response, TypeError>;

declare function invalidDataError(config: {
    validationErrors: string[];
    response: unknown;
}): InvalidDataError;
declare function timeoutError(config: {
    timeout: number;
}): TimeoutError;
declare function abortError(): AbortError;
declare function preparationError(config: {
    response: string;
    reason: string | null;
}): PreparationError;
declare function httpError(config: {
    status: number;
    statusText: string;
    response: string | Json | null;
}): HttpError;
declare function networkError(config: {
    reason: string | null;
    cause?: unknown;
}): NetworkError;
declare function configurationError(config: {
    reason: string;
    validationErrors: string[];
}): ConfigurationError;

declare type WithError<T = any, P = Record<string, unknown>> = P & {
    error: T;
};
declare function isInvalidDataError(args: WithError): args is WithError<InvalidDataError>;
declare function isTimeoutError(args: WithError): args is WithError<TimeoutError>;
declare function isPreparationError(args: WithError): args is WithError<PreparationError>;
declare function isHttpError(args: WithError): args is WithError<HttpError>;
declare function isHttpErrorCode<Code extends number>(code: Code | Code[]): (args: WithError) => args is WithError<HttpError<Code>, Record<string, unknown>>;
declare function isNetworkError(args: WithError): args is WithError<NetworkError>;

declare type TriggerProtocol = {
    '@@trigger': () => {
        setup: EventCallable<void>;
        teardown: EventCallable<void>;
        fired: Event<unknown> | Event<void>;
    };
};

declare function keepFresh<Params>(query: Query<Params, any, any, any>, config: {
    automatically: true;
    enabled?: Store<boolean>;
}): void;
declare function keepFresh<Params>(query: Query<Params, any, any, any>, config: {
    triggers: Array<Event<any> | TriggerProtocol>;
    enabled?: Store<boolean>;
}): void;
declare function keepFresh<Params>(query: Query<Params, any, any, any>, config: {
    automatically: true;
    triggers: Array<Event<any> | TriggerProtocol>;
    enabled?: Store<boolean>;
}): void;

declare type Barrier = {
    /**
     * Is Barrier active?
     */
    $active: Store<boolean>;
    /**
     * Event that triggers every time when Barrier is activated or active Barrier is touched
     */
    activated: Event<void>;
    /**
     * Event that triggers every time when Barrier is deactivated or inactive Barrier is touched
     */
    deactivated: Event<void>;
    /**
     * Semi-private properties, you have to avoid using them
     */
    __: {
        /**
         * Call this event every time when operation with applied Barrier tries to start
         */
        touch: EventCallable<void>;
        /**
         * Call this event every time when operation with applied Barrier fails
         */
        operationFailed: EventCallable<{
            params: unknown;
            error: unknown;
        }>;
        /**
         * Call this event every time when operation with applied Barrier succeeds
         */
        operationDone: EventCallable<{
            params: unknown;
            result: unknown;
        }>;
        /**
         * Barrier ia based on Mutex, this store provides direct access to it
         */
        $mutex: Store<Mutex | null>;
    };
};

/**
 * Applies the Barrier to the Query or Mutation. After operation start it checks the Barrier .$active status and postpones the execution if the Barrier is active. After the Barrier is deactivated, it resumes the execution of the operation.
 *
 * @param operation Query or Mutation to apply Barrier to
 * @param config.barrier Barrier to apply
 */
declare function applyBarrier<O extends RemoteOperation<any, any, any, any, any>>(operation: O, { barrier }: {
    barrier: Barrier;
}): void;

declare type Performer = RemoteOperation<void, any, any, any> | Effect<void, any, any> | {
    start: EventCallable<void>;
    end: Event<any>;
};
/**
 * Creates new Barrier
 * @param config.active Store that holds the Barrier status
 * @param config.perform Array of Performers that should be started when active Barrier is touched
 */
declare function createBarrier(config: {
    active: Store<boolean>;
    perform?: Array<Performer>;
}): Barrier;
/**
 * Creates new Barrier
 * @param config.activateOn Event that will activate Barrier
 * @param config.deactivateOn Event that will deactivate Barrier
 */
declare function createBarrier(config: {
    activateOn: Event<any>;
    deactivateOn: Event<any>;
}): Barrier;
/**
 * Creates new Barrier
 * @param config.activateOn.failure A function that will be called every time when operation with applied Barrier fails. If it returns true, Barrier will be activated.
 * @param config.perform Array of Performers that should be started when active Barrier is touched
 */
declare function createBarrier(config: {
    activateOn: {
        failure: (options: {
            params: unknown;
            error: unknown;
        }) => boolean;
    };
    perform: Array<Performer>;
}): Barrier;

export { AbortError, Barrier, CacheAdapter, CacheAdapterOptions, ConfigurationError, Contract, DynamicallySourcedField, FarfetchedError, FetchApiRecord, FetchingStatus, HttpError, InvalidDataError, JsonApiRequestError, JsonObject, Mutation, NetworkError, ParamsDeclaration, PreparationError, Query, RemoteOperationError, RemoteOperationParams, RemoteOperationResult, SourcedField, TimeoutError, ValidationResult, Validator, abortError, applyBarrier, attachOperation, cache, combineSourced, configurationError, connectQuery, createBarrier, createCacheAdapter, createHeadlessMutation, createHeadlessQuery, createJsonMutation, createJsonQuery, createMutation, createQuery, declareParams, exponentialDelay, fetchFx, httpError, inMemoryCache, invalidDataError, isHttpError, isHttpErrorCode, isInvalidDataError, isNetworkError, isPreparationError, isTimeoutError, keepFresh, linearDelay, localStorageCache, networkError, normalizeSourced, preparationError, retry, sessionStorageCache, timeout, timeoutError, unknownContract, update, voidCache };
